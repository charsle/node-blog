{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":0},{"_id":"source/images/logo.png","path":"images/logo.png","modified":0,"renderable":0},{"_id":"source/images/logo@2x.png","path":"images/logo@2x.png","modified":0,"renderable":0},{"_id":"themes/anatole/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/blog_basic.css","path":"css/blog_basic.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/js/jquery-migrate-1.2.1.min.js","path":"js/jquery-migrate-1.2.1.min.js","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/js/jquery.appear.js","path":"js/jquery.appear.js","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/logo@2x.png","path":"images/logo@2x.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/anatole/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/anatole/.gitignore","hash":"9fcbb05b158b5d3ba1ee60d38889e05e8b0f3f2a","modified":1514225028000},{"_id":"source/.DS_Store","hash":"1b3a60537feb552f344d4f7f23e4ef4a9b4ee6cd","modified":1517133890355},{"_id":"themes/anatole/LICENSE","hash":"359cb81298c1fdbccf531548fc097466b0151be4","modified":1514225028000},{"_id":"themes/anatole/README.md","hash":"75a3829b8a316249ec0b4fd8eae2d371de879494","modified":1514225028000},{"_id":"themes/anatole/_config.sample.yml","hash":"c6bce49d93a37e9ed5f0c4b104decc0bd7832e04","modified":1517128647581},{"_id":"themes/anatole/package.json","hash":"cf731a3ebf3913747fccb6c4c6615eba7d7e88a4","modified":1514225028000},{"_id":"source/_posts/array.md","hash":"3611e3e2bb96fe68a19dfdca0fa81d4867e6b4d3","modified":1517132405304},{"_id":"source/_posts/git-opeation.md","hash":"a94e8bee491cdb0132e1726db9537ad99f71eddd","modified":1517132428000},{"_id":"source/_posts/info.md","hash":"e4053e3d44948c8973f49fc883a00016ea81a9a6","modified":1517132463285},{"_id":"source/_posts/index.md","hash":"c7294043224fa852ae2a33ab24db1152b3479858","modified":1517132422730},{"_id":"source/_posts/mobile.md","hash":"c8dc77d264a90dab43da9a1190f32694e144a744","modified":1517133580000},{"_id":"source/images/favicon.png","hash":"d659236704308954da9d64b101c4f54cc3f3255c","modified":1517127162689},{"_id":"source/languages/zh-cn.yml","hash":"dab1823e036f4adb3b7ae9efe95a37a15e47bec2","modified":1517131069426},{"_id":"source/languages/pt-BR.yml","hash":"ac5a0003d7793aade51f70643b2e2a631b6a65c3","modified":1517131069424},{"_id":"source/images/logo.png","hash":"41bdf2ebd8cc193ad82a211758af827d891b1a90","modified":1517127162691},{"_id":"source/images/logo@2x.png","hash":"49c3fa97724abf53861bf11356ea9ba5bcb11576","modified":1517127162692},{"_id":"themes/anatole/languages/pt-BR.yml","hash":"ac5a0003d7793aade51f70643b2e2a631b6a65c3","modified":1517128094038},{"_id":"themes/anatole/languages/zh-cn.yml","hash":"dab1823e036f4adb3b7ae9efe95a37a15e47bec2","modified":1514225028000},{"_id":"themes/anatole/layout/archive.pug","hash":"1a161404966000b25a84762f08da3ca60af146bc","modified":1514225028000},{"_id":"themes/anatole/layout/category.pug","hash":"ae894ef4baee4a0c7c8e66641166061e789f1fa7","modified":1514225028000},{"_id":"themes/anatole/layout/index.pug","hash":"53da3cfd498951148acb33de1574df80ae282dc5","modified":1514225028000},{"_id":"themes/anatole/layout/mixins.pug","hash":"107bfd2fe10de0d8b110c13bb1168af79e62a37c","modified":1514225028000},{"_id":"themes/anatole/layout/page.pug","hash":"15142c94e5c2247aba8efb64cffd695b3f133670","modified":1514225028000},{"_id":"themes/anatole/layout/post.pug","hash":"012f8e272cf4713a0f08e3b702dab08ef6593b31","modified":1514225028000},{"_id":"themes/anatole/layout/tag.pug","hash":"7017a8bae4f4a412dafb556772bdcf2cfddeb79f","modified":1514225028000},{"_id":"themes/anatole/layout/partial/comments.pug","hash":"fad5bbe7c2a134c892fcb1c731d979463145a49b","modified":1514225028000},{"_id":"themes/anatole/layout/partial/footer.pug","hash":"772f03a2dd9fa4fed422c4eb4d5d1ace84c65580","modified":1514225028000},{"_id":"themes/anatole/layout/partial/head.pug","hash":"3d6126d0b53a889a46ad61eb8cc0ab1b35446c49","modified":1514225028000},{"_id":"themes/anatole/layout/partial/layout.pug","hash":"174050fa9ee919f5bcb2c5426224ec1968db672c","modified":1514225028000},{"_id":"themes/anatole/layout/partial/sidebar.pug","hash":"6721b1e0b1e59e54d031a4978e7f82aece336efc","modified":1514225028000},{"_id":"themes/anatole/layout/partial/nav.pug","hash":"22b708ebb028e24cb556315a74a183c303d7778e","modified":1517128427228},{"_id":"themes/anatole/source/css/font-awesome.min.css","hash":"95d0b0c4d11105c81be1857b744076a1d2bed918","modified":1514225028000},{"_id":"themes/anatole/source/css/blog_basic.css","hash":"7db88f0873e858b21a4c981c8481708ad9117478","modified":1514225028000},{"_id":"themes/anatole/source/css/style.css","hash":"bf0acea70e383c7d3f81de8f5838c505800672f8","modified":1517126843000},{"_id":"themes/anatole/source/css/style.scss","hash":"175c9237798207f705c62777b5f51509adec6d0a","modified":1517126468513},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1514225028000},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1514225028000},{"_id":"themes/anatole/source/images/favicon.png","hash":"d659236704308954da9d64b101c4f54cc3f3255c","modified":1514225028000},{"_id":"themes/anatole/source/js/jquery-migrate-1.2.1.min.js","hash":"743052320809514fb788fe1d3df37fc87ce90452","modified":1514225028000},{"_id":"themes/anatole/source/images/logo.png","hash":"41bdf2ebd8cc193ad82a211758af827d891b1a90","modified":1514225028000},{"_id":"themes/anatole/source/js/jquery.appear.js","hash":"1f8067d7bd4c0bde30785e8016100f239e14394f","modified":1514225028000},{"_id":"themes/anatole/source/images/logo@2x.png","hash":"49c3fa97724abf53861bf11356ea9ba5bcb11576","modified":1514225028000},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1514225028000},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.svg","hash":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1514225028000},{"_id":"themes/anatole/source/js/jquery.js","hash":"bfc05b695dfa4f23e11d04b84993585da7a764bf","modified":1514225028000},{"_id":"public/languages/zh-cn.json","hash":"90bb7b87975df4890e62a79c471580dd174f3403","modified":1517134088105},{"_id":"public/languages/pt-BR.json","hash":"58bf225e557bb0318914c737030ce2c38cdaa073","modified":1517134088105},{"_id":"public/2018/01/28/info/index.html","hash":"ef4975bb7e0d14e5dd75edf435283b0ba64d88d2","modified":1517134088138},{"_id":"public/index.html","hash":"bced1477ff4db846e19a6fa8af37dec47d2b3f68","modified":1517134088139},{"_id":"public/archives/index.html","hash":"796eac154ef3696c0aea2db5b2eeee6aaca6f7b6","modified":1517134088139},{"_id":"public/archives/2018/index.html","hash":"796eac154ef3696c0aea2db5b2eeee6aaca6f7b6","modified":1517134088139},{"_id":"public/archives/2018/01/index.html","hash":"796eac154ef3696c0aea2db5b2eeee6aaca6f7b6","modified":1517134088139},{"_id":"public/tags/array-javascript-api/index.html","hash":"278d7f2b4b0fb5c88a15f4368d036575a025636e","modified":1517134088139},{"_id":"public/tags/git/index.html","hash":"3fbf9f6cf553dde375376fae4f6cadacebac921e","modified":1517134088139},{"_id":"public/tags/system-api-前端接口对接-后端/index.html","hash":"fdcee690893ef1fdfb30ef08db10642cf8fe3535","modified":1517134088139},{"_id":"public/tags/rem-px/index.html","hash":"0bfdcdc343537b4d7aab8939751932e56a58abf2","modified":1517134088140},{"_id":"public/2018/01/28/mobile/index.html","hash":"a03a80cf2f9482393e4554dd80f669731221c49a","modified":1517134088140},{"_id":"public/2018/01/28/git-opeation/index.html","hash":"c87348b357da0b2252d3c666d59bcc54430819ee","modified":1517134088140},{"_id":"public/2018/01/28/array/index.html","hash":"d758a3d62c8a182a599344eeddc76bc03144a2f2","modified":1517134088140},{"_id":"public/2018/01/28/index/index.html","hash":"1d4b8de23a3529a37f6f99d645c51c03622007ef","modified":1517134088140},{"_id":"public/images/favicon.png","hash":"d659236704308954da9d64b101c4f54cc3f3255c","modified":1517134088142},{"_id":"public/images/logo.png","hash":"41bdf2ebd8cc193ad82a211758af827d891b1a90","modified":1517134088142},{"_id":"public/images/logo@2x.png","hash":"49c3fa97724abf53861bf11356ea9ba5bcb11576","modified":1517134088142},{"_id":"public/css/style.scss","hash":"175c9237798207f705c62777b5f51509adec6d0a","modified":1517134088142},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1517134088143},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1517134088143},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1517134088145},{"_id":"public/css/blog_basic.css","hash":"7db88f0873e858b21a4c981c8481708ad9117478","modified":1517134088149},{"_id":"public/css/style.css","hash":"bf0acea70e383c7d3f81de8f5838c505800672f8","modified":1517134088149},{"_id":"public/js/jquery-migrate-1.2.1.min.js","hash":"743052320809514fb788fe1d3df37fc87ce90452","modified":1517134088149},{"_id":"public/js/jquery.appear.js","hash":"1f8067d7bd4c0bde30785e8016100f239e14394f","modified":1517134088149},{"_id":"public/css/font-awesome.min.css","hash":"95d0b0c4d11105c81be1857b744076a1d2bed918","modified":1517134088149},{"_id":"public/js/jquery.js","hash":"bfc05b695dfa4f23e11d04b84993585da7a764bf","modified":1517134088149},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1517134088155}],"Category":[],"Data":[],"Page":[{"_content":"prev: 上一页\nnext: 下一页\nprev_post: 上一篇\nnext_post: 下一篇\nHome: 首页\nAlbums: 相册\nCategories: 分类\nArchive: 归档\nTags: 标签\nAbout: 关于\nLinks: 友链\nComments: 评论\n","source":"languages/zh-cn.yml","raw":"prev: 上一页\nnext: 下一页\nprev_post: 上一篇\nnext_post: 下一篇\nHome: 首页\nAlbums: 相册\nCategories: 分类\nArchive: 归档\nTags: 标签\nAbout: 关于\nLinks: 友链\nComments: 评论\n","date":"2018-01-28T09:17:49.426Z","updated":"2018-01-28T09:17:49.426Z","path":"languages/zh-cn.json","layout":"false","title":"","comments":1,"_id":"cjcymfvsb0001s2gsw4wrgygm","content":"{\"prev\":\"上一页\",\"next\":\"下一页\",\"prev_post\":\"上一篇\",\"next_post\":\"下一篇\",\"Home\":\"首页\",\"Albums\":\"相册\",\"Categories\":\"分类\",\"Archive\":\"归档\",\"Tags\":\"标签\",\"About\":\"关于\",\"Links\":\"友链\",\"Comments\":\"评论\"}","site":{"data":{}},"excerpt":"","more":"{\"prev\":\"上一页\",\"next\":\"下一页\",\"prev_post\":\"上一篇\",\"next_post\":\"下一篇\",\"Home\":\"首页\",\"Albums\":\"相册\",\"Categories\":\"分类\",\"Archive\":\"归档\",\"Tags\":\"标签\",\"About\":\"关于\",\"Links\":\"友链\",\"Comments\":\"评论\"}"},{"_content":"prev: Anterior\nnext: Próximo\nprev_post: Post Anterior\nnext_post: Próximo post\nHome: Home\nAlbums: Álbums\nCategories: Categorias\nArchive: Arquivo\nTags: Tags\nAbout: Sobre\nLinks: Links\nComments: Comentários\n","source":"languages/pt-BR.yml","raw":"prev: Anterior\nnext: Próximo\nprev_post: Post Anterior\nnext_post: Próximo post\nHome: Home\nAlbums: Álbums\nCategories: Categorias\nArchive: Arquivo\nTags: Tags\nAbout: Sobre\nLinks: Links\nComments: Comentários\n","date":"2018-01-28T09:17:49.425Z","updated":"2018-01-28T09:17:49.424Z","path":"languages/pt-BR.json","layout":"false","title":"","comments":1,"_id":"cjcymfvse0003s2gsrw2d8i8w","content":"{\"prev\":\"Anterior\",\"next\":\"Próximo\",\"prev_post\":\"Post Anterior\",\"next_post\":\"Próximo post\",\"Home\":\"Home\",\"Albums\":\"Álbums\",\"Categories\":\"Categorias\",\"Archive\":\"Arquivo\",\"Tags\":\"Tags\",\"About\":\"Sobre\",\"Links\":\"Links\",\"Comments\":\"Comentários\"}","site":{"data":{}},"excerpt":"","more":"{\"prev\":\"Anterior\",\"next\":\"Próximo\",\"prev_post\":\"Post Anterior\",\"next_post\":\"Próximo post\",\"Home\":\"Home\",\"Albums\":\"Álbums\",\"Categories\":\"Categorias\",\"Archive\":\"Arquivo\",\"Tags\":\"Tags\",\"About\":\"Sobre\",\"Links\":\"Links\",\"Comments\":\"Comentários\"}"}],"Post":[{"title":"javascript Application Programming Interface","date":"2018-01-28T09:36:43.000Z","_content":"数组API\nAPI: Application Programming Interface,应用程序编程接口;\njs中对象提供的方法就叫做API；\ninstanceof\n检测一个对象是否是数组;(用来对付复杂数据类型;)\n// 简单数据类型 typeof ;\nA instanceof B  // A是不是B造出来的;\n例：\n    var arr = [1,2,3];\n    console.log(arr instanceof Array); //arr属不属于Array类型;\nArray.isArray( )\nArray.isArray(参数); // 判断参数是不是数组,返回布尔值;\n例：\n    var arr = [1,2,3];\n    var num = 123;\n    console.log(Array.isArray(arr)); //true\n    console.log(Array.isArray(num)); //false\ntoString( )\n数组.toString(); // 把数组变成字符串,去除了[],内容用逗号链接;\n例：\n    var arr = [\"aaa\",\"bbb\",\"ccc\"];\n    console.log(arr.toString());      //返回 aaa,bbb,ccc\nvalueOf( )\n数组.valueOf();  //返回数组本身;   \n例：\n    var arr = [\"aaa\",\"bbb\",\"ccc\"];\n    console.log(arr.valueOf());      //返回数组本身  [\"aaa\",\"bbb\",\"ccc\"]\n数组.join(参数)\n数组.join(参数);  // 数组中的元素可以按照参数进行链接变成一个字符串;\nconsole.log(arr.join());    //和toString()一样用逗号链接\nconsole.log(arr.join(\"|\")); //用参数链接\nconsole.log(arr.join(\"&\")); //用参数链接\nconsole.log(arr.join(\" \")); //如果是空格，真的用空格链接\nconsole.log(arr.join(\"\"));  //空字符是无缝连接\n数组元素的添加和删除\npush( )和pop( )\n1. 数组.push() //在数组的最末尾添加元素;\n2. 数组.pop()  //不需要参数;在数组的最末尾删除一项;\n例：\n    var arr = [1,2,3];\n    var aaa = arr.push(\"abc\");//在数组的最末尾添加一个元素;\n    console.log(arr);//元素被修改了\n    console.log(aaa);//返回值是数组的长度;\n \n    aaa = arr.pop();//不需要参数;在数组的最末尾删除一项;\n    console.log(arr);//元素被修改了\n    console.log(aaa);//被删除的那一项\nunshift( )和shift( )\n1. 数组.unshift() //在数组的最前面添加一个元素;\n2. 数组.shift()  //不需要参数;在数组的最前面删除一项;\n例：\n    var arr = [1,2,3];\n    aaa = arr.unshift(\"abc\");//在数组的最前面添加一个元素;\n    console.log(arr);//元素被修改了\n    console.log(aaa);//返回值是数组的长度;\n \n    aaa = arr.shift();//不需要参数;在数组的最前面删除一项;\n    console.log(arr);//元素被修改了\n    console.log(aaa);//被删除的那一项\n数组元素排序\nreverse( )\nreverse()   //翻转数组\n例:\n    var arr1 = [1,2,3,4,5];\n    var aaa = arr1.reverse(); // [5,4,3,2,1]\nsort( )\nsort() // 数组中元素排序;(默认：从小到大)\n      //  默认：按照首个字符的Unicode编码排序;如果第一个相同那么就比较第二个...\n例：        \n    var arr = [4,5,1,3,2,7,6];\n    var aaa =arr.sort();\n    console.log(aaa);          // [1, 2, 3, 4, 5, 6, 7]\n    console.log(aaa === arr);// true 原数组被排序了(冒泡排序)\n    //默认还可以排列字母;\n    var arr2 = [\"c\",\"e\",\"d\",\"a\",\"b\"];\n    var bbb = arr2.sort();\n    console.log(bbb);         // [\"a\", \"b\", \"c\", \"d\", \"e\"]\n    console.log(bbb===arr2); // true 原数组被排序了(冒泡排序)\n \nsort() //数值大小排序方法,需要借助回调函数;\n例：\n      var arr = [4,5,1,13,2,7,6];\n      //回调函数里面返回值如果是：参数1-参数2;升幂；   参数2-参数1;降幂；\n      arr.sort(function (a,b) {\n        return a-b; //升序\n        //return b-a; //降序\n        //return b.value-a.value; //按照元素value属性的大小排序;\n      });\n      console.log(arr); // [1, 2, 4, 5, 6, 7, 13]\nsort( )底层原理\n    var aaa = bubbleSort([1,12,3], function (a,b) {\n//        return a-b;//实参：array[j]-array[j+1]；\n        return b-a;//实参：array[j+1]-array[j]；\n    });\n    console.log(aaa);\n \n    function bubbleSort(array,fn){\n        //外循环控制轮数，内循环控制次数，都是元素个数-1;\n        for(var i=0;i<array.length-1;i++){ for(var=\"\" j=\"0;j<array.length-1-i;j++){//次数优化，多比较一轮，少比较一次;\" 满足条件交换位置;=\"\" if(array[j]=\"\">array[j+1]){//大于升幂排序；否则降幂;\n                //a-b>0  和  a>b是一个意思;\n                //b-a>0  和  a<b是一个意思; if(array[j]-array[j+1]=\"\">0){//升幂排序\n//                if(array[j+1]-array[j]>0){//降幂排序\n                //把两个变量送到一个函数中;\n                if(fn(array[j],array[j+1])>0){\n                    var temp = array[j];\n                    array[j] = array[j+1];\n                    array[j+1] = temp;\n                }\n            }\n        }\n        //返回数组\n        return array;\n    }\n</b是一个意思;></array.length-1;i++){>\n数组元素的操作\nconcat( )\n数组1.concat(数组2); // 链接两个数组;\nvar arr1 = [1,2,3];\nvar arr2 = [\"a\",\"b\",\"c\"];\nvar arr3 = arr1.concat(arr2);\nconsole.log(arr3)   //    [1, 2, 3, \"a\", \"b\", \"c\"]\nslice( )\n数组.slice(开始索引值，结束索引值);     //数组截取;\n例 ：\n      var arr = [1, 2, 3, \"a\", \"b\", \"c\"];\n      console.log(arr.slice(3));            //从索引值为3截取到最后;[\"a\", \"b\", \"c\"]\n      console.log(arr.slice(0,3));            //包左不包右;[1, 2, 3]\n      console.log(arr.slice(-2));            //负数是后几个;[\"b\", \"c\"]\n      console.log(arr.slice(3,0));            //如果前面的比后面的大，那么就是[];[]\n      console.log(arr);                          //原数组不被修改;[1, 2, 3, \"a\", \"b\", \"c\"]\nsplice( )\n数组.splice(开始索引值，删除几个，替换内容1，替换内容2，...);  // 替换和删除;\n                                                      //改变原数组;返回值是被删除/替换的内容\n例:\n    var arr = [1,2,3,4,5,6,\"a\", \"b\", \"c\"]\n    arr.splice(5);        //从索引值为3截取到最后;(删除)\n    console.log(arr);     // [1, 2, 3, 4, 5]\n    arr.splice(1,2);    //(删除指定个数)从索引为1的开始删除2个\n    console.log(arr);   //[1, 4, 5]\n \n//替换\n    var arr = [1,2,3,4,5,6,\"a\", \"b\", \"c\"];\n    console.log(arr.splice(3,3,\"aaa\",\"bbb\",\"ccc\"));    //(删除指定数并替换)\n    console.log(arr);     // [1, 2, 3, \"aaa\", \"bbb\", \"ccc\", \"a\", \"b\", \"c\"]\n//    添加\n    arr.splice(3,0,\"aaa\",\"bbb\",\"ccc\");//(删除指定个数)\n//\n    console.log(arr);//截取或者替换之后的;   [1, 2, 3, \"aaa\", \"bbb\", \"ccc\", \"aaa\", \"bbb\", \"ccc\", \"a\", \"b\", \"c\"]\nindexOf / lastIndexOf\n数组.indexOf(元素);      // 给元素，查索引(从前往后)\n数组.lastIndexOf(元素);  // 给元素，查索引(从后往前)\n例：\n    var arr = [\"a\",\"b\",\"c\",\"d\",\"c\",\"b\",\"b\"];\n    console.log(arr.indexOf(\"b\"));        // 1 查到以后立刻返回\n    console.log(arr.lastIndexOf(\"b\"));    // 6 找到以后立刻返回\n    console.log(arr.indexOf(\"xxx\"));    // -1;  查不到就返回-1；\n数组迭代(遍历)\nevery()\n对数组中每一项运行回调函数，如果都返回true，every返回true，\n如果有一项返回false，则停止遍历 every返回false；不写默认返回false\n像保镖失误一次，游戏结束！！！\n例：\n1.    var arr = [111,222,333,444,555];\n    arr.every(function (a,b,c) {\n        console.log(a);    //元素\n        console.log(b);    //索引值\n        console.log(c);    //数组本身;\n        console.log(\"-----\");    //数组本身;\n        //数组中元素赋值：c[b] = 值;      a=有时候无法赋值;\n        return true;\n    });\n \n2.  //every返回一个bool值，全部是true才是true；有一个是false，结果就是false\n    var bool = arr.every(function (element, index, array) {\n        //判断：我们定义所有元素都大于200;\n        //if(element > 100){\n        if(element > 200){\n            return true;\n        }else{\n            return false;\n        }\n    })\n    alert(bool); //false\nfilter()\n//   对数组中每一项运行回调函数，该函数返回结果是true的项组成的新数组\n//     新数组是有老数组中的元素组成的，return为ture的项;\n例：\n    var arr = [111,222,333,444,555];\n    var newArr = arr.filter(function (element, index, array) {\n        //只要是奇数，就组成数组;(数组中辨别元素)\n        if(element%2 === 0){\n            return true;\n        }else{\n            return false;\n        }\n    })\n \n    console.log(newArr); // [222, 444]\nforEach()\n// 和for循环一样；没有返回值;\n例：\n    var arr = [111,222,333,444,555];\n    var sum = 0;\n    var aaa = arr.forEach(function (element,index,array) {\n        console.log(element); // 输出数组中的每一个元素\n        console.log(index); // 数组元素对应的索引值\n        console.log(array); // 数组本身 [111, 222, 333, 444, 555]\n        sum += element; //数组中元素求和;\n    });\n    console.log(sum); // 数组元素加起来的和\n    console.log(aaa);//undefined；没有返回值 所以返回undefined\nmap()\n//  对数组中每一项运行回调函数，返回该函数的结果组成的新数组\n//    return什么新数组中就有什么; 不return返回undefined; 对数组二次加工\n例：\n    var arr = [111,222,333,444,555];\n    var newArr = arr.map(function (element, index, array) {\n        if(index == 2){\n            return element; // 这里return了 所以下面返回的值是333\n        }\n        return element*100; // 返回的元素值都乘上100后的值\n    })\n    console.log(newArr); // [11100, 22200, 333, 44400, 55500]\nsome()\n//对数组中每一项运行回调函数，如果该函数对某一项返回true，则some返回true; 像杀手，有一个成功，就胜利了！！！\n例：\n    var arr = [111,222,333,444,555];\n    var bool = arr.some(function (ele,i,array) {\n        //判断：数组中有3的倍数\n        if(ele%3 == 0){\n            return true;\n        }\n        return false;\n    })\n    alert(bool); //true ; 有一个成功就是true\n数组清空\n    1. arr.length = 0; // (不好，伪数组无法清空)\n    2. arr.splice(0); // 伪数组没有这个方法;\n    3. arr = [];     // 可以操作伪数组; (推荐!)\n \n// 伪数组: 就是长的像数组，但是没有数组的方法;也不能添加和删除元素;\n例： // arguments\n        fn(111,222,333);\n        function fn(){\n            arguments.length = 0; // 无法清空 返回 [1, 2, 3]\n           arguments.splice(0); // 会报错 arguments.splice is not a function\n            arguments = []; // 可以清空,返回空数组[] \n            console.log(arguments);\n        }\n数组案例\n1.将一个字符串数组输出为|分割的形式，比如“刘备|张飞|关羽”。使用两种方式实现\n \n       var arr = [\"刘备\",\"张飞\",\"关羽\"];\n       var separator = \"|\";\n       //通过for循环累加\n       var str = arr[0];\n       for(var i=1;i<arr.length;i++){\n           str += separator+arr[i];\n       }\n       console.log(str); // 刘备|张飞|关羽\n       //join()可以把数组中的元素链接成字符串;\n       console.log(arr.join(\"|\")); // 刘备|张飞|关羽\n2.将一个字符串数组的元素的顺序进行反转。[\"a\", \"b\", \"c\", \"d\"] -> [ \"d\",\"c\",\"b\",\"a\"]。使用两种种方式实现。提示：第i个和第length-i-1个进行交换\n \n  // 数组.reverse() 方法\n           var arr = [\"a\", \"b\", \"c\", \"d\"];\n           console.log(arr.reverse()); // [\"d\", \"c\", \"b\", \"a\"]\n        \n       //  三种：1.正向遍历，反向添加;  2.反向遍历，正向添加;   3.元数组元素交换位置;\n           for(var i=0;i<arr.length/2;i++){\n               var temp = arr[i];\n               arr[i] = arr[arr.length-1-i];\n               arr[arr.length-1-i] = temp;\n           }\n           console.log(arr);\n3.工资的数组[1500, 1200, 2000, 2100, 1800],把工资超过2000的删除\n \n   var arr = [1500, 1200, 2000, 2100, 1800];\n   //利用filter()形成一个数组;return true;组成的数组;\n   var newArr = arr.filter(function (ele, i, array) {\n       //2000以上返回false;\n       if(ele<2000){\n           return true;\n       }else{\n           return false;\n       }\n   });\n   console.log(newArr); // [1500, 1200, 1800]\n4.[\"c\", \"a\", \"z\", \"a\", \"x\", \"a\"]找到数组中每一个a出现的位置\n \n   var arr = [\"c\", \"a\", \"z\", \"a\", \"x\", \"a\"];\n   //遍历数组(for/while/do...while)    forEach();\n   arr.forEach(function (ele, index, array) {\n       //如果元素等于“a”，那么就输出索引值；\n       if(\"a\" === ele){\n           console.log(index);\n       }\n   });\n5.编写一个方法去掉一个数组的重复元素 (数组去重)\n \n       var arr = [\"鸣人\",\"鸣人\",\"佐助\",\"佐助\",\"小樱\",\"小樱\"];\n   //  方法1：  思路：定义一个新数组，遍历老数组，判断，如果新数组里面没有老数组的元素就添加，否则就不添加；\n       var newArr = [];\n       //遍历老数组\n       arr.forEach(function (ele,index,array) {\n           //检测老数组中的元素，如果新数组中存在就不添加了，不存在才添加;\n           if(newArr.indexOf(ele) === -1){//不存在就添加;（去新数组中查找元素索引值，如果为-1就是没有）\n               newArr.push(ele);\n           }\n       });\n       console.log(newArr); // [\"鸣人\", \"佐助\", \"小樱\"]\n","source":"_posts/array.md","raw":"---\ntitle: javascript Application Programming Interface\ndate: 2018-01-28 17:36:43\ntags: array, javascript, api\n---\n数组API\nAPI: Application Programming Interface,应用程序编程接口;\njs中对象提供的方法就叫做API；\ninstanceof\n检测一个对象是否是数组;(用来对付复杂数据类型;)\n// 简单数据类型 typeof ;\nA instanceof B  // A是不是B造出来的;\n例：\n    var arr = [1,2,3];\n    console.log(arr instanceof Array); //arr属不属于Array类型;\nArray.isArray( )\nArray.isArray(参数); // 判断参数是不是数组,返回布尔值;\n例：\n    var arr = [1,2,3];\n    var num = 123;\n    console.log(Array.isArray(arr)); //true\n    console.log(Array.isArray(num)); //false\ntoString( )\n数组.toString(); // 把数组变成字符串,去除了[],内容用逗号链接;\n例：\n    var arr = [\"aaa\",\"bbb\",\"ccc\"];\n    console.log(arr.toString());      //返回 aaa,bbb,ccc\nvalueOf( )\n数组.valueOf();  //返回数组本身;   \n例：\n    var arr = [\"aaa\",\"bbb\",\"ccc\"];\n    console.log(arr.valueOf());      //返回数组本身  [\"aaa\",\"bbb\",\"ccc\"]\n数组.join(参数)\n数组.join(参数);  // 数组中的元素可以按照参数进行链接变成一个字符串;\nconsole.log(arr.join());    //和toString()一样用逗号链接\nconsole.log(arr.join(\"|\")); //用参数链接\nconsole.log(arr.join(\"&\")); //用参数链接\nconsole.log(arr.join(\" \")); //如果是空格，真的用空格链接\nconsole.log(arr.join(\"\"));  //空字符是无缝连接\n数组元素的添加和删除\npush( )和pop( )\n1. 数组.push() //在数组的最末尾添加元素;\n2. 数组.pop()  //不需要参数;在数组的最末尾删除一项;\n例：\n    var arr = [1,2,3];\n    var aaa = arr.push(\"abc\");//在数组的最末尾添加一个元素;\n    console.log(arr);//元素被修改了\n    console.log(aaa);//返回值是数组的长度;\n \n    aaa = arr.pop();//不需要参数;在数组的最末尾删除一项;\n    console.log(arr);//元素被修改了\n    console.log(aaa);//被删除的那一项\nunshift( )和shift( )\n1. 数组.unshift() //在数组的最前面添加一个元素;\n2. 数组.shift()  //不需要参数;在数组的最前面删除一项;\n例：\n    var arr = [1,2,3];\n    aaa = arr.unshift(\"abc\");//在数组的最前面添加一个元素;\n    console.log(arr);//元素被修改了\n    console.log(aaa);//返回值是数组的长度;\n \n    aaa = arr.shift();//不需要参数;在数组的最前面删除一项;\n    console.log(arr);//元素被修改了\n    console.log(aaa);//被删除的那一项\n数组元素排序\nreverse( )\nreverse()   //翻转数组\n例:\n    var arr1 = [1,2,3,4,5];\n    var aaa = arr1.reverse(); // [5,4,3,2,1]\nsort( )\nsort() // 数组中元素排序;(默认：从小到大)\n      //  默认：按照首个字符的Unicode编码排序;如果第一个相同那么就比较第二个...\n例：        \n    var arr = [4,5,1,3,2,7,6];\n    var aaa =arr.sort();\n    console.log(aaa);          // [1, 2, 3, 4, 5, 6, 7]\n    console.log(aaa === arr);// true 原数组被排序了(冒泡排序)\n    //默认还可以排列字母;\n    var arr2 = [\"c\",\"e\",\"d\",\"a\",\"b\"];\n    var bbb = arr2.sort();\n    console.log(bbb);         // [\"a\", \"b\", \"c\", \"d\", \"e\"]\n    console.log(bbb===arr2); // true 原数组被排序了(冒泡排序)\n \nsort() //数值大小排序方法,需要借助回调函数;\n例：\n      var arr = [4,5,1,13,2,7,6];\n      //回调函数里面返回值如果是：参数1-参数2;升幂；   参数2-参数1;降幂；\n      arr.sort(function (a,b) {\n        return a-b; //升序\n        //return b-a; //降序\n        //return b.value-a.value; //按照元素value属性的大小排序;\n      });\n      console.log(arr); // [1, 2, 4, 5, 6, 7, 13]\nsort( )底层原理\n    var aaa = bubbleSort([1,12,3], function (a,b) {\n//        return a-b;//实参：array[j]-array[j+1]；\n        return b-a;//实参：array[j+1]-array[j]；\n    });\n    console.log(aaa);\n \n    function bubbleSort(array,fn){\n        //外循环控制轮数，内循环控制次数，都是元素个数-1;\n        for(var i=0;i<array.length-1;i++){ for(var=\"\" j=\"0;j<array.length-1-i;j++){//次数优化，多比较一轮，少比较一次;\" 满足条件交换位置;=\"\" if(array[j]=\"\">array[j+1]){//大于升幂排序；否则降幂;\n                //a-b>0  和  a>b是一个意思;\n                //b-a>0  和  a<b是一个意思; if(array[j]-array[j+1]=\"\">0){//升幂排序\n//                if(array[j+1]-array[j]>0){//降幂排序\n                //把两个变量送到一个函数中;\n                if(fn(array[j],array[j+1])>0){\n                    var temp = array[j];\n                    array[j] = array[j+1];\n                    array[j+1] = temp;\n                }\n            }\n        }\n        //返回数组\n        return array;\n    }\n</b是一个意思;></array.length-1;i++){>\n数组元素的操作\nconcat( )\n数组1.concat(数组2); // 链接两个数组;\nvar arr1 = [1,2,3];\nvar arr2 = [\"a\",\"b\",\"c\"];\nvar arr3 = arr1.concat(arr2);\nconsole.log(arr3)   //    [1, 2, 3, \"a\", \"b\", \"c\"]\nslice( )\n数组.slice(开始索引值，结束索引值);     //数组截取;\n例 ：\n      var arr = [1, 2, 3, \"a\", \"b\", \"c\"];\n      console.log(arr.slice(3));            //从索引值为3截取到最后;[\"a\", \"b\", \"c\"]\n      console.log(arr.slice(0,3));            //包左不包右;[1, 2, 3]\n      console.log(arr.slice(-2));            //负数是后几个;[\"b\", \"c\"]\n      console.log(arr.slice(3,0));            //如果前面的比后面的大，那么就是[];[]\n      console.log(arr);                          //原数组不被修改;[1, 2, 3, \"a\", \"b\", \"c\"]\nsplice( )\n数组.splice(开始索引值，删除几个，替换内容1，替换内容2，...);  // 替换和删除;\n                                                      //改变原数组;返回值是被删除/替换的内容\n例:\n    var arr = [1,2,3,4,5,6,\"a\", \"b\", \"c\"]\n    arr.splice(5);        //从索引值为3截取到最后;(删除)\n    console.log(arr);     // [1, 2, 3, 4, 5]\n    arr.splice(1,2);    //(删除指定个数)从索引为1的开始删除2个\n    console.log(arr);   //[1, 4, 5]\n \n//替换\n    var arr = [1,2,3,4,5,6,\"a\", \"b\", \"c\"];\n    console.log(arr.splice(3,3,\"aaa\",\"bbb\",\"ccc\"));    //(删除指定数并替换)\n    console.log(arr);     // [1, 2, 3, \"aaa\", \"bbb\", \"ccc\", \"a\", \"b\", \"c\"]\n//    添加\n    arr.splice(3,0,\"aaa\",\"bbb\",\"ccc\");//(删除指定个数)\n//\n    console.log(arr);//截取或者替换之后的;   [1, 2, 3, \"aaa\", \"bbb\", \"ccc\", \"aaa\", \"bbb\", \"ccc\", \"a\", \"b\", \"c\"]\nindexOf / lastIndexOf\n数组.indexOf(元素);      // 给元素，查索引(从前往后)\n数组.lastIndexOf(元素);  // 给元素，查索引(从后往前)\n例：\n    var arr = [\"a\",\"b\",\"c\",\"d\",\"c\",\"b\",\"b\"];\n    console.log(arr.indexOf(\"b\"));        // 1 查到以后立刻返回\n    console.log(arr.lastIndexOf(\"b\"));    // 6 找到以后立刻返回\n    console.log(arr.indexOf(\"xxx\"));    // -1;  查不到就返回-1；\n数组迭代(遍历)\nevery()\n对数组中每一项运行回调函数，如果都返回true，every返回true，\n如果有一项返回false，则停止遍历 every返回false；不写默认返回false\n像保镖失误一次，游戏结束！！！\n例：\n1.    var arr = [111,222,333,444,555];\n    arr.every(function (a,b,c) {\n        console.log(a);    //元素\n        console.log(b);    //索引值\n        console.log(c);    //数组本身;\n        console.log(\"-----\");    //数组本身;\n        //数组中元素赋值：c[b] = 值;      a=有时候无法赋值;\n        return true;\n    });\n \n2.  //every返回一个bool值，全部是true才是true；有一个是false，结果就是false\n    var bool = arr.every(function (element, index, array) {\n        //判断：我们定义所有元素都大于200;\n        //if(element > 100){\n        if(element > 200){\n            return true;\n        }else{\n            return false;\n        }\n    })\n    alert(bool); //false\nfilter()\n//   对数组中每一项运行回调函数，该函数返回结果是true的项组成的新数组\n//     新数组是有老数组中的元素组成的，return为ture的项;\n例：\n    var arr = [111,222,333,444,555];\n    var newArr = arr.filter(function (element, index, array) {\n        //只要是奇数，就组成数组;(数组中辨别元素)\n        if(element%2 === 0){\n            return true;\n        }else{\n            return false;\n        }\n    })\n \n    console.log(newArr); // [222, 444]\nforEach()\n// 和for循环一样；没有返回值;\n例：\n    var arr = [111,222,333,444,555];\n    var sum = 0;\n    var aaa = arr.forEach(function (element,index,array) {\n        console.log(element); // 输出数组中的每一个元素\n        console.log(index); // 数组元素对应的索引值\n        console.log(array); // 数组本身 [111, 222, 333, 444, 555]\n        sum += element; //数组中元素求和;\n    });\n    console.log(sum); // 数组元素加起来的和\n    console.log(aaa);//undefined；没有返回值 所以返回undefined\nmap()\n//  对数组中每一项运行回调函数，返回该函数的结果组成的新数组\n//    return什么新数组中就有什么; 不return返回undefined; 对数组二次加工\n例：\n    var arr = [111,222,333,444,555];\n    var newArr = arr.map(function (element, index, array) {\n        if(index == 2){\n            return element; // 这里return了 所以下面返回的值是333\n        }\n        return element*100; // 返回的元素值都乘上100后的值\n    })\n    console.log(newArr); // [11100, 22200, 333, 44400, 55500]\nsome()\n//对数组中每一项运行回调函数，如果该函数对某一项返回true，则some返回true; 像杀手，有一个成功，就胜利了！！！\n例：\n    var arr = [111,222,333,444,555];\n    var bool = arr.some(function (ele,i,array) {\n        //判断：数组中有3的倍数\n        if(ele%3 == 0){\n            return true;\n        }\n        return false;\n    })\n    alert(bool); //true ; 有一个成功就是true\n数组清空\n    1. arr.length = 0; // (不好，伪数组无法清空)\n    2. arr.splice(0); // 伪数组没有这个方法;\n    3. arr = [];     // 可以操作伪数组; (推荐!)\n \n// 伪数组: 就是长的像数组，但是没有数组的方法;也不能添加和删除元素;\n例： // arguments\n        fn(111,222,333);\n        function fn(){\n            arguments.length = 0; // 无法清空 返回 [1, 2, 3]\n           arguments.splice(0); // 会报错 arguments.splice is not a function\n            arguments = []; // 可以清空,返回空数组[] \n            console.log(arguments);\n        }\n数组案例\n1.将一个字符串数组输出为|分割的形式，比如“刘备|张飞|关羽”。使用两种方式实现\n \n       var arr = [\"刘备\",\"张飞\",\"关羽\"];\n       var separator = \"|\";\n       //通过for循环累加\n       var str = arr[0];\n       for(var i=1;i<arr.length;i++){\n           str += separator+arr[i];\n       }\n       console.log(str); // 刘备|张飞|关羽\n       //join()可以把数组中的元素链接成字符串;\n       console.log(arr.join(\"|\")); // 刘备|张飞|关羽\n2.将一个字符串数组的元素的顺序进行反转。[\"a\", \"b\", \"c\", \"d\"] -> [ \"d\",\"c\",\"b\",\"a\"]。使用两种种方式实现。提示：第i个和第length-i-1个进行交换\n \n  // 数组.reverse() 方法\n           var arr = [\"a\", \"b\", \"c\", \"d\"];\n           console.log(arr.reverse()); // [\"d\", \"c\", \"b\", \"a\"]\n        \n       //  三种：1.正向遍历，反向添加;  2.反向遍历，正向添加;   3.元数组元素交换位置;\n           for(var i=0;i<arr.length/2;i++){\n               var temp = arr[i];\n               arr[i] = arr[arr.length-1-i];\n               arr[arr.length-1-i] = temp;\n           }\n           console.log(arr);\n3.工资的数组[1500, 1200, 2000, 2100, 1800],把工资超过2000的删除\n \n   var arr = [1500, 1200, 2000, 2100, 1800];\n   //利用filter()形成一个数组;return true;组成的数组;\n   var newArr = arr.filter(function (ele, i, array) {\n       //2000以上返回false;\n       if(ele<2000){\n           return true;\n       }else{\n           return false;\n       }\n   });\n   console.log(newArr); // [1500, 1200, 1800]\n4.[\"c\", \"a\", \"z\", \"a\", \"x\", \"a\"]找到数组中每一个a出现的位置\n \n   var arr = [\"c\", \"a\", \"z\", \"a\", \"x\", \"a\"];\n   //遍历数组(for/while/do...while)    forEach();\n   arr.forEach(function (ele, index, array) {\n       //如果元素等于“a”，那么就输出索引值；\n       if(\"a\" === ele){\n           console.log(index);\n       }\n   });\n5.编写一个方法去掉一个数组的重复元素 (数组去重)\n \n       var arr = [\"鸣人\",\"鸣人\",\"佐助\",\"佐助\",\"小樱\",\"小樱\"];\n   //  方法1：  思路：定义一个新数组，遍历老数组，判断，如果新数组里面没有老数组的元素就添加，否则就不添加；\n       var newArr = [];\n       //遍历老数组\n       arr.forEach(function (ele,index,array) {\n           //检测老数组中的元素，如果新数组中存在就不添加了，不存在才添加;\n           if(newArr.indexOf(ele) === -1){//不存在就添加;（去新数组中查找元素索引值，如果为-1就是没有）\n               newArr.push(ele);\n           }\n       });\n       console.log(newArr); // [\"鸣人\", \"佐助\", \"小樱\"]\n","slug":"array","published":1,"updated":"2018-01-28T09:40:05.304Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcymfvs70000s2gssh4no3n8","content":"<p>数组API<br>API: Application Programming Interface,应用程序编程接口;<br>js中对象提供的方法就叫做API；<br>instanceof<br>检测一个对象是否是数组;(用来对付复杂数据类型;)<br>// 简单数据类型 typeof ;<br>A instanceof B  // A是不是B造出来的;<br>例：<br>    var arr = [1,2,3];<br>    console.log(arr instanceof Array); //arr属不属于Array类型;<br>Array.isArray( )<br>Array.isArray(参数); // 判断参数是不是数组,返回布尔值;<br>例：<br>    var arr = [1,2,3];<br>    var num = 123;<br>    console.log(Array.isArray(arr)); //true<br>    console.log(Array.isArray(num)); //false<br>toString( )<br>数组.toString(); // 把数组变成字符串,去除了[],内容用逗号链接;<br>例：<br>    var arr = [“aaa”,”bbb”,”ccc”];<br>    console.log(arr.toString());      //返回 aaa,bbb,ccc<br>valueOf( )<br>数组.valueOf();  //返回数组本身;<br>例：<br>    var arr = [“aaa”,”bbb”,”ccc”];<br>    console.log(arr.valueOf());      //返回数组本身  [“aaa”,”bbb”,”ccc”]<br>数组.join(参数)<br>数组.join(参数);  // 数组中的元素可以按照参数进行链接变成一个字符串;<br>console.log(arr.join());    //和toString()一样用逗号链接<br>console.log(arr.join(“|”)); //用参数链接<br>console.log(arr.join(“&amp;”)); //用参数链接<br>console.log(arr.join(“ “)); //如果是空格，真的用空格链接<br>console.log(arr.join(“”));  //空字符是无缝连接<br>数组元素的添加和删除<br>push( )和pop( )</p>\n<ol>\n<li>数组.push() //在数组的最末尾添加元素;</li>\n<li><p>数组.pop()  //不需要参数;在数组的最末尾删除一项;<br>例：<br> var arr = [1,2,3];<br> var aaa = arr.push(“abc”);//在数组的最末尾添加一个元素;<br> console.log(arr);//元素被修改了<br> console.log(aaa);//返回值是数组的长度;</p>\n<p> aaa = arr.pop();//不需要参数;在数组的最末尾删除一项;<br> console.log(arr);//元素被修改了<br> console.log(aaa);//被删除的那一项<br>unshift( )和shift( )</p>\n</li>\n<li>数组.unshift() //在数组的最前面添加一个元素;</li>\n<li><p>数组.shift()  //不需要参数;在数组的最前面删除一项;<br>例：<br> var arr = [1,2,3];<br> aaa = arr.unshift(“abc”);//在数组的最前面添加一个元素;<br> console.log(arr);//元素被修改了<br> console.log(aaa);//返回值是数组的长度;</p>\n<p> aaa = arr.shift();//不需要参数;在数组的最前面删除一项;<br> console.log(arr);//元素被修改了<br> console.log(aaa);//被删除的那一项<br>数组元素排序<br>reverse( )<br>reverse()   //翻转数组<br>例:<br> var arr1 = [1,2,3,4,5];<br> var aaa = arr1.reverse(); // [5,4,3,2,1]<br>sort( )<br>sort() // 数组中元素排序;(默认：从小到大)<br>   //  默认：按照首个字符的Unicode编码排序;如果第一个相同那么就比较第二个…<br>例：<br> var arr = [4,5,1,3,2,7,6];<br> var aaa =arr.sort();<br> console.log(aaa);          // [1, 2, 3, 4, 5, 6, 7]<br> console.log(aaa === arr);// true 原数组被排序了(冒泡排序)<br> //默认还可以排列字母;<br> var arr2 = [“c”,”e”,”d”,”a”,”b”];<br> var bbb = arr2.sort();<br> console.log(bbb);         // [“a”, “b”, “c”, “d”, “e”]<br> console.log(bbb===arr2); // true 原数组被排序了(冒泡排序)</p>\n</li>\n</ol>\n<p>sort() //数值大小排序方法,需要借助回调函数;<br>例：<br>      var arr = [4,5,1,13,2,7,6];<br>      //回调函数里面返回值如果是：参数1-参数2;升幂；   参数2-参数1;降幂；<br>      arr.sort(function (a,b) {<br>        return a-b; //升序<br>        //return b-a; //降序<br>        //return b.value-a.value; //按照元素value属性的大小排序;<br>      });<br>      console.log(arr); // [1, 2, 4, 5, 6, 7, 13]<br>sort( )底层原理<br>    var aaa = bubbleSort([1,12,3], function (a,b) {<br>//        return a-b;//实参：array[j]-array[j+1]；<br>        return b-a;//实参：array[j+1]-array[j]；<br>    });<br>    console.log(aaa);</p>\n<pre><code>function bubbleSort(array,fn){\n    //外循环控制轮数，内循环控制次数，都是元素个数-1;\n    for(var i=0;i&lt;array.length-1;i++){ for(var=&quot;&quot; j=&quot;0;j&lt;array.length-1-i;j++){//次数优化，多比较一轮，少比较一次;&quot; 满足条件交换位置;=&quot;&quot; if(array[j]=&quot;&quot;&gt;array[j+1]){//大于升幂排序；否则降幂;\n            //a-b&gt;0  和  a&gt;b是一个意思;\n            //b-a&gt;0  和  a&lt;b是一个意思; if(array[j]-array[j+1]=&quot;&quot;&gt;0){//升幂排序\n</code></pre><p>//                if(array[j+1]-array[j]&gt;0){//降幂排序<br>                //把两个变量送到一个函数中;<br>                if(fn(array[j],array[j+1])&gt;0){<br>                    var temp = array[j];<br>                    array[j] = array[j+1];<br>                    array[j+1] = temp;<br>                }<br>            }<br>        }<br>        //返回数组<br>        return array;<br>    }<br><br>数组元素的操作<br>concat( )<br>数组1.concat(数组2); // 链接两个数组;<br>var arr1 = [1,2,3];<br>var arr2 = [“a”,”b”,”c”];<br>var arr3 = arr1.concat(arr2);<br>console.log(arr3)   //    [1, 2, 3, “a”, “b”, “c”]<br>slice( )<br>数组.slice(开始索引值，结束索引值);     //数组截取;<br>例 ：<br>      var arr = [1, 2, 3, “a”, “b”, “c”];<br>      console.log(arr.slice(3));            //从索引值为3截取到最后;[“a”, “b”, “c”]<br>      console.log(arr.slice(0,3));            //包左不包右;[1, 2, 3]<br>      console.log(arr.slice(-2));            //负数是后几个;[“b”, “c”]<br>      console.log(arr.slice(3,0));            //如果前面的比后面的大，那么就是[];[]<br>      console.log(arr);                          //原数组不被修改;[1, 2, 3, “a”, “b”, “c”]<br>splice( )<br>数组.splice(开始索引值，删除几个，替换内容1，替换内容2，…);  // 替换和删除;<br>                                                      //改变原数组;返回值是被删除/替换的内容<br>例:<br>    var arr = [1,2,3,4,5,6,”a”, “b”, “c”]<br>    arr.splice(5);        //从索引值为3截取到最后;(删除)<br>    console.log(arr);     // [1, 2, 3, 4, 5]<br>    arr.splice(1,2);    //(删除指定个数)从索引为1的开始删除2个<br>    console.log(arr);   //[1, 4, 5]</p>\n<p>//替换<br>    var arr = [1,2,3,4,5,6,”a”, “b”, “c”];<br>    console.log(arr.splice(3,3,”aaa”,”bbb”,”ccc”));    //(删除指定数并替换)<br>    console.log(arr);     // [1, 2, 3, “aaa”, “bbb”, “ccc”, “a”, “b”, “c”]<br>//    添加<br>    arr.splice(3,0,”aaa”,”bbb”,”ccc”);//(删除指定个数)<br>//<br>    console.log(arr);//截取或者替换之后的;   [1, 2, 3, “aaa”, “bbb”, “ccc”, “aaa”, “bbb”, “ccc”, “a”, “b”, “c”]<br>indexOf / lastIndexOf<br>数组.indexOf(元素);      // 给元素，查索引(从前往后)<br>数组.lastIndexOf(元素);  // 给元素，查索引(从后往前)<br>例：<br>    var arr = [“a”,”b”,”c”,”d”,”c”,”b”,”b”];<br>    console.log(arr.indexOf(“b”));        // 1 查到以后立刻返回<br>    console.log(arr.lastIndexOf(“b”));    // 6 找到以后立刻返回<br>    console.log(arr.indexOf(“xxx”));    // -1;  查不到就返回-1；<br>数组迭代(遍历)<br>every()<br>对数组中每一项运行回调函数，如果都返回true，every返回true，<br>如果有一项返回false，则停止遍历 every返回false；不写默认返回false<br>像保镖失误一次，游戏结束！！！<br>例：</p>\n<ol>\n<li><p>var arr = [111,222,333,444,555];<br>arr.every(function (a,b,c) {<br>  console.log(a);    //元素<br>  console.log(b);    //索引值<br>  console.log(c);    //数组本身;<br>  console.log(“—–”);    //数组本身;<br>  //数组中元素赋值：c[b] = 值;      a=有时候无法赋值;<br>  return true;<br>});</p>\n</li>\n<li><p>//every返回一个bool值，全部是true才是true；有一个是false，结果就是false<br>var bool = arr.every(function (element, index, array) {</p>\n<pre><code>//判断：我们定义所有元素都大于200;\n//if(element &gt; 100){\nif(element &gt; 200){\n    return true;\n}else{\n    return false;\n}\n</code></pre><p>})<br>alert(bool); //false<br>filter()<br>//   对数组中每一项运行回调函数，该函数返回结果是true的项组成的新数组<br>//     新数组是有老数组中的元素组成的，return为ture的项;<br>例：<br>var arr = [111,222,333,444,555];<br>var newArr = arr.filter(function (element, index, array) {</p>\n<pre><code>//只要是奇数，就组成数组;(数组中辨别元素)\nif(element%2 === 0){\n    return true;\n}else{\n    return false;\n}\n</code></pre><p>})</p>\n<p>console.log(newArr); // [222, 444]<br>forEach()<br>// 和for循环一样；没有返回值;<br>例：<br>var arr = [111,222,333,444,555];<br>var sum = 0;<br>var aaa = arr.forEach(function (element,index,array) {</p>\n<pre><code>console.log(element); // 输出数组中的每一个元素\nconsole.log(index); // 数组元素对应的索引值\nconsole.log(array); // 数组本身 [111, 222, 333, 444, 555]\nsum += element; //数组中元素求和;\n</code></pre><p>});<br>console.log(sum); // 数组元素加起来的和<br>console.log(aaa);//undefined；没有返回值 所以返回undefined<br>map()<br>//  对数组中每一项运行回调函数，返回该函数的结果组成的新数组<br>//    return什么新数组中就有什么; 不return返回undefined; 对数组二次加工<br>例：<br>var arr = [111,222,333,444,555];<br>var newArr = arr.map(function (element, index, array) {</p>\n<pre><code>if(index == 2){\n    return element; // 这里return了 所以下面返回的值是333\n}\nreturn element*100; // 返回的元素值都乘上100后的值\n</code></pre><p>})<br>console.log(newArr); // [11100, 22200, 333, 44400, 55500]<br>some()<br>//对数组中每一项运行回调函数，如果该函数对某一项返回true，则some返回true; 像杀手，有一个成功，就胜利了！！！<br>例：<br>var arr = [111,222,333,444,555];<br>var bool = arr.some(function (ele,i,array) {</p>\n<pre><code>//判断：数组中有3的倍数\nif(ele%3 == 0){\n    return true;\n}\nreturn false;\n</code></pre><p>})<br>alert(bool); //true ; 有一个成功就是true<br>数组清空</p>\n<ol>\n<li>arr.length = 0; // (不好，伪数组无法清空)</li>\n<li>arr.splice(0); // 伪数组没有这个方法;</li>\n<li>arr = [];     // 可以操作伪数组; (推荐!)</li>\n</ol>\n</li>\n</ol>\n<p>// 伪数组: 就是长的像数组，但是没有数组的方法;也不能添加和删除元素;<br>例： // arguments<br>        fn(111,222,333);<br>        function fn(){<br>            arguments.length = 0; // 无法清空 返回 [1, 2, 3]<br>           arguments.splice(0); // 会报错 arguments.splice is not a function<br>            arguments = []; // 可以清空,返回空数组[]<br>            console.log(arguments);<br>        }<br>数组案例<br>1.将一个字符串数组输出为|分割的形式，比如“刘备|张飞|关羽”。使用两种方式实现</p>\n<pre><code>var arr = [&quot;刘备&quot;,&quot;张飞&quot;,&quot;关羽&quot;];\nvar separator = &quot;|&quot;;\n//通过for循环累加\nvar str = arr[0];\nfor(var i=1;i&lt;arr.length;i++){\n    str += separator+arr[i];\n}\nconsole.log(str); // 刘备|张飞|关羽\n//join()可以把数组中的元素链接成字符串;\nconsole.log(arr.join(&quot;|&quot;)); // 刘备|张飞|关羽\n</code></pre><p>2.将一个字符串数组的元素的顺序进行反转。[“a”, “b”, “c”, “d”] -&gt; [ “d”,”c”,”b”,”a”]。使用两种种方式实现。提示：第i个和第length-i-1个进行交换</p>\n<p>  // 数组.reverse() 方法<br>           var arr = [“a”, “b”, “c”, “d”];<br>           console.log(arr.reverse()); // [“d”, “c”, “b”, “a”]</p>\n<pre><code>//  三种：1.正向遍历，反向添加;  2.反向遍历，正向添加;   3.元数组元素交换位置;\n    for(var i=0;i&lt;arr.length/2;i++){\n        var temp = arr[i];\n        arr[i] = arr[arr.length-1-i];\n        arr[arr.length-1-i] = temp;\n    }\n    console.log(arr);\n</code></pre><p>3.工资的数组[1500, 1200, 2000, 2100, 1800],把工资超过2000的删除</p>\n<p>   var arr = [1500, 1200, 2000, 2100, 1800];<br>   //利用filter()形成一个数组;return true;组成的数组;<br>   var newArr = arr.filter(function (ele, i, array) {<br>       //2000以上返回false;<br>       if(ele&lt;2000){<br>           return true;<br>       }else{<br>           return false;<br>       }<br>   });<br>   console.log(newArr); // [1500, 1200, 1800]<br>4.[“c”, “a”, “z”, “a”, “x”, “a”]找到数组中每一个a出现的位置</p>\n<p>   var arr = [“c”, “a”, “z”, “a”, “x”, “a”];<br>   //遍历数组(for/while/do…while)    forEach();<br>   arr.forEach(function (ele, index, array) {<br>       //如果元素等于“a”，那么就输出索引值；<br>       if(“a” === ele){<br>           console.log(index);<br>       }<br>   });<br>5.编写一个方法去掉一个数组的重复元素 (数组去重)</p>\n<pre><code>var arr = [&quot;鸣人&quot;,&quot;鸣人&quot;,&quot;佐助&quot;,&quot;佐助&quot;,&quot;小樱&quot;,&quot;小樱&quot;];\n</code></pre><p>   //  方法1：  思路：定义一个新数组，遍历老数组，判断，如果新数组里面没有老数组的元素就添加，否则就不添加；<br>       var newArr = [];<br>       //遍历老数组<br>       arr.forEach(function (ele,index,array) {<br>           //检测老数组中的元素，如果新数组中存在就不添加了，不存在才添加;<br>           if(newArr.indexOf(ele) === -1){//不存在就添加;（去新数组中查找元素索引值，如果为-1就是没有）<br>               newArr.push(ele);<br>           }<br>       });<br>       console.log(newArr); // [“鸣人”, “佐助”, “小樱”]</p>\n","site":{"data":{}},"excerpt":"","more":"<p>数组API<br>API: Application Programming Interface,应用程序编程接口;<br>js中对象提供的方法就叫做API；<br>instanceof<br>检测一个对象是否是数组;(用来对付复杂数据类型;)<br>// 简单数据类型 typeof ;<br>A instanceof B  // A是不是B造出来的;<br>例：<br>    var arr = [1,2,3];<br>    console.log(arr instanceof Array); //arr属不属于Array类型;<br>Array.isArray( )<br>Array.isArray(参数); // 判断参数是不是数组,返回布尔值;<br>例：<br>    var arr = [1,2,3];<br>    var num = 123;<br>    console.log(Array.isArray(arr)); //true<br>    console.log(Array.isArray(num)); //false<br>toString( )<br>数组.toString(); // 把数组变成字符串,去除了[],内容用逗号链接;<br>例：<br>    var arr = [“aaa”,”bbb”,”ccc”];<br>    console.log(arr.toString());      //返回 aaa,bbb,ccc<br>valueOf( )<br>数组.valueOf();  //返回数组本身;<br>例：<br>    var arr = [“aaa”,”bbb”,”ccc”];<br>    console.log(arr.valueOf());      //返回数组本身  [“aaa”,”bbb”,”ccc”]<br>数组.join(参数)<br>数组.join(参数);  // 数组中的元素可以按照参数进行链接变成一个字符串;<br>console.log(arr.join());    //和toString()一样用逗号链接<br>console.log(arr.join(“|”)); //用参数链接<br>console.log(arr.join(“&amp;”)); //用参数链接<br>console.log(arr.join(“ “)); //如果是空格，真的用空格链接<br>console.log(arr.join(“”));  //空字符是无缝连接<br>数组元素的添加和删除<br>push( )和pop( )</p>\n<ol>\n<li>数组.push() //在数组的最末尾添加元素;</li>\n<li><p>数组.pop()  //不需要参数;在数组的最末尾删除一项;<br>例：<br> var arr = [1,2,3];<br> var aaa = arr.push(“abc”);//在数组的最末尾添加一个元素;<br> console.log(arr);//元素被修改了<br> console.log(aaa);//返回值是数组的长度;</p>\n<p> aaa = arr.pop();//不需要参数;在数组的最末尾删除一项;<br> console.log(arr);//元素被修改了<br> console.log(aaa);//被删除的那一项<br>unshift( )和shift( )</p>\n</li>\n<li>数组.unshift() //在数组的最前面添加一个元素;</li>\n<li><p>数组.shift()  //不需要参数;在数组的最前面删除一项;<br>例：<br> var arr = [1,2,3];<br> aaa = arr.unshift(“abc”);//在数组的最前面添加一个元素;<br> console.log(arr);//元素被修改了<br> console.log(aaa);//返回值是数组的长度;</p>\n<p> aaa = arr.shift();//不需要参数;在数组的最前面删除一项;<br> console.log(arr);//元素被修改了<br> console.log(aaa);//被删除的那一项<br>数组元素排序<br>reverse( )<br>reverse()   //翻转数组<br>例:<br> var arr1 = [1,2,3,4,5];<br> var aaa = arr1.reverse(); // [5,4,3,2,1]<br>sort( )<br>sort() // 数组中元素排序;(默认：从小到大)<br>   //  默认：按照首个字符的Unicode编码排序;如果第一个相同那么就比较第二个…<br>例：<br> var arr = [4,5,1,3,2,7,6];<br> var aaa =arr.sort();<br> console.log(aaa);          // [1, 2, 3, 4, 5, 6, 7]<br> console.log(aaa === arr);// true 原数组被排序了(冒泡排序)<br> //默认还可以排列字母;<br> var arr2 = [“c”,”e”,”d”,”a”,”b”];<br> var bbb = arr2.sort();<br> console.log(bbb);         // [“a”, “b”, “c”, “d”, “e”]<br> console.log(bbb===arr2); // true 原数组被排序了(冒泡排序)</p>\n</li>\n</ol>\n<p>sort() //数值大小排序方法,需要借助回调函数;<br>例：<br>      var arr = [4,5,1,13,2,7,6];<br>      //回调函数里面返回值如果是：参数1-参数2;升幂；   参数2-参数1;降幂；<br>      arr.sort(function (a,b) {<br>        return a-b; //升序<br>        //return b-a; //降序<br>        //return b.value-a.value; //按照元素value属性的大小排序;<br>      });<br>      console.log(arr); // [1, 2, 4, 5, 6, 7, 13]<br>sort( )底层原理<br>    var aaa = bubbleSort([1,12,3], function (a,b) {<br>//        return a-b;//实参：array[j]-array[j+1]；<br>        return b-a;//实参：array[j+1]-array[j]；<br>    });<br>    console.log(aaa);</p>\n<pre><code>function bubbleSort(array,fn){\n    //外循环控制轮数，内循环控制次数，都是元素个数-1;\n    for(var i=0;i&lt;array.length-1;i++){ for(var=&quot;&quot; j=&quot;0;j&lt;array.length-1-i;j++){//次数优化，多比较一轮，少比较一次;&quot; 满足条件交换位置;=&quot;&quot; if(array[j]=&quot;&quot;&gt;array[j+1]){//大于升幂排序；否则降幂;\n            //a-b&gt;0  和  a&gt;b是一个意思;\n            //b-a&gt;0  和  a&lt;b是一个意思; if(array[j]-array[j+1]=&quot;&quot;&gt;0){//升幂排序\n</code></pre><p>//                if(array[j+1]-array[j]&gt;0){//降幂排序<br>                //把两个变量送到一个函数中;<br>                if(fn(array[j],array[j+1])&gt;0){<br>                    var temp = array[j];<br>                    array[j] = array[j+1];<br>                    array[j+1] = temp;<br>                }<br>            }<br>        }<br>        //返回数组<br>        return array;<br>    }<br><br>数组元素的操作<br>concat( )<br>数组1.concat(数组2); // 链接两个数组;<br>var arr1 = [1,2,3];<br>var arr2 = [“a”,”b”,”c”];<br>var arr3 = arr1.concat(arr2);<br>console.log(arr3)   //    [1, 2, 3, “a”, “b”, “c”]<br>slice( )<br>数组.slice(开始索引值，结束索引值);     //数组截取;<br>例 ：<br>      var arr = [1, 2, 3, “a”, “b”, “c”];<br>      console.log(arr.slice(3));            //从索引值为3截取到最后;[“a”, “b”, “c”]<br>      console.log(arr.slice(0,3));            //包左不包右;[1, 2, 3]<br>      console.log(arr.slice(-2));            //负数是后几个;[“b”, “c”]<br>      console.log(arr.slice(3,0));            //如果前面的比后面的大，那么就是[];[]<br>      console.log(arr);                          //原数组不被修改;[1, 2, 3, “a”, “b”, “c”]<br>splice( )<br>数组.splice(开始索引值，删除几个，替换内容1，替换内容2，…);  // 替换和删除;<br>                                                      //改变原数组;返回值是被删除/替换的内容<br>例:<br>    var arr = [1,2,3,4,5,6,”a”, “b”, “c”]<br>    arr.splice(5);        //从索引值为3截取到最后;(删除)<br>    console.log(arr);     // [1, 2, 3, 4, 5]<br>    arr.splice(1,2);    //(删除指定个数)从索引为1的开始删除2个<br>    console.log(arr);   //[1, 4, 5]</p>\n<p>//替换<br>    var arr = [1,2,3,4,5,6,”a”, “b”, “c”];<br>    console.log(arr.splice(3,3,”aaa”,”bbb”,”ccc”));    //(删除指定数并替换)<br>    console.log(arr);     // [1, 2, 3, “aaa”, “bbb”, “ccc”, “a”, “b”, “c”]<br>//    添加<br>    arr.splice(3,0,”aaa”,”bbb”,”ccc”);//(删除指定个数)<br>//<br>    console.log(arr);//截取或者替换之后的;   [1, 2, 3, “aaa”, “bbb”, “ccc”, “aaa”, “bbb”, “ccc”, “a”, “b”, “c”]<br>indexOf / lastIndexOf<br>数组.indexOf(元素);      // 给元素，查索引(从前往后)<br>数组.lastIndexOf(元素);  // 给元素，查索引(从后往前)<br>例：<br>    var arr = [“a”,”b”,”c”,”d”,”c”,”b”,”b”];<br>    console.log(arr.indexOf(“b”));        // 1 查到以后立刻返回<br>    console.log(arr.lastIndexOf(“b”));    // 6 找到以后立刻返回<br>    console.log(arr.indexOf(“xxx”));    // -1;  查不到就返回-1；<br>数组迭代(遍历)<br>every()<br>对数组中每一项运行回调函数，如果都返回true，every返回true，<br>如果有一项返回false，则停止遍历 every返回false；不写默认返回false<br>像保镖失误一次，游戏结束！！！<br>例：</p>\n<ol>\n<li><p>var arr = [111,222,333,444,555];<br>arr.every(function (a,b,c) {<br>  console.log(a);    //元素<br>  console.log(b);    //索引值<br>  console.log(c);    //数组本身;<br>  console.log(“—–”);    //数组本身;<br>  //数组中元素赋值：c[b] = 值;      a=有时候无法赋值;<br>  return true;<br>});</p>\n</li>\n<li><p>//every返回一个bool值，全部是true才是true；有一个是false，结果就是false<br>var bool = arr.every(function (element, index, array) {</p>\n<pre><code>//判断：我们定义所有元素都大于200;\n//if(element &gt; 100){\nif(element &gt; 200){\n    return true;\n}else{\n    return false;\n}\n</code></pre><p>})<br>alert(bool); //false<br>filter()<br>//   对数组中每一项运行回调函数，该函数返回结果是true的项组成的新数组<br>//     新数组是有老数组中的元素组成的，return为ture的项;<br>例：<br>var arr = [111,222,333,444,555];<br>var newArr = arr.filter(function (element, index, array) {</p>\n<pre><code>//只要是奇数，就组成数组;(数组中辨别元素)\nif(element%2 === 0){\n    return true;\n}else{\n    return false;\n}\n</code></pre><p>})</p>\n<p>console.log(newArr); // [222, 444]<br>forEach()<br>// 和for循环一样；没有返回值;<br>例：<br>var arr = [111,222,333,444,555];<br>var sum = 0;<br>var aaa = arr.forEach(function (element,index,array) {</p>\n<pre><code>console.log(element); // 输出数组中的每一个元素\nconsole.log(index); // 数组元素对应的索引值\nconsole.log(array); // 数组本身 [111, 222, 333, 444, 555]\nsum += element; //数组中元素求和;\n</code></pre><p>});<br>console.log(sum); // 数组元素加起来的和<br>console.log(aaa);//undefined；没有返回值 所以返回undefined<br>map()<br>//  对数组中每一项运行回调函数，返回该函数的结果组成的新数组<br>//    return什么新数组中就有什么; 不return返回undefined; 对数组二次加工<br>例：<br>var arr = [111,222,333,444,555];<br>var newArr = arr.map(function (element, index, array) {</p>\n<pre><code>if(index == 2){\n    return element; // 这里return了 所以下面返回的值是333\n}\nreturn element*100; // 返回的元素值都乘上100后的值\n</code></pre><p>})<br>console.log(newArr); // [11100, 22200, 333, 44400, 55500]<br>some()<br>//对数组中每一项运行回调函数，如果该函数对某一项返回true，则some返回true; 像杀手，有一个成功，就胜利了！！！<br>例：<br>var arr = [111,222,333,444,555];<br>var bool = arr.some(function (ele,i,array) {</p>\n<pre><code>//判断：数组中有3的倍数\nif(ele%3 == 0){\n    return true;\n}\nreturn false;\n</code></pre><p>})<br>alert(bool); //true ; 有一个成功就是true<br>数组清空</p>\n<ol>\n<li>arr.length = 0; // (不好，伪数组无法清空)</li>\n<li>arr.splice(0); // 伪数组没有这个方法;</li>\n<li>arr = [];     // 可以操作伪数组; (推荐!)</li>\n</ol>\n</li>\n</ol>\n<p>// 伪数组: 就是长的像数组，但是没有数组的方法;也不能添加和删除元素;<br>例： // arguments<br>        fn(111,222,333);<br>        function fn(){<br>            arguments.length = 0; // 无法清空 返回 [1, 2, 3]<br>           arguments.splice(0); // 会报错 arguments.splice is not a function<br>            arguments = []; // 可以清空,返回空数组[]<br>            console.log(arguments);<br>        }<br>数组案例<br>1.将一个字符串数组输出为|分割的形式，比如“刘备|张飞|关羽”。使用两种方式实现</p>\n<pre><code>var arr = [&quot;刘备&quot;,&quot;张飞&quot;,&quot;关羽&quot;];\nvar separator = &quot;|&quot;;\n//通过for循环累加\nvar str = arr[0];\nfor(var i=1;i&lt;arr.length;i++){\n    str += separator+arr[i];\n}\nconsole.log(str); // 刘备|张飞|关羽\n//join()可以把数组中的元素链接成字符串;\nconsole.log(arr.join(&quot;|&quot;)); // 刘备|张飞|关羽\n</code></pre><p>2.将一个字符串数组的元素的顺序进行反转。[“a”, “b”, “c”, “d”] -&gt; [ “d”,”c”,”b”,”a”]。使用两种种方式实现。提示：第i个和第length-i-1个进行交换</p>\n<p>  // 数组.reverse() 方法<br>           var arr = [“a”, “b”, “c”, “d”];<br>           console.log(arr.reverse()); // [“d”, “c”, “b”, “a”]</p>\n<pre><code>//  三种：1.正向遍历，反向添加;  2.反向遍历，正向添加;   3.元数组元素交换位置;\n    for(var i=0;i&lt;arr.length/2;i++){\n        var temp = arr[i];\n        arr[i] = arr[arr.length-1-i];\n        arr[arr.length-1-i] = temp;\n    }\n    console.log(arr);\n</code></pre><p>3.工资的数组[1500, 1200, 2000, 2100, 1800],把工资超过2000的删除</p>\n<p>   var arr = [1500, 1200, 2000, 2100, 1800];<br>   //利用filter()形成一个数组;return true;组成的数组;<br>   var newArr = arr.filter(function (ele, i, array) {<br>       //2000以上返回false;<br>       if(ele&lt;2000){<br>           return true;<br>       }else{<br>           return false;<br>       }<br>   });<br>   console.log(newArr); // [1500, 1200, 1800]<br>4.[“c”, “a”, “z”, “a”, “x”, “a”]找到数组中每一个a出现的位置</p>\n<p>   var arr = [“c”, “a”, “z”, “a”, “x”, “a”];<br>   //遍历数组(for/while/do…while)    forEach();<br>   arr.forEach(function (ele, index, array) {<br>       //如果元素等于“a”，那么就输出索引值；<br>       if(“a” === ele){<br>           console.log(index);<br>       }<br>   });<br>5.编写一个方法去掉一个数组的重复元素 (数组去重)</p>\n<pre><code>var arr = [&quot;鸣人&quot;,&quot;鸣人&quot;,&quot;佐助&quot;,&quot;佐助&quot;,&quot;小樱&quot;,&quot;小樱&quot;];\n</code></pre><p>   //  方法1：  思路：定义一个新数组，遍历老数组，判断，如果新数组里面没有老数组的元素就添加，否则就不添加；<br>       var newArr = [];<br>       //遍历老数组<br>       arr.forEach(function (ele,index,array) {<br>           //检测老数组中的元素，如果新数组中存在就不添加了，不存在才添加;<br>           if(newArr.indexOf(ele) === -1){//不存在就添加;（去新数组中查找元素索引值，如果为-1就是没有）<br>               newArr.push(ele);<br>           }<br>       });<br>       console.log(newArr); // [“鸣人”, “佐助”, “小樱”]</p>\n"},{"title":"Git 常用命令速查","_content":"\nGit 常用命令速查\ngit branch 查看本地所有分支\ngit status 查看当前状态\ngit commit 提交\ngit branch -a 查看所有的分支\ngit branch -r 查看远程所有分支\ngit commit -am “init” 提交并且加注释\ngit remote add origin git@192.168.1.119:ndshow\ngit push origin master 将文件给推到服务器上\ngit remote show origin 显示远程库origin里的资源\ngit push origin master:develop\ngit push origin master:hb-dev 将本地库与服务器上的库进行关联\ngit checkout –track origin/dev 切换到远程dev分支\ngit branch -D master develop 删除本地库develop\ngit checkout -b dev 建立一个新的本地分支dev\ngit merge origin/dev 将分支dev与当前分支进行合并\ngit checkout dev 切换到本地dev分支\ngit remote show 查看远程库\ngit add . 他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。\ngit rm 文件名(包括路径) 从git中删除指定文件\ngit clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来\ngit config –list 看所有用户\ngit ls-files 看已经被提交的\ngit rm [file name] 删除一个文件\ngit commit -a 提交当前repos的所有的改变\ngit add [file name] 添加一个文件到git index\ngit commit -v 当你用－v参数的时候可以看commit的差异\ngit commit -m “This is the message describing the commit” 添加commit信息\ngit commit -a -a是代表add，把所有的change加到git index里然后再commit\ngit commit -a -v 一般提交命令\ngit log 看你commit的日志\ngit diff 查看尚未暂存的更新\ngit rm a.a 移除文件(从暂存区和工作区中删除)\ngit rm –cached a.a 移除文件(只从暂存区中删除)\ngit commit -m “remove” 移除文件(从Git中删除)\ngit rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)\ngit diff –cached 或 $ git diff –staged 查看尚未提交的更新\ngit stash push 将文件给push到一个临时空间中\ngit stash pop 将文件从临时空间pop下来\ngit remote add origin git@github.com:username/Hello-World.git\ngit push origin master 将本地项目给提交到服务器中\ngit pull 本地与服务器端同步\ngit push (远程仓库名) (分支名) 将本地分支推送到服务器上去。\ngit push origin serverfix:awesomebranch\ngit fetch 相当于是从远程获取最新版本到本地，不会自动merge\ngit commit -a -m “log_message” (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：\ngit branch branch_0.1 master 从主分支master创建branch_0.1分支\ngit branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0\ngit checkout branch_1.0/master 切换到branch_1.0/master分支\ndu -hs\ngit branch 删除远程branch\ngit push origin :branch_remote_name\ngit branch -r -d branch_remote_name\n初始化版本库，并提交到远程服务器端\n\nmkdir WebApp\ncd WebApp\ngit init 本地初始化\ntouch README\ngit add README 添加文件\ngit commit -m 'first commit'\ngit remote add origin git@github.com:daixu/WebApp.git\n增加一个远程服务器端\n\n上面的命令会增加URL地址为’git@github.com:daixu/WebApp.git’，名称为origin的远程服务器库，以后提交代码的时候只需要使用 origin别名即可\n\nGit 命令速查表\n常用的Git命令\n命令\t简要说明\ngit add\t添加至暂存区\ngit add–interactive\t交互式添加\ngit apply\t应用补丁\ngit am\t应用邮件格式补丁\ngit annotate\t同义词，等同于 git blame\ngit archive\t文件归档打包\ngit bisect\t二分查找\ngit blame\t文件逐行追溯\ngit branch\t分支管理\ngit cat-file\t版本库对象研究工具\ngit checkout\t检出到工作区、切换或创建分支\ngit cherry-pick\t提交拣选\ngit citool\t图形化提交，相当于 git gui 命令\ngit clean\t清除工作区未跟踪文件\ngit clone\t克隆版本库\ngit commit\t提交\ngit config\t查询和修改配置\ngit describe\t通过里程碑直观地显示提交ID\ngit diff\t差异比较\ngit difftool\t调用图形化差异比较工具\ngit fetch\t获取远程版本库的提交\ngit format-patch\t创建邮件格式的补丁文件。参见 git am 命令\ngit grep\t文件内容搜索定位工具\ngit gui\t基于Tcl/Tk的图形化工具，侧重提交等操作\ngit help\t帮助\ngit init\t版本库初始化\ngit init-db*\t同义词，等同于 git init\ngit log\t显示提交日志\ngit merge\t分支合并\ngit mergetool\t图形化冲突解决\ngit mv\t重命名\ngit pull\t拉回远程版本库的提交\ngit push\t推送至远程版本库\ngit rebase\t分支变基\ngit rebase–interactive\t交互式分支变基\ngit reflog\t分支等引用变更记录管理\ngit remote\t远程版本库管理\ngit repo-config*\t同义词，等同于 git config\ngit reset\t重置改变分支“游标”指向\ngit rev-parse\t将各种引用表示法转换为哈希值等\ngit revert\t反转提交\ngit rm\t删除文件\ngit show\t显示各种类型的对象\ngit stage*\t同义词，等同于 git add\ngit stash\t保存和恢复进度\ngit status\t显示工作区文件状态\ngit tag\t里程碑管理对象库操作相关命令\n命令\t简要说明\ngit commit-tree\t从树对象创建提交\ngit hash-object\t从标准输入或文件计算哈希值或创建对象\ngit ls-files\t显示工作区和暂存区文件\ngit ls-tree\t显示树对象包含的文件\ngit mktag\t读取标准输入创建一个里程碑对象\ngit mktree\t读取标准输入创建一个树对象\ngit read-tree\t读取树对象到暂存区\ngit update-index\t工作区内容注册到暂存区及暂存区管理\ngit unpack-file\t创建临时文件包含指定 blob 的内容\ngit write-tree\t从暂存区创建一个树对象引用操作相关命令\n命令\t简要说明\ngit check-ref-format\t检查引用名称是否符合规范\ngit for-each-ref\t引用迭代器，用于shell编程\ngit ls-remote\t显示远程版本库的引用\ngit name-rev\t将提交ID显示为友好名称\ngit peek-remote*\t过时命令，请使用 git ls-remote\ngit rev-list\t显示版本范围\ngit show-branch\t显示分支列表及拓扑关系\ngit show-ref\t显示本地引用\ngit symbolic-ref\t显示或者设置符号引用\ngit update-ref\t更新引用的指向\ngit verify-tag\t校验 GPG 签名的Tag版本库管理相关命令\n命令\t简要说明\ngit count-objects\t显示松散对象的数量和磁盘占用\ngit filter-branch\t版本库重构\ngit fsck\t对象库完整性检查\ngit fsck-objects*\t同义词，等同于 git fsck\ngit gc\t版本库存储优化\ngit index-pack\t从打包文件创建对应的索引文件\ngit lost-found*\t过时，请使用 git fsck –lost-found 命令\ngit pack-objects\t从标准输入读入对象ID，打包到文件\ngit pack-redundant\t查找多余的 pack 文件\ngit pack-refs\t将引用打包到 .git/packed-refs 文件中\ngit prune\t从对象库删除过期对象\ngit prune-packed\t将已经打包的松散对象删除\ngit relink\t为本地版本库中相同的对象建立硬连接\ngit repack\t将版本库未打包的松散对象打包\ngit show-index\t读取包的索引文件，显示打包文件中的内容\ngit unpack-objects\t从打包文件释放文件\ngit verify-pack\t校验对象库打包文件数据传输相关命令\n命令\t简要说明\ngit fetch-pack\t执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象\ngit receive-pack\t执行 git push 命令时在远程执行的命令，用于接受推送的数据\ngit send-pack\t执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据\ngit upload-archive\t执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档\ngit upload-pack\t执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传邮件相关命令\n命令\t简要说明\ngit imap-send\t将补丁通过 IMAP 发送\ngit mailinfo\t从邮件导出提交说明和补丁\ngit mailsplit\t将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件\ngit request-pull\t创建包含提交间差异和执行PULL操作地址的信息\ngit send-email\t发送邮件协议相关命令\n命令\t简要说明\ngit daemon\t实现Git协议\ngit http-backend\t实现HTTP协议的CGI程序，支持智能HTTP协议\ngit instaweb\t即时启动浏览器通过 gitweb 浏览当前版本库\ngit shell\t受限制的shell，提供仅执行Git命令的SSH访问\ngit update-server-info\t更新哑协议需要的辅助文件\ngit http-fetch\t通过HTTP协议获取版本库\ngit http-push\t通过HTTP/DAV协议推送\ngit remote-ext\t由Git命令调用，通过外部命令提供扩展协议支持\ngit remote-fd\t由Git命令调用，使用文件描述符作为协议接口\ngit remote-ftp\t由Git命令调用，提供对FTP协议的支持\ngit remote-ftps\t由Git命令调用，提供对FTPS协议的支持\ngit remote-http\t由Git命令调用，提供对HTTP协议的支持\ngit remote-https\t由Git命令调用，提供对HTTPS协议的支持\ngit remote-testgit\t协议扩展示例脚本版本库转换和交互相关命令\n命令\t简要说明\ngit archimport\t导入Arch版本库到Git\ngit bundle\t提交打包和解包，以便在不同版本库间传递\ngit cvsexportcommit\t将Git的一个提交作为一个CVS检出\ngit cvsimport\t导入CVS版本库到Git。或者使用 cvs2git\ngit cvsserver\tGit的CVS协议模拟器，可供CVS命令访问Git版本库\ngit fast-export\t将提交导出为 git-fast-import 格式\ngit fast-import\t其他版本库迁移至Git的通用工具\ngit svn\tGit 作为前端操作 Subversion合并相关的辅助命令\n命令\t简要说明\ngit merge-base\t供其他脚本调用，找到两个或多个提交最近的共同祖先\ngit merge-file\t针对文件的两个不同版本执行三向文件合并\ngit merge-index\t对index中的冲突文件调用指定的冲突解决工具\ngit merge-octopus\t合并两个以上分支。参见 git merge 的octopus合并策略\ngit merge-one-file\t由 git merge-index 调用的标准辅助程序\ngit merge-ours\t合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略\ngit merge-recursive\t针对两个分支的三向合并。参见 git merge 的recursive合并策略\ngit merge-resolve\t针对两个分支的三向合并。参见 git merge 的resolve合并策略\ngit merge-subtree\t子树合并。参见 git merge 的 subtree 合并策略\ngit merge-tree\t显式三向合并结果，不改变暂存区\ngit fmt-merge-msg\t供执行合并操作的脚本调用，用于创建一个合并提交说明\ngit rerere\t重用所记录的冲突解决方案杂项\n命令\t简要说明\ngit bisect–helper\t由 git bisect 命令调用，确认二分查找进度\ngit check-attr\t显示某个文件是否设置了某个属性\ngit checkout-index\t从暂存区拷贝文件至工作区\ngit cherry\t查找没有合并到上游的提交\ngit diff-files\t比较暂存区和工作区，相当于 git diff –raw\ngit diff-index\t比较暂存区和版本库，相当于 git diff –cached –raw\ngit diff-tree\t比较两个树对象，相当于 git diff –raw A B\ngit difftool–helper\t由 git difftool 命令调用，默认要使用的差异比较工具\ngit get-tar-commit-id\t从 git archive 创建的 tar 包中提取提交ID\ngit gui–askpass\t命令 git gui 的获取用户口令输入界面\ngit notes\t提交评论管理\ngit patch-id\t补丁过滤行号和空白字符后生成补丁唯一ID\ngit quiltimport\t将Quilt补丁列表应用到当前分支\ngit replace\t提交替换\ngit shortlog\t对 git log 的汇总输出，适合于产品发布说明\ngit stripspace\t删除空行，供其他脚本调用\ngit submodule\t子模组管理\ngit tar-tree\t过时命令，请使用 git archive\ngit var\t显示 Git 环境变量\ngit web–browse\t启动浏览器以查看目录或文件\ngit whatchanged\t显示提交历史及每次提交的改动\ngit-mergetool–lib\t包含于其他脚本中，提供合并/差异比较工具的选择和执行\ngit-parse-remote\t包含于其他脚本中，提供操作远程版本库的函数\ngit-sh-setup\t包含于其他脚本中，提供 shell 编程的函数库原文地址：","source":"_posts/git-opeation.md","raw":"---\ntitle: Git 常用命令速查\ntags: git\n---\n\nGit 常用命令速查\ngit branch 查看本地所有分支\ngit status 查看当前状态\ngit commit 提交\ngit branch -a 查看所有的分支\ngit branch -r 查看远程所有分支\ngit commit -am “init” 提交并且加注释\ngit remote add origin git@192.168.1.119:ndshow\ngit push origin master 将文件给推到服务器上\ngit remote show origin 显示远程库origin里的资源\ngit push origin master:develop\ngit push origin master:hb-dev 将本地库与服务器上的库进行关联\ngit checkout –track origin/dev 切换到远程dev分支\ngit branch -D master develop 删除本地库develop\ngit checkout -b dev 建立一个新的本地分支dev\ngit merge origin/dev 将分支dev与当前分支进行合并\ngit checkout dev 切换到本地dev分支\ngit remote show 查看远程库\ngit add . 他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。\ngit rm 文件名(包括路径) 从git中删除指定文件\ngit clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来\ngit config –list 看所有用户\ngit ls-files 看已经被提交的\ngit rm [file name] 删除一个文件\ngit commit -a 提交当前repos的所有的改变\ngit add [file name] 添加一个文件到git index\ngit commit -v 当你用－v参数的时候可以看commit的差异\ngit commit -m “This is the message describing the commit” 添加commit信息\ngit commit -a -a是代表add，把所有的change加到git index里然后再commit\ngit commit -a -v 一般提交命令\ngit log 看你commit的日志\ngit diff 查看尚未暂存的更新\ngit rm a.a 移除文件(从暂存区和工作区中删除)\ngit rm –cached a.a 移除文件(只从暂存区中删除)\ngit commit -m “remove” 移除文件(从Git中删除)\ngit rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)\ngit diff –cached 或 $ git diff –staged 查看尚未提交的更新\ngit stash push 将文件给push到一个临时空间中\ngit stash pop 将文件从临时空间pop下来\ngit remote add origin git@github.com:username/Hello-World.git\ngit push origin master 将本地项目给提交到服务器中\ngit pull 本地与服务器端同步\ngit push (远程仓库名) (分支名) 将本地分支推送到服务器上去。\ngit push origin serverfix:awesomebranch\ngit fetch 相当于是从远程获取最新版本到本地，不会自动merge\ngit commit -a -m “log_message” (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：\ngit branch branch_0.1 master 从主分支master创建branch_0.1分支\ngit branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0\ngit checkout branch_1.0/master 切换到branch_1.0/master分支\ndu -hs\ngit branch 删除远程branch\ngit push origin :branch_remote_name\ngit branch -r -d branch_remote_name\n初始化版本库，并提交到远程服务器端\n\nmkdir WebApp\ncd WebApp\ngit init 本地初始化\ntouch README\ngit add README 添加文件\ngit commit -m 'first commit'\ngit remote add origin git@github.com:daixu/WebApp.git\n增加一个远程服务器端\n\n上面的命令会增加URL地址为’git@github.com:daixu/WebApp.git’，名称为origin的远程服务器库，以后提交代码的时候只需要使用 origin别名即可\n\nGit 命令速查表\n常用的Git命令\n命令\t简要说明\ngit add\t添加至暂存区\ngit add–interactive\t交互式添加\ngit apply\t应用补丁\ngit am\t应用邮件格式补丁\ngit annotate\t同义词，等同于 git blame\ngit archive\t文件归档打包\ngit bisect\t二分查找\ngit blame\t文件逐行追溯\ngit branch\t分支管理\ngit cat-file\t版本库对象研究工具\ngit checkout\t检出到工作区、切换或创建分支\ngit cherry-pick\t提交拣选\ngit citool\t图形化提交，相当于 git gui 命令\ngit clean\t清除工作区未跟踪文件\ngit clone\t克隆版本库\ngit commit\t提交\ngit config\t查询和修改配置\ngit describe\t通过里程碑直观地显示提交ID\ngit diff\t差异比较\ngit difftool\t调用图形化差异比较工具\ngit fetch\t获取远程版本库的提交\ngit format-patch\t创建邮件格式的补丁文件。参见 git am 命令\ngit grep\t文件内容搜索定位工具\ngit gui\t基于Tcl/Tk的图形化工具，侧重提交等操作\ngit help\t帮助\ngit init\t版本库初始化\ngit init-db*\t同义词，等同于 git init\ngit log\t显示提交日志\ngit merge\t分支合并\ngit mergetool\t图形化冲突解决\ngit mv\t重命名\ngit pull\t拉回远程版本库的提交\ngit push\t推送至远程版本库\ngit rebase\t分支变基\ngit rebase–interactive\t交互式分支变基\ngit reflog\t分支等引用变更记录管理\ngit remote\t远程版本库管理\ngit repo-config*\t同义词，等同于 git config\ngit reset\t重置改变分支“游标”指向\ngit rev-parse\t将各种引用表示法转换为哈希值等\ngit revert\t反转提交\ngit rm\t删除文件\ngit show\t显示各种类型的对象\ngit stage*\t同义词，等同于 git add\ngit stash\t保存和恢复进度\ngit status\t显示工作区文件状态\ngit tag\t里程碑管理对象库操作相关命令\n命令\t简要说明\ngit commit-tree\t从树对象创建提交\ngit hash-object\t从标准输入或文件计算哈希值或创建对象\ngit ls-files\t显示工作区和暂存区文件\ngit ls-tree\t显示树对象包含的文件\ngit mktag\t读取标准输入创建一个里程碑对象\ngit mktree\t读取标准输入创建一个树对象\ngit read-tree\t读取树对象到暂存区\ngit update-index\t工作区内容注册到暂存区及暂存区管理\ngit unpack-file\t创建临时文件包含指定 blob 的内容\ngit write-tree\t从暂存区创建一个树对象引用操作相关命令\n命令\t简要说明\ngit check-ref-format\t检查引用名称是否符合规范\ngit for-each-ref\t引用迭代器，用于shell编程\ngit ls-remote\t显示远程版本库的引用\ngit name-rev\t将提交ID显示为友好名称\ngit peek-remote*\t过时命令，请使用 git ls-remote\ngit rev-list\t显示版本范围\ngit show-branch\t显示分支列表及拓扑关系\ngit show-ref\t显示本地引用\ngit symbolic-ref\t显示或者设置符号引用\ngit update-ref\t更新引用的指向\ngit verify-tag\t校验 GPG 签名的Tag版本库管理相关命令\n命令\t简要说明\ngit count-objects\t显示松散对象的数量和磁盘占用\ngit filter-branch\t版本库重构\ngit fsck\t对象库完整性检查\ngit fsck-objects*\t同义词，等同于 git fsck\ngit gc\t版本库存储优化\ngit index-pack\t从打包文件创建对应的索引文件\ngit lost-found*\t过时，请使用 git fsck –lost-found 命令\ngit pack-objects\t从标准输入读入对象ID，打包到文件\ngit pack-redundant\t查找多余的 pack 文件\ngit pack-refs\t将引用打包到 .git/packed-refs 文件中\ngit prune\t从对象库删除过期对象\ngit prune-packed\t将已经打包的松散对象删除\ngit relink\t为本地版本库中相同的对象建立硬连接\ngit repack\t将版本库未打包的松散对象打包\ngit show-index\t读取包的索引文件，显示打包文件中的内容\ngit unpack-objects\t从打包文件释放文件\ngit verify-pack\t校验对象库打包文件数据传输相关命令\n命令\t简要说明\ngit fetch-pack\t执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象\ngit receive-pack\t执行 git push 命令时在远程执行的命令，用于接受推送的数据\ngit send-pack\t执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据\ngit upload-archive\t执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档\ngit upload-pack\t执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传邮件相关命令\n命令\t简要说明\ngit imap-send\t将补丁通过 IMAP 发送\ngit mailinfo\t从邮件导出提交说明和补丁\ngit mailsplit\t将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件\ngit request-pull\t创建包含提交间差异和执行PULL操作地址的信息\ngit send-email\t发送邮件协议相关命令\n命令\t简要说明\ngit daemon\t实现Git协议\ngit http-backend\t实现HTTP协议的CGI程序，支持智能HTTP协议\ngit instaweb\t即时启动浏览器通过 gitweb 浏览当前版本库\ngit shell\t受限制的shell，提供仅执行Git命令的SSH访问\ngit update-server-info\t更新哑协议需要的辅助文件\ngit http-fetch\t通过HTTP协议获取版本库\ngit http-push\t通过HTTP/DAV协议推送\ngit remote-ext\t由Git命令调用，通过外部命令提供扩展协议支持\ngit remote-fd\t由Git命令调用，使用文件描述符作为协议接口\ngit remote-ftp\t由Git命令调用，提供对FTP协议的支持\ngit remote-ftps\t由Git命令调用，提供对FTPS协议的支持\ngit remote-http\t由Git命令调用，提供对HTTP协议的支持\ngit remote-https\t由Git命令调用，提供对HTTPS协议的支持\ngit remote-testgit\t协议扩展示例脚本版本库转换和交互相关命令\n命令\t简要说明\ngit archimport\t导入Arch版本库到Git\ngit bundle\t提交打包和解包，以便在不同版本库间传递\ngit cvsexportcommit\t将Git的一个提交作为一个CVS检出\ngit cvsimport\t导入CVS版本库到Git。或者使用 cvs2git\ngit cvsserver\tGit的CVS协议模拟器，可供CVS命令访问Git版本库\ngit fast-export\t将提交导出为 git-fast-import 格式\ngit fast-import\t其他版本库迁移至Git的通用工具\ngit svn\tGit 作为前端操作 Subversion合并相关的辅助命令\n命令\t简要说明\ngit merge-base\t供其他脚本调用，找到两个或多个提交最近的共同祖先\ngit merge-file\t针对文件的两个不同版本执行三向文件合并\ngit merge-index\t对index中的冲突文件调用指定的冲突解决工具\ngit merge-octopus\t合并两个以上分支。参见 git merge 的octopus合并策略\ngit merge-one-file\t由 git merge-index 调用的标准辅助程序\ngit merge-ours\t合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略\ngit merge-recursive\t针对两个分支的三向合并。参见 git merge 的recursive合并策略\ngit merge-resolve\t针对两个分支的三向合并。参见 git merge 的resolve合并策略\ngit merge-subtree\t子树合并。参见 git merge 的 subtree 合并策略\ngit merge-tree\t显式三向合并结果，不改变暂存区\ngit fmt-merge-msg\t供执行合并操作的脚本调用，用于创建一个合并提交说明\ngit rerere\t重用所记录的冲突解决方案杂项\n命令\t简要说明\ngit bisect–helper\t由 git bisect 命令调用，确认二分查找进度\ngit check-attr\t显示某个文件是否设置了某个属性\ngit checkout-index\t从暂存区拷贝文件至工作区\ngit cherry\t查找没有合并到上游的提交\ngit diff-files\t比较暂存区和工作区，相当于 git diff –raw\ngit diff-index\t比较暂存区和版本库，相当于 git diff –cached –raw\ngit diff-tree\t比较两个树对象，相当于 git diff –raw A B\ngit difftool–helper\t由 git difftool 命令调用，默认要使用的差异比较工具\ngit get-tar-commit-id\t从 git archive 创建的 tar 包中提取提交ID\ngit gui–askpass\t命令 git gui 的获取用户口令输入界面\ngit notes\t提交评论管理\ngit patch-id\t补丁过滤行号和空白字符后生成补丁唯一ID\ngit quiltimport\t将Quilt补丁列表应用到当前分支\ngit replace\t提交替换\ngit shortlog\t对 git log 的汇总输出，适合于产品发布说明\ngit stripspace\t删除空行，供其他脚本调用\ngit submodule\t子模组管理\ngit tar-tree\t过时命令，请使用 git archive\ngit var\t显示 Git 环境变量\ngit web–browse\t启动浏览器以查看目录或文件\ngit whatchanged\t显示提交历史及每次提交的改动\ngit-mergetool–lib\t包含于其他脚本中，提供合并/差异比较工具的选择和执行\ngit-parse-remote\t包含于其他脚本中，提供操作远程版本库的函数\ngit-sh-setup\t包含于其他脚本中，提供 shell 编程的函数库原文地址：","slug":"git-opeation","published":1,"date":"2018-01-28T09:39:06.209Z","updated":"2018-01-28T09:40:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcymfvsc0002s2gse2ugzme5","content":"<p>Git 常用命令速查<br>git branch 查看本地所有分支<br>git status 查看当前状态<br>git commit 提交<br>git branch -a 查看所有的分支<br>git branch -r 查看远程所有分支<br>git commit -am “init” 提交并且加注释<br>git remote add origin git@192.168.1.119:ndshow<br>git push origin master 将文件给推到服务器上<br>git remote show origin 显示远程库origin里的资源<br>git push origin master:develop<br>git push origin master:hb-dev 将本地库与服务器上的库进行关联<br>git checkout –track origin/dev 切换到远程dev分支<br>git branch -D master develop 删除本地库develop<br>git checkout -b dev 建立一个新的本地分支dev<br>git merge origin/dev 将分支dev与当前分支进行合并<br>git checkout dev 切换到本地dev分支<br>git remote show 查看远程库<br>git add . 他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。<br>git rm 文件名(包括路径) 从git中删除指定文件<br>git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来<br>git config –list 看所有用户<br>git ls-files 看已经被提交的<br>git rm [file name] 删除一个文件<br>git commit -a 提交当前repos的所有的改变<br>git add [file name] 添加一个文件到git index<br>git commit -v 当你用－v参数的时候可以看commit的差异<br>git commit -m “This is the message describing the commit” 添加commit信息<br>git commit -a -a是代表add，把所有的change加到git index里然后再commit<br>git commit -a -v 一般提交命令<br>git log 看你commit的日志<br>git diff 查看尚未暂存的更新<br>git rm a.a 移除文件(从暂存区和工作区中删除)<br>git rm –cached a.a 移除文件(只从暂存区中删除)<br>git commit -m “remove” 移除文件(从Git中删除)<br>git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)<br>git diff –cached 或 $ git diff –staged 查看尚未提交的更新<br>git stash push 将文件给push到一个临时空间中<br>git stash pop 将文件从临时空间pop下来<br>git remote add origin git@github.com:username/Hello-World.git<br>git push origin master 将本地项目给提交到服务器中<br>git pull 本地与服务器端同步<br>git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。<br>git push origin serverfix:awesomebranch<br>git fetch 相当于是从远程获取最新版本到本地，不会自动merge<br>git commit -a -m “log_message” (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：<br>git branch branch_0.1 master 从主分支master创建branch_0.1分支<br>git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0<br>git checkout branch_1.0/master 切换到branch_1.0/master分支<br>du -hs<br>git branch 删除远程branch<br>git push origin :branch_remote_name<br>git branch -r -d branch_remote_name<br>初始化版本库，并提交到远程服务器端</p>\n<p>mkdir WebApp<br>cd WebApp<br>git init 本地初始化<br>touch README<br>git add README 添加文件<br>git commit -m ‘first commit’<br>git remote add origin git@github.com:daixu/WebApp.git<br>增加一个远程服务器端</p>\n<p>上面的命令会增加URL地址为’git@github.com:daixu/WebApp.git’，名称为origin的远程服务器库，以后提交代码的时候只需要使用 origin别名即可</p>\n<p>Git 命令速查表<br>常用的Git命令<br>命令    简要说明<br>git add    添加至暂存区<br>git add–interactive    交互式添加<br>git apply    应用补丁<br>git am    应用邮件格式补丁<br>git annotate    同义词，等同于 git blame<br>git archive    文件归档打包<br>git bisect    二分查找<br>git blame    文件逐行追溯<br>git branch    分支管理<br>git cat-file    版本库对象研究工具<br>git checkout    检出到工作区、切换或创建分支<br>git cherry-pick    提交拣选<br>git citool    图形化提交，相当于 git gui 命令<br>git clean    清除工作区未跟踪文件<br>git clone    克隆版本库<br>git commit    提交<br>git config    查询和修改配置<br>git describe    通过里程碑直观地显示提交ID<br>git diff    差异比较<br>git difftool    调用图形化差异比较工具<br>git fetch    获取远程版本库的提交<br>git format-patch    创建邮件格式的补丁文件。参见 git am 命令<br>git grep    文件内容搜索定位工具<br>git gui    基于Tcl/Tk的图形化工具，侧重提交等操作<br>git help    帮助<br>git init    版本库初始化<br>git init-db<em>    同义词，等同于 git init<br>git log    显示提交日志<br>git merge    分支合并<br>git mergetool    图形化冲突解决<br>git mv    重命名<br>git pull    拉回远程版本库的提交<br>git push    推送至远程版本库<br>git rebase    分支变基<br>git rebase–interactive    交互式分支变基<br>git reflog    分支等引用变更记录管理<br>git remote    远程版本库管理<br>git repo-config</em>    同义词，等同于 git config<br>git reset    重置改变分支“游标”指向<br>git rev-parse    将各种引用表示法转换为哈希值等<br>git revert    反转提交<br>git rm    删除文件<br>git show    显示各种类型的对象<br>git stage<em>    同义词，等同于 git add<br>git stash    保存和恢复进度<br>git status    显示工作区文件状态<br>git tag    里程碑管理对象库操作相关命令<br>命令    简要说明<br>git commit-tree    从树对象创建提交<br>git hash-object    从标准输入或文件计算哈希值或创建对象<br>git ls-files    显示工作区和暂存区文件<br>git ls-tree    显示树对象包含的文件<br>git mktag    读取标准输入创建一个里程碑对象<br>git mktree    读取标准输入创建一个树对象<br>git read-tree    读取树对象到暂存区<br>git update-index    工作区内容注册到暂存区及暂存区管理<br>git unpack-file    创建临时文件包含指定 blob 的内容<br>git write-tree    从暂存区创建一个树对象引用操作相关命令<br>命令    简要说明<br>git check-ref-format    检查引用名称是否符合规范<br>git for-each-ref    引用迭代器，用于shell编程<br>git ls-remote    显示远程版本库的引用<br>git name-rev    将提交ID显示为友好名称<br>git peek-remote</em>    过时命令，请使用 git ls-remote<br>git rev-list    显示版本范围<br>git show-branch    显示分支列表及拓扑关系<br>git show-ref    显示本地引用<br>git symbolic-ref    显示或者设置符号引用<br>git update-ref    更新引用的指向<br>git verify-tag    校验 GPG 签名的Tag版本库管理相关命令<br>命令    简要说明<br>git count-objects    显示松散对象的数量和磁盘占用<br>git filter-branch    版本库重构<br>git fsck    对象库完整性检查<br>git fsck-objects<em>    同义词，等同于 git fsck<br>git gc    版本库存储优化<br>git index-pack    从打包文件创建对应的索引文件<br>git lost-found</em>    过时，请使用 git fsck –lost-found 命令<br>git pack-objects    从标准输入读入对象ID，打包到文件<br>git pack-redundant    查找多余的 pack 文件<br>git pack-refs    将引用打包到 .git/packed-refs 文件中<br>git prune    从对象库删除过期对象<br>git prune-packed    将已经打包的松散对象删除<br>git relink    为本地版本库中相同的对象建立硬连接<br>git repack    将版本库未打包的松散对象打包<br>git show-index    读取包的索引文件，显示打包文件中的内容<br>git unpack-objects    从打包文件释放文件<br>git verify-pack    校验对象库打包文件数据传输相关命令<br>命令    简要说明<br>git fetch-pack    执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象<br>git receive-pack    执行 git push 命令时在远程执行的命令，用于接受推送的数据<br>git send-pack    执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据<br>git upload-archive    执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档<br>git upload-pack    执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传邮件相关命令<br>命令    简要说明<br>git imap-send    将补丁通过 IMAP 发送<br>git mailinfo    从邮件导出提交说明和补丁<br>git mailsplit    将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件<br>git request-pull    创建包含提交间差异和执行PULL操作地址的信息<br>git send-email    发送邮件协议相关命令<br>命令    简要说明<br>git daemon    实现Git协议<br>git http-backend    实现HTTP协议的CGI程序，支持智能HTTP协议<br>git instaweb    即时启动浏览器通过 gitweb 浏览当前版本库<br>git shell    受限制的shell，提供仅执行Git命令的SSH访问<br>git update-server-info    更新哑协议需要的辅助文件<br>git http-fetch    通过HTTP协议获取版本库<br>git http-push    通过HTTP/DAV协议推送<br>git remote-ext    由Git命令调用，通过外部命令提供扩展协议支持<br>git remote-fd    由Git命令调用，使用文件描述符作为协议接口<br>git remote-ftp    由Git命令调用，提供对FTP协议的支持<br>git remote-ftps    由Git命令调用，提供对FTPS协议的支持<br>git remote-http    由Git命令调用，提供对HTTP协议的支持<br>git remote-https    由Git命令调用，提供对HTTPS协议的支持<br>git remote-testgit    协议扩展示例脚本版本库转换和交互相关命令<br>命令    简要说明<br>git archimport    导入Arch版本库到Git<br>git bundle    提交打包和解包，以便在不同版本库间传递<br>git cvsexportcommit    将Git的一个提交作为一个CVS检出<br>git cvsimport    导入CVS版本库到Git。或者使用 cvs2git<br>git cvsserver    Git的CVS协议模拟器，可供CVS命令访问Git版本库<br>git fast-export    将提交导出为 git-fast-import 格式<br>git fast-import    其他版本库迁移至Git的通用工具<br>git svn    Git 作为前端操作 Subversion合并相关的辅助命令<br>命令    简要说明<br>git merge-base    供其他脚本调用，找到两个或多个提交最近的共同祖先<br>git merge-file    针对文件的两个不同版本执行三向文件合并<br>git merge-index    对index中的冲突文件调用指定的冲突解决工具<br>git merge-octopus    合并两个以上分支。参见 git merge 的octopus合并策略<br>git merge-one-file    由 git merge-index 调用的标准辅助程序<br>git merge-ours    合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略<br>git merge-recursive    针对两个分支的三向合并。参见 git merge 的recursive合并策略<br>git merge-resolve    针对两个分支的三向合并。参见 git merge 的resolve合并策略<br>git merge-subtree    子树合并。参见 git merge 的 subtree 合并策略<br>git merge-tree    显式三向合并结果，不改变暂存区<br>git fmt-merge-msg    供执行合并操作的脚本调用，用于创建一个合并提交说明<br>git rerere    重用所记录的冲突解决方案杂项<br>命令    简要说明<br>git bisect–helper    由 git bisect 命令调用，确认二分查找进度<br>git check-attr    显示某个文件是否设置了某个属性<br>git checkout-index    从暂存区拷贝文件至工作区<br>git cherry    查找没有合并到上游的提交<br>git diff-files    比较暂存区和工作区，相当于 git diff –raw<br>git diff-index    比较暂存区和版本库，相当于 git diff –cached –raw<br>git diff-tree    比较两个树对象，相当于 git diff –raw A B<br>git difftool–helper    由 git difftool 命令调用，默认要使用的差异比较工具<br>git get-tar-commit-id    从 git archive 创建的 tar 包中提取提交ID<br>git gui–askpass    命令 git gui 的获取用户口令输入界面<br>git notes    提交评论管理<br>git patch-id    补丁过滤行号和空白字符后生成补丁唯一ID<br>git quiltimport    将Quilt补丁列表应用到当前分支<br>git replace    提交替换<br>git shortlog    对 git log 的汇总输出，适合于产品发布说明<br>git stripspace    删除空行，供其他脚本调用<br>git submodule    子模组管理<br>git tar-tree    过时命令，请使用 git archive<br>git var    显示 Git 环境变量<br>git web–browse    启动浏览器以查看目录或文件<br>git whatchanged    显示提交历史及每次提交的改动<br>git-mergetool–lib    包含于其他脚本中，提供合并/差异比较工具的选择和执行<br>git-parse-remote    包含于其他脚本中，提供操作远程版本库的函数<br>git-sh-setup    包含于其他脚本中，提供 shell 编程的函数库原文地址：</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Git 常用命令速查<br>git branch 查看本地所有分支<br>git status 查看当前状态<br>git commit 提交<br>git branch -a 查看所有的分支<br>git branch -r 查看远程所有分支<br>git commit -am “init” 提交并且加注释<br>git remote add origin git@192.168.1.119:ndshow<br>git push origin master 将文件给推到服务器上<br>git remote show origin 显示远程库origin里的资源<br>git push origin master:develop<br>git push origin master:hb-dev 将本地库与服务器上的库进行关联<br>git checkout –track origin/dev 切换到远程dev分支<br>git branch -D master develop 删除本地库develop<br>git checkout -b dev 建立一个新的本地分支dev<br>git merge origin/dev 将分支dev与当前分支进行合并<br>git checkout dev 切换到本地dev分支<br>git remote show 查看远程库<br>git add . 他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。<br>git rm 文件名(包括路径) 从git中删除指定文件<br>git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来<br>git config –list 看所有用户<br>git ls-files 看已经被提交的<br>git rm [file name] 删除一个文件<br>git commit -a 提交当前repos的所有的改变<br>git add [file name] 添加一个文件到git index<br>git commit -v 当你用－v参数的时候可以看commit的差异<br>git commit -m “This is the message describing the commit” 添加commit信息<br>git commit -a -a是代表add，把所有的change加到git index里然后再commit<br>git commit -a -v 一般提交命令<br>git log 看你commit的日志<br>git diff 查看尚未暂存的更新<br>git rm a.a 移除文件(从暂存区和工作区中删除)<br>git rm –cached a.a 移除文件(只从暂存区中删除)<br>git commit -m “remove” 移除文件(从Git中删除)<br>git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)<br>git diff –cached 或 $ git diff –staged 查看尚未提交的更新<br>git stash push 将文件给push到一个临时空间中<br>git stash pop 将文件从临时空间pop下来<br>git remote add origin git@github.com:username/Hello-World.git<br>git push origin master 将本地项目给提交到服务器中<br>git pull 本地与服务器端同步<br>git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。<br>git push origin serverfix:awesomebranch<br>git fetch 相当于是从远程获取最新版本到本地，不会自动merge<br>git commit -a -m “log_message” (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：<br>git branch branch_0.1 master 从主分支master创建branch_0.1分支<br>git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0<br>git checkout branch_1.0/master 切换到branch_1.0/master分支<br>du -hs<br>git branch 删除远程branch<br>git push origin :branch_remote_name<br>git branch -r -d branch_remote_name<br>初始化版本库，并提交到远程服务器端</p>\n<p>mkdir WebApp<br>cd WebApp<br>git init 本地初始化<br>touch README<br>git add README 添加文件<br>git commit -m ‘first commit’<br>git remote add origin git@github.com:daixu/WebApp.git<br>增加一个远程服务器端</p>\n<p>上面的命令会增加URL地址为’git@github.com:daixu/WebApp.git’，名称为origin的远程服务器库，以后提交代码的时候只需要使用 origin别名即可</p>\n<p>Git 命令速查表<br>常用的Git命令<br>命令    简要说明<br>git add    添加至暂存区<br>git add–interactive    交互式添加<br>git apply    应用补丁<br>git am    应用邮件格式补丁<br>git annotate    同义词，等同于 git blame<br>git archive    文件归档打包<br>git bisect    二分查找<br>git blame    文件逐行追溯<br>git branch    分支管理<br>git cat-file    版本库对象研究工具<br>git checkout    检出到工作区、切换或创建分支<br>git cherry-pick    提交拣选<br>git citool    图形化提交，相当于 git gui 命令<br>git clean    清除工作区未跟踪文件<br>git clone    克隆版本库<br>git commit    提交<br>git config    查询和修改配置<br>git describe    通过里程碑直观地显示提交ID<br>git diff    差异比较<br>git difftool    调用图形化差异比较工具<br>git fetch    获取远程版本库的提交<br>git format-patch    创建邮件格式的补丁文件。参见 git am 命令<br>git grep    文件内容搜索定位工具<br>git gui    基于Tcl/Tk的图形化工具，侧重提交等操作<br>git help    帮助<br>git init    版本库初始化<br>git init-db<em>    同义词，等同于 git init<br>git log    显示提交日志<br>git merge    分支合并<br>git mergetool    图形化冲突解决<br>git mv    重命名<br>git pull    拉回远程版本库的提交<br>git push    推送至远程版本库<br>git rebase    分支变基<br>git rebase–interactive    交互式分支变基<br>git reflog    分支等引用变更记录管理<br>git remote    远程版本库管理<br>git repo-config</em>    同义词，等同于 git config<br>git reset    重置改变分支“游标”指向<br>git rev-parse    将各种引用表示法转换为哈希值等<br>git revert    反转提交<br>git rm    删除文件<br>git show    显示各种类型的对象<br>git stage<em>    同义词，等同于 git add<br>git stash    保存和恢复进度<br>git status    显示工作区文件状态<br>git tag    里程碑管理对象库操作相关命令<br>命令    简要说明<br>git commit-tree    从树对象创建提交<br>git hash-object    从标准输入或文件计算哈希值或创建对象<br>git ls-files    显示工作区和暂存区文件<br>git ls-tree    显示树对象包含的文件<br>git mktag    读取标准输入创建一个里程碑对象<br>git mktree    读取标准输入创建一个树对象<br>git read-tree    读取树对象到暂存区<br>git update-index    工作区内容注册到暂存区及暂存区管理<br>git unpack-file    创建临时文件包含指定 blob 的内容<br>git write-tree    从暂存区创建一个树对象引用操作相关命令<br>命令    简要说明<br>git check-ref-format    检查引用名称是否符合规范<br>git for-each-ref    引用迭代器，用于shell编程<br>git ls-remote    显示远程版本库的引用<br>git name-rev    将提交ID显示为友好名称<br>git peek-remote</em>    过时命令，请使用 git ls-remote<br>git rev-list    显示版本范围<br>git show-branch    显示分支列表及拓扑关系<br>git show-ref    显示本地引用<br>git symbolic-ref    显示或者设置符号引用<br>git update-ref    更新引用的指向<br>git verify-tag    校验 GPG 签名的Tag版本库管理相关命令<br>命令    简要说明<br>git count-objects    显示松散对象的数量和磁盘占用<br>git filter-branch    版本库重构<br>git fsck    对象库完整性检查<br>git fsck-objects<em>    同义词，等同于 git fsck<br>git gc    版本库存储优化<br>git index-pack    从打包文件创建对应的索引文件<br>git lost-found</em>    过时，请使用 git fsck –lost-found 命令<br>git pack-objects    从标准输入读入对象ID，打包到文件<br>git pack-redundant    查找多余的 pack 文件<br>git pack-refs    将引用打包到 .git/packed-refs 文件中<br>git prune    从对象库删除过期对象<br>git prune-packed    将已经打包的松散对象删除<br>git relink    为本地版本库中相同的对象建立硬连接<br>git repack    将版本库未打包的松散对象打包<br>git show-index    读取包的索引文件，显示打包文件中的内容<br>git unpack-objects    从打包文件释放文件<br>git verify-pack    校验对象库打包文件数据传输相关命令<br>命令    简要说明<br>git fetch-pack    执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象<br>git receive-pack    执行 git push 命令时在远程执行的命令，用于接受推送的数据<br>git send-pack    执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据<br>git upload-archive    执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档<br>git upload-pack    执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传邮件相关命令<br>命令    简要说明<br>git imap-send    将补丁通过 IMAP 发送<br>git mailinfo    从邮件导出提交说明和补丁<br>git mailsplit    将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件<br>git request-pull    创建包含提交间差异和执行PULL操作地址的信息<br>git send-email    发送邮件协议相关命令<br>命令    简要说明<br>git daemon    实现Git协议<br>git http-backend    实现HTTP协议的CGI程序，支持智能HTTP协议<br>git instaweb    即时启动浏览器通过 gitweb 浏览当前版本库<br>git shell    受限制的shell，提供仅执行Git命令的SSH访问<br>git update-server-info    更新哑协议需要的辅助文件<br>git http-fetch    通过HTTP协议获取版本库<br>git http-push    通过HTTP/DAV协议推送<br>git remote-ext    由Git命令调用，通过外部命令提供扩展协议支持<br>git remote-fd    由Git命令调用，使用文件描述符作为协议接口<br>git remote-ftp    由Git命令调用，提供对FTP协议的支持<br>git remote-ftps    由Git命令调用，提供对FTPS协议的支持<br>git remote-http    由Git命令调用，提供对HTTP协议的支持<br>git remote-https    由Git命令调用，提供对HTTPS协议的支持<br>git remote-testgit    协议扩展示例脚本版本库转换和交互相关命令<br>命令    简要说明<br>git archimport    导入Arch版本库到Git<br>git bundle    提交打包和解包，以便在不同版本库间传递<br>git cvsexportcommit    将Git的一个提交作为一个CVS检出<br>git cvsimport    导入CVS版本库到Git。或者使用 cvs2git<br>git cvsserver    Git的CVS协议模拟器，可供CVS命令访问Git版本库<br>git fast-export    将提交导出为 git-fast-import 格式<br>git fast-import    其他版本库迁移至Git的通用工具<br>git svn    Git 作为前端操作 Subversion合并相关的辅助命令<br>命令    简要说明<br>git merge-base    供其他脚本调用，找到两个或多个提交最近的共同祖先<br>git merge-file    针对文件的两个不同版本执行三向文件合并<br>git merge-index    对index中的冲突文件调用指定的冲突解决工具<br>git merge-octopus    合并两个以上分支。参见 git merge 的octopus合并策略<br>git merge-one-file    由 git merge-index 调用的标准辅助程序<br>git merge-ours    合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略<br>git merge-recursive    针对两个分支的三向合并。参见 git merge 的recursive合并策略<br>git merge-resolve    针对两个分支的三向合并。参见 git merge 的resolve合并策略<br>git merge-subtree    子树合并。参见 git merge 的 subtree 合并策略<br>git merge-tree    显式三向合并结果，不改变暂存区<br>git fmt-merge-msg    供执行合并操作的脚本调用，用于创建一个合并提交说明<br>git rerere    重用所记录的冲突解决方案杂项<br>命令    简要说明<br>git bisect–helper    由 git bisect 命令调用，确认二分查找进度<br>git check-attr    显示某个文件是否设置了某个属性<br>git checkout-index    从暂存区拷贝文件至工作区<br>git cherry    查找没有合并到上游的提交<br>git diff-files    比较暂存区和工作区，相当于 git diff –raw<br>git diff-index    比较暂存区和版本库，相当于 git diff –cached –raw<br>git diff-tree    比较两个树对象，相当于 git diff –raw A B<br>git difftool–helper    由 git difftool 命令调用，默认要使用的差异比较工具<br>git get-tar-commit-id    从 git archive 创建的 tar 包中提取提交ID<br>git gui–askpass    命令 git gui 的获取用户口令输入界面<br>git notes    提交评论管理<br>git patch-id    补丁过滤行号和空白字符后生成补丁唯一ID<br>git quiltimport    将Quilt补丁列表应用到当前分支<br>git replace    提交替换<br>git shortlog    对 git log 的汇总输出，适合于产品发布说明<br>git stripspace    删除空行，供其他脚本调用<br>git submodule    子模组管理<br>git tar-tree    过时命令，请使用 git archive<br>git var    显示 Git 环境变量<br>git web–browse    启动浏览器以查看目录或文件<br>git whatchanged    显示提交历史及每次提交的改动<br>git-mergetool–lib    包含于其他脚本中，提供合并/差异比较工具的选择和执行<br>git-parse-remote    包含于其他脚本中，提供操作远程版本库的函数<br>git-sh-setup    包含于其他脚本中，提供 shell 编程的函数库原文地址：</p>\n"},{"title":"小型企业内部接口调试项目","date":"2018-01-28T07:37:46.000Z","_content":"\n#小型企业内部接口调试项目\n\n## https://gitee.com/charsle/restApi.git  \n\n### 如果觉得喜欢，欢迎star\n\n#### 系统说明\n  1. 系统分为后台开发人员接口上传，前端人员接口展示,统一进行登陆\n![统一进行登陆](https://gitee.com/uploads/images/2018/0127/183539_8060b43e_447841.png \"QQ20180127-180825@2x.png\")\n\n  2. 系统分为后台开发人员接口进行项目配置，可以对该项目进行增删改查，\n![项目配置](https://gitee.com/uploads/images/2018/0127/183702_0040927f_447841.png \"QQ20180127-182605@2x.png\")\n\n  3. 系统分为后台开发人员接口进行接口配置，对接口进行增删改查\n![接口配置](https://gitee.com/uploads/images/2018/0127/183804_1566a606_447841.png \"QQ20180127-182638@2x.png\")\n\n   4. 前端人员接口展示，进行接口的调试，以及需要授权的接口，进行设置\n![前端人员调试](https://gitee.com/uploads/images/2018/0127/183952_ca09b3ce_447841.png \"QQ20180127-182908@2x.png\")\n\n\n### Development\n\n```bash\n$ npm i\n$ npm run dev\n$ open http://localhost:7001/\n```\n\n### Deploy\n\n```bash\n$ npm start\n$ npm stop\n```\n\n### npm scripts\n\n- Use `npm run lint` to check code style.\n- Use `npm test` to run unit test.\n- Use `npm run autod` to auto detect dependencies upgrade, see [autod](https://www.npmjs.com/package/autod) for more detail.\n\n\n[egg]: https://eggjs.org","source":"_posts/info.md","raw":"---\ntitle: 小型企业内部接口调试项目\ndate: 2018-01-28 15:37:46\ntags: system, api,前端接口对接,后端\n---\n\n#小型企业内部接口调试项目\n\n## https://gitee.com/charsle/restApi.git  \n\n### 如果觉得喜欢，欢迎star\n\n#### 系统说明\n  1. 系统分为后台开发人员接口上传，前端人员接口展示,统一进行登陆\n![统一进行登陆](https://gitee.com/uploads/images/2018/0127/183539_8060b43e_447841.png \"QQ20180127-180825@2x.png\")\n\n  2. 系统分为后台开发人员接口进行项目配置，可以对该项目进行增删改查，\n![项目配置](https://gitee.com/uploads/images/2018/0127/183702_0040927f_447841.png \"QQ20180127-182605@2x.png\")\n\n  3. 系统分为后台开发人员接口进行接口配置，对接口进行增删改查\n![接口配置](https://gitee.com/uploads/images/2018/0127/183804_1566a606_447841.png \"QQ20180127-182638@2x.png\")\n\n   4. 前端人员接口展示，进行接口的调试，以及需要授权的接口，进行设置\n![前端人员调试](https://gitee.com/uploads/images/2018/0127/183952_ca09b3ce_447841.png \"QQ20180127-182908@2x.png\")\n\n\n### Development\n\n```bash\n$ npm i\n$ npm run dev\n$ open http://localhost:7001/\n```\n\n### Deploy\n\n```bash\n$ npm start\n$ npm stop\n```\n\n### npm scripts\n\n- Use `npm run lint` to check code style.\n- Use `npm test` to run unit test.\n- Use `npm run autod` to auto detect dependencies upgrade, see [autod](https://www.npmjs.com/package/autod) for more detail.\n\n\n[egg]: https://eggjs.org","slug":"info","published":1,"updated":"2018-01-28T09:41:03.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcymfvsh0005s2gsc88po3gi","content":"<p>#小型企业内部接口调试项目</p>\n<h2 id=\"https-gitee-com-charsle-restApi-git\"><a href=\"#https-gitee-com-charsle-restApi-git\" class=\"headerlink\" title=\"https://gitee.com/charsle/restApi.git\"></a><a href=\"https://gitee.com/charsle/restApi.git\" target=\"_blank\" rel=\"noopener\">https://gitee.com/charsle/restApi.git</a></h2><h3 id=\"如果觉得喜欢，欢迎star\"><a href=\"#如果觉得喜欢，欢迎star\" class=\"headerlink\" title=\"如果觉得喜欢，欢迎star\"></a>如果觉得喜欢，欢迎star</h3><h4 id=\"系统说明\"><a href=\"#系统说明\" class=\"headerlink\" title=\"系统说明\"></a>系统说明</h4><ol>\n<li><p>系统分为后台开发人员接口上传，前端人员接口展示,统一进行登陆<br><img src=\"https://gitee.com/uploads/images/2018/0127/183539_8060b43e_447841.png\" alt=\"统一进行登陆\" title=\"QQ20180127-180825@2x.png\"></p>\n</li>\n<li><p>系统分为后台开发人员接口进行项目配置，可以对该项目进行增删改查，<br><img src=\"https://gitee.com/uploads/images/2018/0127/183702_0040927f_447841.png\" alt=\"项目配置\" title=\"QQ20180127-182605@2x.png\"></p>\n</li>\n<li><p>系统分为后台开发人员接口进行接口配置，对接口进行增删改查<br><img src=\"https://gitee.com/uploads/images/2018/0127/183804_1566a606_447841.png\" alt=\"接口配置\" title=\"QQ20180127-182638@2x.png\"></p>\n<ol>\n<li>前端人员接口展示，进行接口的调试，以及需要授权的接口，进行设置<br><img src=\"https://gitee.com/uploads/images/2018/0127/183952_ca09b3ce_447841.png\" alt=\"前端人员调试\" title=\"QQ20180127-182908@2x.png\"></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Development\"><a href=\"#Development\" class=\"headerlink\" title=\"Development\"></a>Development</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm i</span><br><span class=\"line\">$ npm run dev</span><br><span class=\"line\">$ open http://localhost:7001/</span><br></pre></td></tr></table></figure>\n<h3 id=\"Deploy\"><a href=\"#Deploy\" class=\"headerlink\" title=\"Deploy\"></a>Deploy</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm start</span><br><span class=\"line\">$ npm stop</span><br></pre></td></tr></table></figure>\n<h3 id=\"npm-scripts\"><a href=\"#npm-scripts\" class=\"headerlink\" title=\"npm scripts\"></a>npm scripts</h3><ul>\n<li>Use <code>npm run lint</code> to check code style.</li>\n<li>Use <code>npm test</code> to run unit test.</li>\n<li>Use <code>npm run autod</code> to auto detect dependencies upgrade, see <a href=\"https://www.npmjs.com/package/autod\" target=\"_blank\" rel=\"noopener\">autod</a> for more detail.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>#小型企业内部接口调试项目</p>\n<h2 id=\"https-gitee-com-charsle-restApi-git\"><a href=\"#https-gitee-com-charsle-restApi-git\" class=\"headerlink\" title=\"https://gitee.com/charsle/restApi.git\"></a><a href=\"https://gitee.com/charsle/restApi.git\" target=\"_blank\" rel=\"noopener\">https://gitee.com/charsle/restApi.git</a></h2><h3 id=\"如果觉得喜欢，欢迎star\"><a href=\"#如果觉得喜欢，欢迎star\" class=\"headerlink\" title=\"如果觉得喜欢，欢迎star\"></a>如果觉得喜欢，欢迎star</h3><h4 id=\"系统说明\"><a href=\"#系统说明\" class=\"headerlink\" title=\"系统说明\"></a>系统说明</h4><ol>\n<li><p>系统分为后台开发人员接口上传，前端人员接口展示,统一进行登陆<br><img src=\"https://gitee.com/uploads/images/2018/0127/183539_8060b43e_447841.png\" alt=\"统一进行登陆\" title=\"QQ20180127-180825@2x.png\"></p>\n</li>\n<li><p>系统分为后台开发人员接口进行项目配置，可以对该项目进行增删改查，<br><img src=\"https://gitee.com/uploads/images/2018/0127/183702_0040927f_447841.png\" alt=\"项目配置\" title=\"QQ20180127-182605@2x.png\"></p>\n</li>\n<li><p>系统分为后台开发人员接口进行接口配置，对接口进行增删改查<br><img src=\"https://gitee.com/uploads/images/2018/0127/183804_1566a606_447841.png\" alt=\"接口配置\" title=\"QQ20180127-182638@2x.png\"></p>\n<ol>\n<li>前端人员接口展示，进行接口的调试，以及需要授权的接口，进行设置<br><img src=\"https://gitee.com/uploads/images/2018/0127/183952_ca09b3ce_447841.png\" alt=\"前端人员调试\" title=\"QQ20180127-182908@2x.png\"></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Development\"><a href=\"#Development\" class=\"headerlink\" title=\"Development\"></a>Development</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm i</span><br><span class=\"line\">$ npm run dev</span><br><span class=\"line\">$ open http://localhost:7001/</span><br></pre></td></tr></table></figure>\n<h3 id=\"Deploy\"><a href=\"#Deploy\" class=\"headerlink\" title=\"Deploy\"></a>Deploy</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm start</span><br><span class=\"line\">$ npm stop</span><br></pre></td></tr></table></figure>\n<h3 id=\"npm-scripts\"><a href=\"#npm-scripts\" class=\"headerlink\" title=\"npm scripts\"></a>npm scripts</h3><ul>\n<li>Use <code>npm run lint</code> to check code style.</li>\n<li>Use <code>npm test</code> to run unit test.</li>\n<li>Use <code>npm run autod</code> to auto detect dependencies upgrade, see <a href=\"https://www.npmjs.com/package/autod\" target=\"_blank\" rel=\"noopener\">autod</a> for more detail.</li>\n</ul>\n"},{"title":"了解真实的『REM』手机屏幕适配","date":"2018-01-28T09:58:49.000Z","_content":"rem 作为一个低调的长度单位，由于手机端网页的兴起，在屏幕适配中得到重用。使用 rem 前端开发者可以很方便的在各种屏幕尺寸下，通过等比缩放的方式达到设计图要求的效果。\n\nrem 的官方定义『The font size of the root element.』，即以根节点的字体大小作为基准值进行长度计算。一般认为网页中的根节点是 html 元素，所以采用的方式也是通过设置 html 元素的 font-size 来做屏幕适配，但实际情况真有这么简单吗？\n\n首先我们来看看使用 rem 实现手机屏幕适配的常用方案。\n\n以设计稿的宽度为640px，即：designWidth = 640，同时设定在640px屏宽下 1rem=100px ，即：rem2px = 100。\n\n设置 1rem=100px 的优点不言而喻。前端开发者在切图、重构页面的时候，通过直接位移小数点的方式，就可以将UI图中测量到的 px 值换算成对应的 rem 值，方便快捷。\n\n此外，在 head 中我们还设置了：<meta name=”viewport” content=”width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0″ />\nviewport 的作用很重要，但不是本文的重点所以不展开，有兴趣的同学可以自行搜索。\n\n先来看看具体方案：\n\n下面四个方案来自同事共享，原理都是采用等比缩放的方式 —— 获得目标屏幕宽度和设计稿宽度的比，作为 rem 的基值（缩放系数），设置为html标签的字体大小。不同的只是在于性能取舍和书写习惯。\n\n方案1\n\n@media screen and (min-width: 320px) {html{font-size:50px;}}\n@media screen and (min-width: 360px) {html{font-size:56.25px;}}\n@media screen and (min-width: 375px) {html{font-size:58.59375px;}}\n@media screen and (min-width: 400px) {html{font-size:62.5px;}}\n@media screen and (min-width: 414px) {html{font-size:64.6875px;}}\n@media screen and (min-width: 440px) {html{font-size:68.75px;}}\n@media screen and (min-width: 480px) {html{font-size:75px;}}\n@media screen and (min-width: 520px) {html{font-size:81.25px;}}\n@media screen and (min-width: 560px) {html{font-size:87.5px;}}\n@media screen and (min-width: 600px) {html{font-size:93.75px;}}\n@media screen and (min-width: 640px) {html{font-size:100px;}}\n@media screen and (min-width: 680px) {html{font-size:106.25px;}}\n@media screen and (min-width: 720px) {html{font-size:112.5px;}}\n@media screen and (min-width: 760px) {html{font-size:118.75px;}}\n@media screen and (min-width: 800px) {html{font-size:125px;}}\n@media screen and (min-width: 960px) {html{font-size:150px;}}\n方案2\n\n@media screen and (min-width: 320px) {html{font-size:312.5%;}}\n@media screen and (min-width: 360px) {html{font-size:351.5625%;}}\n@media screen and (min-width: 375px) {html{font-size:366.211%;}}\n@media screen and (min-width: 400px) {html{font-size:390.625%;}}\n@media screen and (min-width: 414px) {html{font-size:404.2969%;}}\n@media screen and (min-width: 440px) {html{font-size:429.6875%;}}\n@media screen and (min-width: 480px) {html{font-size:468.75%;}}\n@media screen and (min-width: 520px) {html{font-size:507.8125%;}}\n@media screen and (min-width: 560px) {html{font-size:546.875%;}}\n@media screen and (min-width: 600px) {html{font-size:585.9375%;}}\n@media screen and (min-width: 640px) {html{font-size:625%;}}\n@media screen and (min-width: 680px) {html{font-size:664.0625%;}}\n@media screen and (min-width: 720px) {html{font-size:703.125%;}}\n@media screen and (min-width: 760px) {html{font-size:742.1875%;}}\n@media screen and (min-width: 800px) {html{font-size:781.25%;}}\n@media screen and (min-width: 960px) {html{font-size:937.5%;}}\n方案3\n\nvar designWidth = 640, rem2px = 100;\ndocument.documentElement.style.fontSize = \n  ((window.innerWidth / designWidth) * rem2px) + 'px';\n方案4\n\nvar designWidth = 640, rem2px = 100;\ndocument.documentElement.style.fontSize = \n  ((((window.innerWidth / designWidth) * rem2px) / 16) * 100) + '%';\n为了更避免理解上的混乱，我在上面js的代码中加了 ( ) ，实际代码中是不需要的。\n\n详细分析一下，rem 和 px 直接的转换公式可以写为：\n\n1rem = 1 * htmlFontSize\nhtmlFontSize 为 html 元素的字体大小。\n\n首先来看方案1中，在屏宽为640px情况下的设置：\n\n@media screen and (min-width: 640px) {html{font-size:100px;}}\n可以很明显的表现出这一点 1rem = 1 * 100px ，同我们最初的设定。那么我们要得到其它屏幕大小的 htmlFontSize 值要怎么办。很简单如方案3，因为我们的采用等比缩放的方式适配，所以计算目标屏幕宽度和设计稿的宽度的比即可：\n\nwindow.innerWidth / designWidth * rem2px + 'px'\n由于浏览器默认字体大小为 16px，所以当我们使用百分比作为根节点 html 的字体大小时，即html元素的font-size值设置为一个百分比值，rem 的计算方式就会改为：\n\ndefaultFontSize = 16px\n1rem = 1 * htmlFontSize * defaultFontSize\n如方案2中，在屏宽为640px情况下的设置：\n\n@media screen and (min-width: 640px) {html{font-size:625%;}}\n应用上面的公式：\n\n1rem = 1 * 625% * 16px\n其中：625% * 16 = 6.25 * 16 = 100\n所以：1rem = 1 * 100px\n同样的可以得到所有屏幕大小下，html 的 font-size 值的计算公式，即为方案4：\n\nwindow.innerWidth / designWidth * rem2px / 16 * 100  + '%'\n通过方案3和方案4的公式，就可以很方便的生成方案1和方案2中的css。\n\n这里只给出了方案3和方案4对应验证页面（方案1和方案2是它们的变形）: scheme3.html, scheme4.html\n\n如下面两张图，是在屏宽为360px下的效果，通过计算目标为：1rem = 56.25px。方案3设置值为：56.25px，方案4设置值为：351.5625%\n\n方案1\t方案2\n\t\n到目前为止貌似很完美的解决了问题，实际情况当然是出现了意外。在有些 Android 手机上，浏览器或 webview 的默认字体是随着系统设置的字体改变的。这样就会导致默认字体大于或小于 16px。\n\n修改默认字体大小后，我们再看方案3和方案4。\n\n同样在屏宽为360px下，我们调大系统字体大小，如下面的效果\n\n设置前 html 元素的字体大小的计算值为 18px ，设置后的计算值为 65px ，由于屏幕宽度没有改变，我们的目标值，即我们在 html 元素上设置的 font-size 值也没有变化任然为 56.25px，而最终计算值出现了偏差。\n\n方案3\t方案4\n\t\n分析偏差前，先来看在360px屏宽下，方案3和方案4的计算过程：\n\n方案3：\n\ndocument.documentElement.style.fontSize = 56.25px\nhtmlFontSize = 56.25px\n1rem = 1 * htmlFontSize = 56.25px\n实际为：\n1rem = 64.6875px\n方案4：\n\ndocument.documentElement.style.fontSize = 351.5625%\nhtmlFontSize = 351.5625%\ndefaultFontSize = 18px\n1rem = 1 * htmlFontSize * defaultFontSize = 351.5625% * 18px = 63.28125px\n351.5625% * 18 = 63.28125\n实际为：\n1rem = 64.6875px\n貌似方案4的计算结果很接近实际效果，而方案3偏差很大。再来比较方案3和方案4的计算公式：\n\n// 方案3\ndocument.documentElement.style.fontSize = \n  window.innerWidth / designWidth * rem2px + 'px';\n \n// 方案4\ndocument.documentElement.style.fontSize = \n  window.innerWidth / designWidth * rem2px / 16 * 100 + '%';\n方案4较于方案3其实多除了一个16，可以推测浏览器在计算 rem 的具体值时，如果 html 设置的 font-size 为 px 值时会先除以 16 ，然后再乘以 htmlFontSize。\n\n1rem = 1 * (56.25px / 16) * 18\n1 * (56.25 / 16) * 18 = 63.28125\n方案4存在问题，是因为系统的默认字体改为了 18px ，但是我们在计算百分比是时候，还是以 16px 为基准值进行计算，所以出现偏差（计算值和实际值之间还有一点偏差这个在后面会提到）。\n\n而在方案3中，我们其实是不考虑浏览器默认字体大小的，但在实际使用的过程中，浏览器还是除了 16 ，而此时默认字体大小为 18px。得出如下在 html 的 fontSize 设置为 px 的情况下 rem 的计算公式为：\n\n1rem = 1 * (htmlFontSize / 16) * defaultFontSize\n在系统设置的字体大小发生改变时，defaultFontSize 会跟着改变，而 16 不会变化。所以方案3虽然表面上不考虑默认字体大小的变化，只关注屏幕与设计稿之间的宽度比，但在实际计算中还是使用到了默认字体大小，而且还有一个不变的 16 在作祟，导致方案3失败。\n\n所谓的「root element」其实不是想象的那样，一个是16，一个是18，到底取的是那个 root element 的字体大小。\n\nok，rem 的计算的时候，px 的方式会有一个16不随系统字体大小改变，所以我们采用百分比的方案，绕开这个问题。\n\n采用百分比的方案4因为在计算时写死了默认字体大小 16px。所以它的偏差在于没能动态的获取默认字体大小。更新如下：\n\n方案4.1\n\nvar designWidth = 640, rem2px = 100;\nvar h = document.getElementsByTagName('html')[0];\nvar htmlFontSize = parseFloat(window.getComputedStyle(h, null)\n                                    .getPropertyValue('font-size'));\n \ndocument.documentElement.style.fontSize = \n  window.innerWidth / designWidth * rem2px / htmlFontSize * 100 + '%';\n效果如下图：\n\n16px 的图中，设置后的 html 的 font-size 与 1rem 的实际值有偏差，同时 6.4rem 的计算值也有偏差。通过查看代码发现html的font-size使用的是： getPropertyValue(‘font-size’) 而 1rem 使用的是 getPropertyValue(‘width’)，偏差出在计算 font-size 的时候浏览器进行了四舍五入。rem 定义中的另一个元素「font size」也不能按字面意思使用，宣告失守。\n\n18px 中的偏差，以及上文中方案4在 18px 实际值和计算值出现的偏差都是同样的问题。所以基准值还需要修改。\n\n方案5\t方案6\n\t\n在更新一版，方案4.2：\n\nvar designWidth = 640, rem2px = 100;\nvar d = window.document.createElement('div');\nd.style.width = '1rem';\nd.style.display = \"none\";\nvar head = window.document.getElementsByTagName('head')[0];\nhead.appendChild(d);\nvar defaultFontSize = parseFloat(window.getComputedStyle(d, null).getPropertyValue('width'));\n// d.remove();\ndocument.documentElement.style.fontSize = \n  window.innerWidth / designWidth * rem2px / defaultFontSize * 100 + '%';\n效果如下图：\n\n方案7\t方案8\n\t\n到此为止，rem 在默认字体不是 16px 的情况下的处理已经解决，考虑到还有设计屏幕旋转，最终手机端的解决方案为：\n\nfunction adapt(designWidth, rem2px){\n  var d = window.document.createElement('div');\n  d.style.width = '1rem';\n  d.style.display = \"none\";\n  var head = window.document.getElementsByTagName('head')[0];\n  head.appendChild(d);\n  var defaultFontSize = parseFloat(window.getComputedStyle(d, null).getPropertyValue('width'));\n  // d.remove();\n  // document.documentElement.style.fontSize = window.innerWidth / designWidth * rem2px / defaultFontSize * 100 + '%';\n  var st = document.createElement('style');\n  var portrait = \"@media screen and (min-width: \"+window.innerWidth+\"px) {html{font-size:\"+ ((window.innerWidth/(designWidth/rem2px)/defaultFontSize)*100) +\"%;}}\";\n  var landscape = \"@media screen and (min-width: \"+window.innerHeight+\"px) {html{font-size:\"+ ((window.innerHeight/(designWidth/rem2px)/defaultFontSize)*100) +\"%;}}\"\n  st.innerHTML = portrait + landscape;\n  head.appendChild(st);\n  return defaultFontSize\n};\nvar defaultFontSize = adapt(640, 100);\n回过头来再看 rem 的定义，『The font size of the root element.』。我们以为的 root element —— html 其实还有个影子在作祟，而我们以为的 font-size 其实是个近似值。\n\nby bx 2016.11.20\n\n评论中提到『高清适配』的问题，解决思路是设置单独的样式特殊处理：其中dpr大于1的时候，1px 的问题，『Retina屏的移动设备如何实现真正1px的线？』此文介绍的很详细，珠玉在前，就不献丑了。图片高清的可以用同样是思路，在不同dpr下加载不同分辨率的图片。\n\n此外rem还有一个问题就是对精灵图的适配，本人开发了一个命令行工具sprites-cli，用来处理这个问题（测试阶段，可能还不是太成熟）。\n\nby 2016.12.06\n\n思而不学则殆，优化了一下此方案前端：『REM』手机屏幕高清适配方案。\n\nby 2016.12.14","source":"_posts/mobile.md","raw":"---\ntitle: 了解真实的『REM』手机屏幕适配\ndate: 2018-01-28 17:58:49\ntags: rem,px\n---\nrem 作为一个低调的长度单位，由于手机端网页的兴起，在屏幕适配中得到重用。使用 rem 前端开发者可以很方便的在各种屏幕尺寸下，通过等比缩放的方式达到设计图要求的效果。\n\nrem 的官方定义『The font size of the root element.』，即以根节点的字体大小作为基准值进行长度计算。一般认为网页中的根节点是 html 元素，所以采用的方式也是通过设置 html 元素的 font-size 来做屏幕适配，但实际情况真有这么简单吗？\n\n首先我们来看看使用 rem 实现手机屏幕适配的常用方案。\n\n以设计稿的宽度为640px，即：designWidth = 640，同时设定在640px屏宽下 1rem=100px ，即：rem2px = 100。\n\n设置 1rem=100px 的优点不言而喻。前端开发者在切图、重构页面的时候，通过直接位移小数点的方式，就可以将UI图中测量到的 px 值换算成对应的 rem 值，方便快捷。\n\n此外，在 head 中我们还设置了：<meta name=”viewport” content=”width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0″ />\nviewport 的作用很重要，但不是本文的重点所以不展开，有兴趣的同学可以自行搜索。\n\n先来看看具体方案：\n\n下面四个方案来自同事共享，原理都是采用等比缩放的方式 —— 获得目标屏幕宽度和设计稿宽度的比，作为 rem 的基值（缩放系数），设置为html标签的字体大小。不同的只是在于性能取舍和书写习惯。\n\n方案1\n\n@media screen and (min-width: 320px) {html{font-size:50px;}}\n@media screen and (min-width: 360px) {html{font-size:56.25px;}}\n@media screen and (min-width: 375px) {html{font-size:58.59375px;}}\n@media screen and (min-width: 400px) {html{font-size:62.5px;}}\n@media screen and (min-width: 414px) {html{font-size:64.6875px;}}\n@media screen and (min-width: 440px) {html{font-size:68.75px;}}\n@media screen and (min-width: 480px) {html{font-size:75px;}}\n@media screen and (min-width: 520px) {html{font-size:81.25px;}}\n@media screen and (min-width: 560px) {html{font-size:87.5px;}}\n@media screen and (min-width: 600px) {html{font-size:93.75px;}}\n@media screen and (min-width: 640px) {html{font-size:100px;}}\n@media screen and (min-width: 680px) {html{font-size:106.25px;}}\n@media screen and (min-width: 720px) {html{font-size:112.5px;}}\n@media screen and (min-width: 760px) {html{font-size:118.75px;}}\n@media screen and (min-width: 800px) {html{font-size:125px;}}\n@media screen and (min-width: 960px) {html{font-size:150px;}}\n方案2\n\n@media screen and (min-width: 320px) {html{font-size:312.5%;}}\n@media screen and (min-width: 360px) {html{font-size:351.5625%;}}\n@media screen and (min-width: 375px) {html{font-size:366.211%;}}\n@media screen and (min-width: 400px) {html{font-size:390.625%;}}\n@media screen and (min-width: 414px) {html{font-size:404.2969%;}}\n@media screen and (min-width: 440px) {html{font-size:429.6875%;}}\n@media screen and (min-width: 480px) {html{font-size:468.75%;}}\n@media screen and (min-width: 520px) {html{font-size:507.8125%;}}\n@media screen and (min-width: 560px) {html{font-size:546.875%;}}\n@media screen and (min-width: 600px) {html{font-size:585.9375%;}}\n@media screen and (min-width: 640px) {html{font-size:625%;}}\n@media screen and (min-width: 680px) {html{font-size:664.0625%;}}\n@media screen and (min-width: 720px) {html{font-size:703.125%;}}\n@media screen and (min-width: 760px) {html{font-size:742.1875%;}}\n@media screen and (min-width: 800px) {html{font-size:781.25%;}}\n@media screen and (min-width: 960px) {html{font-size:937.5%;}}\n方案3\n\nvar designWidth = 640, rem2px = 100;\ndocument.documentElement.style.fontSize = \n  ((window.innerWidth / designWidth) * rem2px) + 'px';\n方案4\n\nvar designWidth = 640, rem2px = 100;\ndocument.documentElement.style.fontSize = \n  ((((window.innerWidth / designWidth) * rem2px) / 16) * 100) + '%';\n为了更避免理解上的混乱，我在上面js的代码中加了 ( ) ，实际代码中是不需要的。\n\n详细分析一下，rem 和 px 直接的转换公式可以写为：\n\n1rem = 1 * htmlFontSize\nhtmlFontSize 为 html 元素的字体大小。\n\n首先来看方案1中，在屏宽为640px情况下的设置：\n\n@media screen and (min-width: 640px) {html{font-size:100px;}}\n可以很明显的表现出这一点 1rem = 1 * 100px ，同我们最初的设定。那么我们要得到其它屏幕大小的 htmlFontSize 值要怎么办。很简单如方案3，因为我们的采用等比缩放的方式适配，所以计算目标屏幕宽度和设计稿的宽度的比即可：\n\nwindow.innerWidth / designWidth * rem2px + 'px'\n由于浏览器默认字体大小为 16px，所以当我们使用百分比作为根节点 html 的字体大小时，即html元素的font-size值设置为一个百分比值，rem 的计算方式就会改为：\n\ndefaultFontSize = 16px\n1rem = 1 * htmlFontSize * defaultFontSize\n如方案2中，在屏宽为640px情况下的设置：\n\n@media screen and (min-width: 640px) {html{font-size:625%;}}\n应用上面的公式：\n\n1rem = 1 * 625% * 16px\n其中：625% * 16 = 6.25 * 16 = 100\n所以：1rem = 1 * 100px\n同样的可以得到所有屏幕大小下，html 的 font-size 值的计算公式，即为方案4：\n\nwindow.innerWidth / designWidth * rem2px / 16 * 100  + '%'\n通过方案3和方案4的公式，就可以很方便的生成方案1和方案2中的css。\n\n这里只给出了方案3和方案4对应验证页面（方案1和方案2是它们的变形）: scheme3.html, scheme4.html\n\n如下面两张图，是在屏宽为360px下的效果，通过计算目标为：1rem = 56.25px。方案3设置值为：56.25px，方案4设置值为：351.5625%\n\n方案1\t方案2\n\t\n到目前为止貌似很完美的解决了问题，实际情况当然是出现了意外。在有些 Android 手机上，浏览器或 webview 的默认字体是随着系统设置的字体改变的。这样就会导致默认字体大于或小于 16px。\n\n修改默认字体大小后，我们再看方案3和方案4。\n\n同样在屏宽为360px下，我们调大系统字体大小，如下面的效果\n\n设置前 html 元素的字体大小的计算值为 18px ，设置后的计算值为 65px ，由于屏幕宽度没有改变，我们的目标值，即我们在 html 元素上设置的 font-size 值也没有变化任然为 56.25px，而最终计算值出现了偏差。\n\n方案3\t方案4\n\t\n分析偏差前，先来看在360px屏宽下，方案3和方案4的计算过程：\n\n方案3：\n\ndocument.documentElement.style.fontSize = 56.25px\nhtmlFontSize = 56.25px\n1rem = 1 * htmlFontSize = 56.25px\n实际为：\n1rem = 64.6875px\n方案4：\n\ndocument.documentElement.style.fontSize = 351.5625%\nhtmlFontSize = 351.5625%\ndefaultFontSize = 18px\n1rem = 1 * htmlFontSize * defaultFontSize = 351.5625% * 18px = 63.28125px\n351.5625% * 18 = 63.28125\n实际为：\n1rem = 64.6875px\n貌似方案4的计算结果很接近实际效果，而方案3偏差很大。再来比较方案3和方案4的计算公式：\n\n// 方案3\ndocument.documentElement.style.fontSize = \n  window.innerWidth / designWidth * rem2px + 'px';\n \n// 方案4\ndocument.documentElement.style.fontSize = \n  window.innerWidth / designWidth * rem2px / 16 * 100 + '%';\n方案4较于方案3其实多除了一个16，可以推测浏览器在计算 rem 的具体值时，如果 html 设置的 font-size 为 px 值时会先除以 16 ，然后再乘以 htmlFontSize。\n\n1rem = 1 * (56.25px / 16) * 18\n1 * (56.25 / 16) * 18 = 63.28125\n方案4存在问题，是因为系统的默认字体改为了 18px ，但是我们在计算百分比是时候，还是以 16px 为基准值进行计算，所以出现偏差（计算值和实际值之间还有一点偏差这个在后面会提到）。\n\n而在方案3中，我们其实是不考虑浏览器默认字体大小的，但在实际使用的过程中，浏览器还是除了 16 ，而此时默认字体大小为 18px。得出如下在 html 的 fontSize 设置为 px 的情况下 rem 的计算公式为：\n\n1rem = 1 * (htmlFontSize / 16) * defaultFontSize\n在系统设置的字体大小发生改变时，defaultFontSize 会跟着改变，而 16 不会变化。所以方案3虽然表面上不考虑默认字体大小的变化，只关注屏幕与设计稿之间的宽度比，但在实际计算中还是使用到了默认字体大小，而且还有一个不变的 16 在作祟，导致方案3失败。\n\n所谓的「root element」其实不是想象的那样，一个是16，一个是18，到底取的是那个 root element 的字体大小。\n\nok，rem 的计算的时候，px 的方式会有一个16不随系统字体大小改变，所以我们采用百分比的方案，绕开这个问题。\n\n采用百分比的方案4因为在计算时写死了默认字体大小 16px。所以它的偏差在于没能动态的获取默认字体大小。更新如下：\n\n方案4.1\n\nvar designWidth = 640, rem2px = 100;\nvar h = document.getElementsByTagName('html')[0];\nvar htmlFontSize = parseFloat(window.getComputedStyle(h, null)\n                                    .getPropertyValue('font-size'));\n \ndocument.documentElement.style.fontSize = \n  window.innerWidth / designWidth * rem2px / htmlFontSize * 100 + '%';\n效果如下图：\n\n16px 的图中，设置后的 html 的 font-size 与 1rem 的实际值有偏差，同时 6.4rem 的计算值也有偏差。通过查看代码发现html的font-size使用的是： getPropertyValue(‘font-size’) 而 1rem 使用的是 getPropertyValue(‘width’)，偏差出在计算 font-size 的时候浏览器进行了四舍五入。rem 定义中的另一个元素「font size」也不能按字面意思使用，宣告失守。\n\n18px 中的偏差，以及上文中方案4在 18px 实际值和计算值出现的偏差都是同样的问题。所以基准值还需要修改。\n\n方案5\t方案6\n\t\n在更新一版，方案4.2：\n\nvar designWidth = 640, rem2px = 100;\nvar d = window.document.createElement('div');\nd.style.width = '1rem';\nd.style.display = \"none\";\nvar head = window.document.getElementsByTagName('head')[0];\nhead.appendChild(d);\nvar defaultFontSize = parseFloat(window.getComputedStyle(d, null).getPropertyValue('width'));\n// d.remove();\ndocument.documentElement.style.fontSize = \n  window.innerWidth / designWidth * rem2px / defaultFontSize * 100 + '%';\n效果如下图：\n\n方案7\t方案8\n\t\n到此为止，rem 在默认字体不是 16px 的情况下的处理已经解决，考虑到还有设计屏幕旋转，最终手机端的解决方案为：\n\nfunction adapt(designWidth, rem2px){\n  var d = window.document.createElement('div');\n  d.style.width = '1rem';\n  d.style.display = \"none\";\n  var head = window.document.getElementsByTagName('head')[0];\n  head.appendChild(d);\n  var defaultFontSize = parseFloat(window.getComputedStyle(d, null).getPropertyValue('width'));\n  // d.remove();\n  // document.documentElement.style.fontSize = window.innerWidth / designWidth * rem2px / defaultFontSize * 100 + '%';\n  var st = document.createElement('style');\n  var portrait = \"@media screen and (min-width: \"+window.innerWidth+\"px) {html{font-size:\"+ ((window.innerWidth/(designWidth/rem2px)/defaultFontSize)*100) +\"%;}}\";\n  var landscape = \"@media screen and (min-width: \"+window.innerHeight+\"px) {html{font-size:\"+ ((window.innerHeight/(designWidth/rem2px)/defaultFontSize)*100) +\"%;}}\"\n  st.innerHTML = portrait + landscape;\n  head.appendChild(st);\n  return defaultFontSize\n};\nvar defaultFontSize = adapt(640, 100);\n回过头来再看 rem 的定义，『The font size of the root element.』。我们以为的 root element —— html 其实还有个影子在作祟，而我们以为的 font-size 其实是个近似值。\n\nby bx 2016.11.20\n\n评论中提到『高清适配』的问题，解决思路是设置单独的样式特殊处理：其中dpr大于1的时候，1px 的问题，『Retina屏的移动设备如何实现真正1px的线？』此文介绍的很详细，珠玉在前，就不献丑了。图片高清的可以用同样是思路，在不同dpr下加载不同分辨率的图片。\n\n此外rem还有一个问题就是对精灵图的适配，本人开发了一个命令行工具sprites-cli，用来处理这个问题（测试阶段，可能还不是太成熟）。\n\nby 2016.12.06\n\n思而不学则殆，优化了一下此方案前端：『REM』手机屏幕高清适配方案。\n\nby 2016.12.14","slug":"mobile","published":1,"updated":"2018-01-28T09:59:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcymfvsj0006s2gsa15008mo","content":"<p>rem 作为一个低调的长度单位，由于手机端网页的兴起，在屏幕适配中得到重用。使用 rem 前端开发者可以很方便的在各种屏幕尺寸下，通过等比缩放的方式达到设计图要求的效果。</p>\n<p>rem 的官方定义『The font size of the root element.』，即以根节点的字体大小作为基准值进行长度计算。一般认为网页中的根节点是 html 元素，所以采用的方式也是通过设置 html 元素的 font-size 来做屏幕适配，但实际情况真有这么简单吗？</p>\n<p>首先我们来看看使用 rem 实现手机屏幕适配的常用方案。</p>\n<p>以设计稿的宽度为640px，即：designWidth = 640，同时设定在640px屏宽下 1rem=100px ，即：rem2px = 100。</p>\n<p>设置 1rem=100px 的优点不言而喻。前端开发者在切图、重构页面的时候，通过直接位移小数点的方式，就可以将UI图中测量到的 px 值换算成对应的 rem 值，方便快捷。</p>\n<p>此外，在 head 中我们还设置了：<meta name=\"”viewport”\" content=\"”width=device-width,\" initial-scale=\"1.0,\" minimum-scale=\"1.0,\" maximum-scale=\"1.0″\"><br>viewport 的作用很重要，但不是本文的重点所以不展开，有兴趣的同学可以自行搜索。</p>\n<p>先来看看具体方案：</p>\n<p>下面四个方案来自同事共享，原理都是采用等比缩放的方式 —— 获得目标屏幕宽度和设计稿宽度的比，作为 rem 的基值（缩放系数），设置为html标签的字体大小。不同的只是在于性能取舍和书写习惯。</p>\n<p>方案1</p>\n<p>@media screen and (min-width: 320px) {html{font-size:50px;}}<br>@media screen and (min-width: 360px) {html{font-size:56.25px;}}<br>@media screen and (min-width: 375px) {html{font-size:58.59375px;}}<br>@media screen and (min-width: 400px) {html{font-size:62.5px;}}<br>@media screen and (min-width: 414px) {html{font-size:64.6875px;}}<br>@media screen and (min-width: 440px) {html{font-size:68.75px;}}<br>@media screen and (min-width: 480px) {html{font-size:75px;}}<br>@media screen and (min-width: 520px) {html{font-size:81.25px;}}<br>@media screen and (min-width: 560px) {html{font-size:87.5px;}}<br>@media screen and (min-width: 600px) {html{font-size:93.75px;}}<br>@media screen and (min-width: 640px) {html{font-size:100px;}}<br>@media screen and (min-width: 680px) {html{font-size:106.25px;}}<br>@media screen and (min-width: 720px) {html{font-size:112.5px;}}<br>@media screen and (min-width: 760px) {html{font-size:118.75px;}}<br>@media screen and (min-width: 800px) {html{font-size:125px;}}<br>@media screen and (min-width: 960px) {html{font-size:150px;}}<br>方案2</p>\n<p>@media screen and (min-width: 320px) {html{font-size:312.5%;}}<br>@media screen and (min-width: 360px) {html{font-size:351.5625%;}}<br>@media screen and (min-width: 375px) {html{font-size:366.211%;}}<br>@media screen and (min-width: 400px) {html{font-size:390.625%;}}<br>@media screen and (min-width: 414px) {html{font-size:404.2969%;}}<br>@media screen and (min-width: 440px) {html{font-size:429.6875%;}}<br>@media screen and (min-width: 480px) {html{font-size:468.75%;}}<br>@media screen and (min-width: 520px) {html{font-size:507.8125%;}}<br>@media screen and (min-width: 560px) {html{font-size:546.875%;}}<br>@media screen and (min-width: 600px) {html{font-size:585.9375%;}}<br>@media screen and (min-width: 640px) {html{font-size:625%;}}<br>@media screen and (min-width: 680px) {html{font-size:664.0625%;}}<br>@media screen and (min-width: 720px) {html{font-size:703.125%;}}<br>@media screen and (min-width: 760px) {html{font-size:742.1875%;}}<br>@media screen and (min-width: 800px) {html{font-size:781.25%;}}<br>@media screen and (min-width: 960px) {html{font-size:937.5%;}}<br>方案3</p>\n<p>var designWidth = 640, rem2px = 100;<br>document.documentElement.style.fontSize =<br>  ((window.innerWidth / designWidth) * rem2px) + ‘px’;<br>方案4</p>\n<p>var designWidth = 640, rem2px = 100;<br>document.documentElement.style.fontSize =<br>  ((((window.innerWidth / designWidth) <em> rem2px) / 16) </em> 100) + ‘%’;<br>为了更避免理解上的混乱，我在上面js的代码中加了 ( ) ，实际代码中是不需要的。</p>\n<p>详细分析一下，rem 和 px 直接的转换公式可以写为：</p>\n<p>1rem = 1 * htmlFontSize<br>htmlFontSize 为 html 元素的字体大小。</p>\n<p>首先来看方案1中，在屏宽为640px情况下的设置：</p>\n<p>@media screen and (min-width: 640px) {html{font-size:100px;}}<br>可以很明显的表现出这一点 1rem = 1 * 100px ，同我们最初的设定。那么我们要得到其它屏幕大小的 htmlFontSize 值要怎么办。很简单如方案3，因为我们的采用等比缩放的方式适配，所以计算目标屏幕宽度和设计稿的宽度的比即可：</p>\n<p>window.innerWidth / designWidth * rem2px + ‘px’<br>由于浏览器默认字体大小为 16px，所以当我们使用百分比作为根节点 html 的字体大小时，即html元素的font-size值设置为一个百分比值，rem 的计算方式就会改为：</p>\n<p>defaultFontSize = 16px<br>1rem = 1 <em> htmlFontSize </em> defaultFontSize<br>如方案2中，在屏宽为640px情况下的设置：</p>\n<p>@media screen and (min-width: 640px) {html{font-size:625%;}}<br>应用上面的公式：</p>\n<p>1rem = 1 <em> 625% </em> 16px<br>其中：625% <em> 16 = 6.25 </em> 16 = 100<br>所以：1rem = 1 * 100px<br>同样的可以得到所有屏幕大小下，html 的 font-size 值的计算公式，即为方案4：</p>\n<p>window.innerWidth / designWidth <em> rem2px / 16 </em> 100  + ‘%’<br>通过方案3和方案4的公式，就可以很方便的生成方案1和方案2中的css。</p>\n<p>这里只给出了方案3和方案4对应验证页面（方案1和方案2是它们的变形）: scheme3.html, scheme4.html</p>\n<p>如下面两张图，是在屏宽为360px下的效果，通过计算目标为：1rem = 56.25px。方案3设置值为：56.25px，方案4设置值为：351.5625%</p>\n<p>方案1    方案2</p>\n<p>到目前为止貌似很完美的解决了问题，实际情况当然是出现了意外。在有些 Android 手机上，浏览器或 webview 的默认字体是随着系统设置的字体改变的。这样就会导致默认字体大于或小于 16px。</p>\n<p>修改默认字体大小后，我们再看方案3和方案4。</p>\n<p>同样在屏宽为360px下，我们调大系统字体大小，如下面的效果</p>\n<p>设置前 html 元素的字体大小的计算值为 18px ，设置后的计算值为 65px ，由于屏幕宽度没有改变，我们的目标值，即我们在 html 元素上设置的 font-size 值也没有变化任然为 56.25px，而最终计算值出现了偏差。</p>\n<p>方案3    方案4</p>\n<p>分析偏差前，先来看在360px屏宽下，方案3和方案4的计算过程：</p>\n<p>方案3：</p>\n<p>document.documentElement.style.fontSize = 56.25px<br>htmlFontSize = 56.25px<br>1rem = 1 * htmlFontSize = 56.25px<br>实际为：<br>1rem = 64.6875px<br>方案4：</p>\n<p>document.documentElement.style.fontSize = 351.5625%<br>htmlFontSize = 351.5625%<br>defaultFontSize = 18px<br>1rem = 1 <em> htmlFontSize </em> defaultFontSize = 351.5625% <em> 18px = 63.28125px<br>351.5625% </em> 18 = 63.28125<br>实际为：<br>1rem = 64.6875px<br>貌似方案4的计算结果很接近实际效果，而方案3偏差很大。再来比较方案3和方案4的计算公式：</p>\n<p>// 方案3<br>document.documentElement.style.fontSize =<br>  window.innerWidth / designWidth * rem2px + ‘px’;</p>\n<p>// 方案4<br>document.documentElement.style.fontSize =<br>  window.innerWidth / designWidth <em> rem2px / 16 </em> 100 + ‘%’;<br>方案4较于方案3其实多除了一个16，可以推测浏览器在计算 rem 的具体值时，如果 html 设置的 font-size 为 px 值时会先除以 16 ，然后再乘以 htmlFontSize。</p>\n<p>1rem = 1 <em> (56.25px / 16) </em> 18<br>1 <em> (56.25 / 16) </em> 18 = 63.28125<br>方案4存在问题，是因为系统的默认字体改为了 18px ，但是我们在计算百分比是时候，还是以 16px 为基准值进行计算，所以出现偏差（计算值和实际值之间还有一点偏差这个在后面会提到）。</p>\n<p>而在方案3中，我们其实是不考虑浏览器默认字体大小的，但在实际使用的过程中，浏览器还是除了 16 ，而此时默认字体大小为 18px。得出如下在 html 的 fontSize 设置为 px 的情况下 rem 的计算公式为：</p>\n<p>1rem = 1 <em> (htmlFontSize / 16) </em> defaultFontSize<br>在系统设置的字体大小发生改变时，defaultFontSize 会跟着改变，而 16 不会变化。所以方案3虽然表面上不考虑默认字体大小的变化，只关注屏幕与设计稿之间的宽度比，但在实际计算中还是使用到了默认字体大小，而且还有一个不变的 16 在作祟，导致方案3失败。</p>\n<p>所谓的「root element」其实不是想象的那样，一个是16，一个是18，到底取的是那个 root element 的字体大小。</p>\n<p>ok，rem 的计算的时候，px 的方式会有一个16不随系统字体大小改变，所以我们采用百分比的方案，绕开这个问题。</p>\n<p>采用百分比的方案4因为在计算时写死了默认字体大小 16px。所以它的偏差在于没能动态的获取默认字体大小。更新如下：</p>\n<p>方案4.1</p>\n<p>var designWidth = 640, rem2px = 100;<br>var h = document.getElementsByTagName(‘html’)[0];<br>var htmlFontSize = parseFloat(window.getComputedStyle(h, null)<br>                                    .getPropertyValue(‘font-size’));</p>\n<p>document.documentElement.style.fontSize =<br>  window.innerWidth / designWidth <em> rem2px / htmlFontSize </em> 100 + ‘%’;<br>效果如下图：</p>\n<p>16px 的图中，设置后的 html 的 font-size 与 1rem 的实际值有偏差，同时 6.4rem 的计算值也有偏差。通过查看代码发现html的font-size使用的是： getPropertyValue(‘font-size’) 而 1rem 使用的是 getPropertyValue(‘width’)，偏差出在计算 font-size 的时候浏览器进行了四舍五入。rem 定义中的另一个元素「font size」也不能按字面意思使用，宣告失守。</p>\n<p>18px 中的偏差，以及上文中方案4在 18px 实际值和计算值出现的偏差都是同样的问题。所以基准值还需要修改。</p>\n<p>方案5    方案6</p>\n<p>在更新一版，方案4.2：</p>\n<p>var designWidth = 640, rem2px = 100;<br>var d = window.document.createElement(‘div’);<br>d.style.width = ‘1rem’;<br>d.style.display = “none”;<br>var head = window.document.getElementsByTagName(‘head’)[0];<br>head.appendChild(d);<br>var defaultFontSize = parseFloat(window.getComputedStyle(d, null).getPropertyValue(‘width’));<br>// d.remove();<br>document.documentElement.style.fontSize =<br>  window.innerWidth / designWidth <em> rem2px / defaultFontSize </em> 100 + ‘%’;<br>效果如下图：</p>\n<p>方案7    方案8</p>\n<p>到此为止，rem 在默认字体不是 16px 的情况下的处理已经解决，考虑到还有设计屏幕旋转，最终手机端的解决方案为：</p>\n<p>function adapt(designWidth, rem2px){<br>  var d = window.document.createElement(‘div’);<br>  d.style.width = ‘1rem’;<br>  d.style.display = “none”;<br>  var head = window.document.getElementsByTagName(‘head’)[0];<br>  head.appendChild(d);<br>  var defaultFontSize = parseFloat(window.getComputedStyle(d, null).getPropertyValue(‘width’));<br>  // d.remove();<br>  // document.documentElement.style.fontSize = window.innerWidth / designWidth <em> rem2px / defaultFontSize </em> 100 + ‘%’;<br>  var st = document.createElement(‘style’);<br>  var portrait = “@media screen and (min-width: “+window.innerWidth+”px) {html{font-size:”+ ((window.innerWidth/(designWidth/rem2px)/defaultFontSize)<em>100) +”%;}}”;<br>  var landscape = “@media screen and (min-width: “+window.innerHeight+”px) {html{font-size:”+ ((window.innerHeight/(designWidth/rem2px)/defaultFontSize)</em>100) +”%;}}”<br>  st.innerHTML = portrait + landscape;<br>  head.appendChild(st);<br>  return defaultFontSize<br>};<br>var defaultFontSize = adapt(640, 100);<br>回过头来再看 rem 的定义，『The font size of the root element.』。我们以为的 root element —— html 其实还有个影子在作祟，而我们以为的 font-size 其实是个近似值。</p>\n<p>by bx 2016.11.20</p>\n<p>评论中提到『高清适配』的问题，解决思路是设置单独的样式特殊处理：其中dpr大于1的时候，1px 的问题，『Retina屏的移动设备如何实现真正1px的线？』此文介绍的很详细，珠玉在前，就不献丑了。图片高清的可以用同样是思路，在不同dpr下加载不同分辨率的图片。</p>\n<p>此外rem还有一个问题就是对精灵图的适配，本人开发了一个命令行工具sprites-cli，用来处理这个问题（测试阶段，可能还不是太成熟）。</p>\n<p>by 2016.12.06</p>\n<p>思而不学则殆，优化了一下此方案前端：『REM』手机屏幕高清适配方案。</p>\n<p>by 2016.12.14</p>\n","site":{"data":{}},"excerpt":"","more":"<p>rem 作为一个低调的长度单位，由于手机端网页的兴起，在屏幕适配中得到重用。使用 rem 前端开发者可以很方便的在各种屏幕尺寸下，通过等比缩放的方式达到设计图要求的效果。</p>\n<p>rem 的官方定义『The font size of the root element.』，即以根节点的字体大小作为基准值进行长度计算。一般认为网页中的根节点是 html 元素，所以采用的方式也是通过设置 html 元素的 font-size 来做屏幕适配，但实际情况真有这么简单吗？</p>\n<p>首先我们来看看使用 rem 实现手机屏幕适配的常用方案。</p>\n<p>以设计稿的宽度为640px，即：designWidth = 640，同时设定在640px屏宽下 1rem=100px ，即：rem2px = 100。</p>\n<p>设置 1rem=100px 的优点不言而喻。前端开发者在切图、重构页面的时候，通过直接位移小数点的方式，就可以将UI图中测量到的 px 值换算成对应的 rem 值，方便快捷。</p>\n<p>此外，在 head 中我们还设置了：<meta name=\"”viewport”\" content=\"”width=device-width,\" initial-scale=\"1.0,\" minimum-scale=\"1.0,\" maximum-scale=\"1.0″\"><br>viewport 的作用很重要，但不是本文的重点所以不展开，有兴趣的同学可以自行搜索。</p>\n<p>先来看看具体方案：</p>\n<p>下面四个方案来自同事共享，原理都是采用等比缩放的方式 —— 获得目标屏幕宽度和设计稿宽度的比，作为 rem 的基值（缩放系数），设置为html标签的字体大小。不同的只是在于性能取舍和书写习惯。</p>\n<p>方案1</p>\n<p>@media screen and (min-width: 320px) {html{font-size:50px;}}<br>@media screen and (min-width: 360px) {html{font-size:56.25px;}}<br>@media screen and (min-width: 375px) {html{font-size:58.59375px;}}<br>@media screen and (min-width: 400px) {html{font-size:62.5px;}}<br>@media screen and (min-width: 414px) {html{font-size:64.6875px;}}<br>@media screen and (min-width: 440px) {html{font-size:68.75px;}}<br>@media screen and (min-width: 480px) {html{font-size:75px;}}<br>@media screen and (min-width: 520px) {html{font-size:81.25px;}}<br>@media screen and (min-width: 560px) {html{font-size:87.5px;}}<br>@media screen and (min-width: 600px) {html{font-size:93.75px;}}<br>@media screen and (min-width: 640px) {html{font-size:100px;}}<br>@media screen and (min-width: 680px) {html{font-size:106.25px;}}<br>@media screen and (min-width: 720px) {html{font-size:112.5px;}}<br>@media screen and (min-width: 760px) {html{font-size:118.75px;}}<br>@media screen and (min-width: 800px) {html{font-size:125px;}}<br>@media screen and (min-width: 960px) {html{font-size:150px;}}<br>方案2</p>\n<p>@media screen and (min-width: 320px) {html{font-size:312.5%;}}<br>@media screen and (min-width: 360px) {html{font-size:351.5625%;}}<br>@media screen and (min-width: 375px) {html{font-size:366.211%;}}<br>@media screen and (min-width: 400px) {html{font-size:390.625%;}}<br>@media screen and (min-width: 414px) {html{font-size:404.2969%;}}<br>@media screen and (min-width: 440px) {html{font-size:429.6875%;}}<br>@media screen and (min-width: 480px) {html{font-size:468.75%;}}<br>@media screen and (min-width: 520px) {html{font-size:507.8125%;}}<br>@media screen and (min-width: 560px) {html{font-size:546.875%;}}<br>@media screen and (min-width: 600px) {html{font-size:585.9375%;}}<br>@media screen and (min-width: 640px) {html{font-size:625%;}}<br>@media screen and (min-width: 680px) {html{font-size:664.0625%;}}<br>@media screen and (min-width: 720px) {html{font-size:703.125%;}}<br>@media screen and (min-width: 760px) {html{font-size:742.1875%;}}<br>@media screen and (min-width: 800px) {html{font-size:781.25%;}}<br>@media screen and (min-width: 960px) {html{font-size:937.5%;}}<br>方案3</p>\n<p>var designWidth = 640, rem2px = 100;<br>document.documentElement.style.fontSize =<br>  ((window.innerWidth / designWidth) * rem2px) + ‘px’;<br>方案4</p>\n<p>var designWidth = 640, rem2px = 100;<br>document.documentElement.style.fontSize =<br>  ((((window.innerWidth / designWidth) <em> rem2px) / 16) </em> 100) + ‘%’;<br>为了更避免理解上的混乱，我在上面js的代码中加了 ( ) ，实际代码中是不需要的。</p>\n<p>详细分析一下，rem 和 px 直接的转换公式可以写为：</p>\n<p>1rem = 1 * htmlFontSize<br>htmlFontSize 为 html 元素的字体大小。</p>\n<p>首先来看方案1中，在屏宽为640px情况下的设置：</p>\n<p>@media screen and (min-width: 640px) {html{font-size:100px;}}<br>可以很明显的表现出这一点 1rem = 1 * 100px ，同我们最初的设定。那么我们要得到其它屏幕大小的 htmlFontSize 值要怎么办。很简单如方案3，因为我们的采用等比缩放的方式适配，所以计算目标屏幕宽度和设计稿的宽度的比即可：</p>\n<p>window.innerWidth / designWidth * rem2px + ‘px’<br>由于浏览器默认字体大小为 16px，所以当我们使用百分比作为根节点 html 的字体大小时，即html元素的font-size值设置为一个百分比值，rem 的计算方式就会改为：</p>\n<p>defaultFontSize = 16px<br>1rem = 1 <em> htmlFontSize </em> defaultFontSize<br>如方案2中，在屏宽为640px情况下的设置：</p>\n<p>@media screen and (min-width: 640px) {html{font-size:625%;}}<br>应用上面的公式：</p>\n<p>1rem = 1 <em> 625% </em> 16px<br>其中：625% <em> 16 = 6.25 </em> 16 = 100<br>所以：1rem = 1 * 100px<br>同样的可以得到所有屏幕大小下，html 的 font-size 值的计算公式，即为方案4：</p>\n<p>window.innerWidth / designWidth <em> rem2px / 16 </em> 100  + ‘%’<br>通过方案3和方案4的公式，就可以很方便的生成方案1和方案2中的css。</p>\n<p>这里只给出了方案3和方案4对应验证页面（方案1和方案2是它们的变形）: scheme3.html, scheme4.html</p>\n<p>如下面两张图，是在屏宽为360px下的效果，通过计算目标为：1rem = 56.25px。方案3设置值为：56.25px，方案4设置值为：351.5625%</p>\n<p>方案1    方案2</p>\n<p>到目前为止貌似很完美的解决了问题，实际情况当然是出现了意外。在有些 Android 手机上，浏览器或 webview 的默认字体是随着系统设置的字体改变的。这样就会导致默认字体大于或小于 16px。</p>\n<p>修改默认字体大小后，我们再看方案3和方案4。</p>\n<p>同样在屏宽为360px下，我们调大系统字体大小，如下面的效果</p>\n<p>设置前 html 元素的字体大小的计算值为 18px ，设置后的计算值为 65px ，由于屏幕宽度没有改变，我们的目标值，即我们在 html 元素上设置的 font-size 值也没有变化任然为 56.25px，而最终计算值出现了偏差。</p>\n<p>方案3    方案4</p>\n<p>分析偏差前，先来看在360px屏宽下，方案3和方案4的计算过程：</p>\n<p>方案3：</p>\n<p>document.documentElement.style.fontSize = 56.25px<br>htmlFontSize = 56.25px<br>1rem = 1 * htmlFontSize = 56.25px<br>实际为：<br>1rem = 64.6875px<br>方案4：</p>\n<p>document.documentElement.style.fontSize = 351.5625%<br>htmlFontSize = 351.5625%<br>defaultFontSize = 18px<br>1rem = 1 <em> htmlFontSize </em> defaultFontSize = 351.5625% <em> 18px = 63.28125px<br>351.5625% </em> 18 = 63.28125<br>实际为：<br>1rem = 64.6875px<br>貌似方案4的计算结果很接近实际效果，而方案3偏差很大。再来比较方案3和方案4的计算公式：</p>\n<p>// 方案3<br>document.documentElement.style.fontSize =<br>  window.innerWidth / designWidth * rem2px + ‘px’;</p>\n<p>// 方案4<br>document.documentElement.style.fontSize =<br>  window.innerWidth / designWidth <em> rem2px / 16 </em> 100 + ‘%’;<br>方案4较于方案3其实多除了一个16，可以推测浏览器在计算 rem 的具体值时，如果 html 设置的 font-size 为 px 值时会先除以 16 ，然后再乘以 htmlFontSize。</p>\n<p>1rem = 1 <em> (56.25px / 16) </em> 18<br>1 <em> (56.25 / 16) </em> 18 = 63.28125<br>方案4存在问题，是因为系统的默认字体改为了 18px ，但是我们在计算百分比是时候，还是以 16px 为基准值进行计算，所以出现偏差（计算值和实际值之间还有一点偏差这个在后面会提到）。</p>\n<p>而在方案3中，我们其实是不考虑浏览器默认字体大小的，但在实际使用的过程中，浏览器还是除了 16 ，而此时默认字体大小为 18px。得出如下在 html 的 fontSize 设置为 px 的情况下 rem 的计算公式为：</p>\n<p>1rem = 1 <em> (htmlFontSize / 16) </em> defaultFontSize<br>在系统设置的字体大小发生改变时，defaultFontSize 会跟着改变，而 16 不会变化。所以方案3虽然表面上不考虑默认字体大小的变化，只关注屏幕与设计稿之间的宽度比，但在实际计算中还是使用到了默认字体大小，而且还有一个不变的 16 在作祟，导致方案3失败。</p>\n<p>所谓的「root element」其实不是想象的那样，一个是16，一个是18，到底取的是那个 root element 的字体大小。</p>\n<p>ok，rem 的计算的时候，px 的方式会有一个16不随系统字体大小改变，所以我们采用百分比的方案，绕开这个问题。</p>\n<p>采用百分比的方案4因为在计算时写死了默认字体大小 16px。所以它的偏差在于没能动态的获取默认字体大小。更新如下：</p>\n<p>方案4.1</p>\n<p>var designWidth = 640, rem2px = 100;<br>var h = document.getElementsByTagName(‘html’)[0];<br>var htmlFontSize = parseFloat(window.getComputedStyle(h, null)<br>                                    .getPropertyValue(‘font-size’));</p>\n<p>document.documentElement.style.fontSize =<br>  window.innerWidth / designWidth <em> rem2px / htmlFontSize </em> 100 + ‘%’;<br>效果如下图：</p>\n<p>16px 的图中，设置后的 html 的 font-size 与 1rem 的实际值有偏差，同时 6.4rem 的计算值也有偏差。通过查看代码发现html的font-size使用的是： getPropertyValue(‘font-size’) 而 1rem 使用的是 getPropertyValue(‘width’)，偏差出在计算 font-size 的时候浏览器进行了四舍五入。rem 定义中的另一个元素「font size」也不能按字面意思使用，宣告失守。</p>\n<p>18px 中的偏差，以及上文中方案4在 18px 实际值和计算值出现的偏差都是同样的问题。所以基准值还需要修改。</p>\n<p>方案5    方案6</p>\n<p>在更新一版，方案4.2：</p>\n<p>var designWidth = 640, rem2px = 100;<br>var d = window.document.createElement(‘div’);<br>d.style.width = ‘1rem’;<br>d.style.display = “none”;<br>var head = window.document.getElementsByTagName(‘head’)[0];<br>head.appendChild(d);<br>var defaultFontSize = parseFloat(window.getComputedStyle(d, null).getPropertyValue(‘width’));<br>// d.remove();<br>document.documentElement.style.fontSize =<br>  window.innerWidth / designWidth <em> rem2px / defaultFontSize </em> 100 + ‘%’;<br>效果如下图：</p>\n<p>方案7    方案8</p>\n<p>到此为止，rem 在默认字体不是 16px 的情况下的处理已经解决，考虑到还有设计屏幕旋转，最终手机端的解决方案为：</p>\n<p>function adapt(designWidth, rem2px){<br>  var d = window.document.createElement(‘div’);<br>  d.style.width = ‘1rem’;<br>  d.style.display = “none”;<br>  var head = window.document.getElementsByTagName(‘head’)[0];<br>  head.appendChild(d);<br>  var defaultFontSize = parseFloat(window.getComputedStyle(d, null).getPropertyValue(‘width’));<br>  // d.remove();<br>  // document.documentElement.style.fontSize = window.innerWidth / designWidth <em> rem2px / defaultFontSize </em> 100 + ‘%’;<br>  var st = document.createElement(‘style’);<br>  var portrait = “@media screen and (min-width: “+window.innerWidth+”px) {html{font-size:”+ ((window.innerWidth/(designWidth/rem2px)/defaultFontSize)<em>100) +”%;}}”;<br>  var landscape = “@media screen and (min-width: “+window.innerHeight+”px) {html{font-size:”+ ((window.innerHeight/(designWidth/rem2px)/defaultFontSize)</em>100) +”%;}}”<br>  st.innerHTML = portrait + landscape;<br>  head.appendChild(st);<br>  return defaultFontSize<br>};<br>var defaultFontSize = adapt(640, 100);<br>回过头来再看 rem 的定义，『The font size of the root element.』。我们以为的 root element —— html 其实还有个影子在作祟，而我们以为的 font-size 其实是个近似值。</p>\n<p>by bx 2016.11.20</p>\n<p>评论中提到『高清适配』的问题，解决思路是设置单独的样式特殊处理：其中dpr大于1的时候，1px 的问题，『Retina屏的移动设备如何实现真正1px的线？』此文介绍的很详细，珠玉在前，就不献丑了。图片高清的可以用同样是思路，在不同dpr下加载不同分辨率的图片。</p>\n<p>此外rem还有一个问题就是对精灵图的适配，本人开发了一个命令行工具sprites-cli，用来处理这个问题（测试阶段，可能还不是太成熟）。</p>\n<p>by 2016.12.06</p>\n<p>思而不学则殆，优化了一下此方案前端：『REM』手机屏幕高清适配方案。</p>\n<p>by 2016.12.14</p>\n"},{"title":"数组操作第二部分","date":"2018-01-28T09:23:04.000Z","_content":"数组\narrayMax\n返回数组中的最大值。\n\n将Math.max()与扩展运算符 (…) 结合使用以获取数组中的最大值。\n\nconst arrayMax = arr => Math.max(...arr);\n// arrayMax([10, 1, 5]) -> 10\narrayMin\n返回数组中的最小值。\n\n将Math.min()与扩展运算符 (…) 结合使用以获取数组中的最小值。\n\nconst arrayMin = arr => Math.min(...arr);\n// arrayMin([10, 1, 5]) -> 1\nchunk\n将数组块划分为指定大小的较小数组。\n\n使用Array.from()创建新的数组, 这符合将生成的区块数。使用Array.slice()将新数组的每个元素映射到size长度的区块。如果原始数组不能均匀拆分, 则最终的块将包含剩余的元素。\n\nconst chunk = (arr, size) =>\nArray.from({length: Math.ceil(arr.length / size)}, (v, i) => arr.slice(i * size, i * size + size));\n// chunk([1,2,3,4,5], 2) -> [[1,2],[3,4],[5]]\ncompact\n从数组中移除 falsey 值。\n\n使用Array.filter()筛选出 falsey 值 (false、null、0、””、undefined和NaN).\n\nconst compact = (arr) => arr.filter(Boolean);\n// compact([0, 1, false, 2, '', 3, 'a', 'e'*23, NaN, 's', 34]) -> [ 1, 2, 3, 'a', 's', 34 ]\ncountOccurrences\n计算数组中值的出现次数。\n\n使用Array.reduce()在每次遇到数组中的特定值时递增计数器。\n\nconst countOccurrences = (arr, value) => arr.reduce((a, v) => v === value ? a + 1 : a + 0, 0);\n// countOccurrences([1,1,2,1,2,3], 1) -> 3\ndeepFlatten\n深拼合数组。\n\n使用递归。使用Array.concat()与空数组 ([]) 和跨页运算符 (…) 来拼合数组。递归拼合作为数组的每个元素。\n\nconst deepFlatten = arr => [].concat(...arr.map(v => Array.isArray(v) ? deepFlatten(v) : v));\n// deepFlatten([1,[2],[[3],4],5]) -> [1,2,3,4,5]\ndifference\n返回两个数组之间的差异。\n\n从b创建Set, 然后使用Array.filter() on 只保留a b中不包含的值.\n\nconst difference = (a, b) => { const s = new Set(b); return a.filter(x => !s.has(x)); };\n// difference([1,2,3], [1,2,4]) -> [3]\ndistinctValuesOfArray\n返回数组的所有不同值。\n\n使用 ES6 Set和…rest运算符放弃所有重复的值。\n\nconst distinctValuesOfArray = arr => [...new Set(arr)];\n// distinctValuesOfArray([1,2,2,3,4,4,5]) -> [1,2,3,4,5]\ndropElements\n移除数组中的元素, 直到传递的函数返回true。返回数组中的其余元素。 在数组中循环, 使用Array.shift()将数组的第一个元素除去, 直到函数的返回值为true。返回其余元素。\n\nconst dropElements = (arr, func) => {\nwhile (arr.length > 0 && !func(arr[0])) arr.shift();\nreturn arr;\n};\n// dropElements([1, 2, 3, 4], n => n >= 3) -> [3,4]\neveryNth\n返回数组中的每个第 n 个元素。\n\n使用Array.filter()创建一个包含给定数组的每个第 n 个元素的新数组。\n\nconst everyNth = (arr, nth) => arr.filter((e, i) => i % nth === 0);\n// everyNth([1,2,3,4,5,6], 2) -> [ 1, 3, 5 ]\nfilterNonUnique\n筛选出数组中的非唯一值。\n\n对于只包含唯一值的数组, 请使用Array.filter()。\n\nconst filterNonUnique = arr => arr.filter(i => arr.indexOf(i) === arr.lastIndexOf(i));\n// filterNonUnique([1,2,2,3,4,4,5]) -> [1,3,5]\nflatten\n拼合数组。\n\n使用Array.reduce()获取数组中的所有元素和concat()以拼合它们。\n\nconst flatten = arr => arr.reduce((a, v) => a.concat(v), []);\n// flatten([1,[2],3,4]) -> [1,2,3,4]\nflattenDepth\n将数组向上拼合到指定深度。\n\n使用递归, 递减depth, 每层深度为1。使用Array.reduce()和Array.concat()来合并元素或数组。基本情况下, 对于等于1的depth停止递归。省略第二个元素,depth仅拼合到1的深度 (单个拼合)。\n\nconst flattenDepth = (arr, depth = 1) =>\ndepth != 1 ? arr.reduce((a, v) => a.concat(Array.isArray(v) ? flattenDepth(v, depth - 1) : v), [])\n: arr.reduce((a, v) => a.concat(v), []);\n// flattenDepth([1,[2],[[[3],4],5]], 2) -> [1,2,[3],4,5]\ngroupby\n根据给定函数对数组元素进行分组。\n\n使用Array.map()将数组的值映射到函数或属性名。使用Array.reduce()创建一个对象, 其中的键是从映射的结果生成的。\n\nconst groupBy = (arr, func) =>\narr.map(typeof func === 'function' ? func : val => val[func])\n.reduce((acc, val, i) => { acc[val] = (acc[val] || []).concat(arr[i]); return acc; }, {});\n// groupBy([6.1, 4.2, 6.3], Math.floor) -> {4: [4.2], 6: [6.1, 6.3]}\n// groupBy(['one', 'two', 'three'], 'length') -> {3: ['one', 'two'], 5: ['three']}\nhead\n返回列表的头。\n\n使用arr[0]可返回传递的数组的第一个元素。\n\nconst head = arr => arr[0];\n// head([1,2,3]) -> 1\ninitial\n返回除最后一个数组之外的所有元素。\n\n使用 “arr.slice(0,-1)” 返回数组的最后一个元素。\n\nconst initial = arr => arr.slice(0, -1);\n// initial([1,2,3]) -> [1,2]\ninitializeArrayWithRange\n初始化包含指定范围内的数字的数组。\n\n使用Array(end-start)创建所需长度的数组Array.map()以填充区域中所需的值。可以省略start以使用默认值0.\n\nconst initializeArrayWithRange = (end, start = 0) =>\nArray.from({ length: end - start }).map((v, i) => i + start);\n// initializeArrayWithRange(5) -> [0,1,2,3,4]\ninitializeArrayWithValues\n初始化并填充具有指定值的数组。\n\n使用Array(n)创建所需长度的数组,fill(v)以填充所需的值。可以省略value以使用默认值0.\n\nconst initializeArrayWithValues = (n, value = 0) => Array(n).fill(value);\n// initializeArrayWithValues(5, 2) -> [2,2,2,2,2]\nintersection\n返回两个数组中存在的元素的列表。\n\n从b创建Set, 然后使用Array.filter()on a只保留b中包含的值.\n\nconst intersection = (a, b) => { const s = new Set(b); return a.filter(x => s.has(x)); };\n// intersection([1,2,3], [4,3,2]) -> [2,3]\nlast\n返回数组中的最后一个元素。\n\n使用arr.length – 1可计算给定数组的最后一个元素的索引并返回它。\n\nconst last = arr => arr[arr.length - 1];\n// last([1,2,3]) -> 3\nmapObject\n使用函数将数组的值映射到对象, 其中键值对由原始值作为键和映射值组成。\n\n使用匿名内部函数范围来声明未定义的内存空间, 使用闭包来存储返回值。使用新的Array可将该数组与函数的映射放在其数据集上, 而逗号运算符返回第二个步骤, 而不需要从一个上下文移动到另一个环境 (由于关闭和操作顺序)。\n\nconst mapObject = (arr, fn) => \n(a => (a = [arr, arr.map(fn)], a[0].reduce( (acc,val,ind) => (acc[val] = a[1][ind], acc), {}) )) ( );\n/*\nconst squareIt = arr => mapObject(arr, a => a*a)\nsquareIt([1,2,3]) // { 1: 1, 2: 4, 3: 9 }\n*/\nnthElement\n返回数组的第 n 个元素。\n\n使用Array.slice()可获取包含第 n 个元素的数组。如果索引超出界限, 则返回[]。省略第二个参数n, 以获取数组的第一个元素。\n\nconst nthElement = (arr, n=0) => (n>0? arr.slice(n,n+1) : arr.slice(n))[0];\n// nthElement(['a','b','c'],1) -> 'b'\n// nthElement(['a','b','b'],-3) -> 'a'\npick\n从对象中选取对应于给定键的键值对。\n\n使用Array.reduce()将筛选/选取的密钥转换回具有相应键值对的对象 (如果在 obj 中存在该键)。\n\nconst pick = (obj, arr) =>\narr.reduce((acc, curr) => (curr in obj && (acc[curr] = obj[curr]), acc), {});\n// pick({ 'a': 1, 'b': '2', 'c': 3 }, ['a', 'c']) -> { 'a': 1, 'c': 3 }\npull\n对原始数组进行变异, 以筛选出指定的值。\n\n使用Array.filter()和Array.includes()来拉出不需要的值。使用Array.length = 0可将传入的数组中的长度重置为零, 并将其设置为Array.push(), 以便仅使用所提取的值填充它。\n\nconst pull = (arr, ...args) => {\nlet pulled = arr.filter((v, i) => !args.includes(v));\narr.length = 0; pulled.forEach(v => arr.push(v));\n};\n// let myArray = ['a', 'b', 'c', 'a', 'b', 'c'];\n// pull(myArray, 'a', 'c');\n// console.log(myArray) -> [ 'b', 'b' ]\nremove\n从数组中移除给定函数返回false的元素. 使用Array.filter()查找返回 truthy 值的数组元素和Array.reduce()以使用Array.splice()删除元素。使用三参数 (func value, index, array调用函数).\n\nconst remove = (arr, func) =>\nArray.isArray(arr) ? arr.filter(func).reduce((acc, val) => {\narr.splice(arr.indexOf(val), 1); return acc.concat(val);\n}, [])\n: [];\n// remove([1, 2, 3, 4], n => n % 2 == 0) -> [2, 4]\nsample\n返回数组中的随机元素。\n\n使用Math.random()生成一个随机数, 将它与length相乘, 并使用数学将其舍入到最接近的整数Math.floor()。此方法也适用于字符串。\n\nconst sample = arr => arr[Math.floor(Math.random() * arr.length)];\n// sample([3, 7, 9, 11]) -> 9\nshuffle\n随机数组值的顺序。\n\n使用Array.sort()可在比较器中使用Math.random()重新排序元素。\n\nconst shuffle = arr => arr.sort(() => Math.random() - 0.5);\n// shuffle([1,2,3]) -> [2,3,1]\nsimilarity\n返回两个数组中都显示的元素的数组。\n\n使用filter()可删除不属于values的值, 使用includes()确定.\n\nconst similarity = (arr, values) => arr.filter(v => values.includes(v));\n// similarity([1,2,3], [1,2,4]) -> [1,2]\nsymmetricDifference\n返回两个数组之间的对称差。\n\n从每个数组创建一个Set, 然后对它们中的每一个都使用Array.filter(), 以便只保留其他值中不包含的数值。\n\nconst symmetricDifference = (a, b) => {\nconst sA = new Set(a), sB = new Set(b);\nreturn [...a.filter(x => !sB.has(x)), ...b.filter(x => !sA.has(x))];\n}\n// symmetricDifference([1,2,3], [1,2,4]) -> [3,4]\ntail\n返回数组中的所有元素, 除第一个。\n\n如果数组的length大于1, 则返回arr.slice(1), 否则返回整个数组。\n\nconst tail = arr => arr.length > 1 ? arr.slice(1) : arr;\n// tail([1,2,3]) -> [2,3]\n// tail([1]) -> [1]\ntake\n返回一个数组, 其中 n 个元素从开始处移除。\n\n使用Array.slice()创建数组的切片, 其中包含从开始处取出的n元素。\n\nconst take = (arr, n = 1) => arr.slice(0, n);\n// take([1, 2, 3], 5) -> [1, 2, 3]\n// take([1, 2, 3], 0) -> []\ntakeRight\n返回一个数组, 其中 n 个元素从末尾移除。\n\n使用Array.slice()创建数组的切片, 其中包含从末尾取出的n元素。\n\nconst takeRight = (arr, n = 1) => arr.slice(arr.length - n, arr.length);\n// takeRight([1, 2, 3], 2) -> [ 2, 3 ]\n// takeRight([1, 2, 3]) -> [3]\nunion\n返回在两个数组中的任意一个中存在的每个元素。\n\n创建一个Set, 其中包含a和b的所有值, 并将其转换为数组。\n\nconst union = (a, b) => Array.from(new Set([...a, ...b]));\n// union([1,2,3], [4,3,2]) -> [1,2,3,4]\nwithout\n筛选出数组中具有指定值之一的元素。\n\n使用Array.filter()创建不包括的数组 (使用!Array.includes()) 所有给定值。\n\nconst without = (arr, ...args) => arr.filter(v => !args.includes(v));\n// without([2, 1, 2, 3], 1, 2) -> [3]\nzip\n创建基于原始数组中的位置分组的元素数组。\n\n使用Math.max.apply()获取参数中最长的数组。创建一个以该长度为返回值的数组, 并使用 map 函数创建一个分组元素的数组Array.from()如果参数数组的长度不同, 则在未找到任何值的情况下使用undefined。\n\nconst zip = (...arrays) => {\nconst maxLength = Math.max(...arrays.map(x => x.length));\nreturn Array.from({length: maxLength}).map((_, i) => {\nreturn Array.from({length: arrays.length}, (_, k) => arrays[k][i]);\n})\n}\n//zip(['a', 'b'], [1, 2], [true, false]); -> [['a', 1, true], ['b', 2, false]]\n//zip(['a'], [1, 2], [true, false]); -> [['a', 1, true], [undefined, 2, false]]\n浏览器\nbottomVisible\n如果页的底部可见, 则返回true, 否则为false。\n\n使用scrollY、scrollHeight和clientHeight来确定页面底部是否可见。\n\nconst bottomVisible = () =>\ndocument.documentElement.clientHeight + window.scrollY >= document.documentElement.scrollHeight || document.documentElement.clientHeight;\n// bottomVisible() -> true\ncurrentURL\n返回当前 URL。\n\n使用window.location.href获取当前 URL。\n\nconst currentURL = () => window.location.href;\n// currentUrl() -> 'https://google.com'\nelementIsVisibleInViewport\n如果指定的元素在视区中可见, 则返回true, 否则为false。\n\n使用Element.getBoundingClientRect()和window.inner(Width|Height)值以确定给定元素在视区中是否可见。省略第二个参数以确定该元素是否完全可见, 或指定true以确定它是否部分可见。\n\nconst elementIsVisibleInViewport = (el, partiallyVisible = false) => {\nconst { top, left, bottom, right } = el.getBoundingClientRect();\nreturn partiallyVisible\n? ((top > 0 && top < innerHeight) || (bottom > 0 && bottom < innerHeight)) &&\n((left > 0 && left < innerWidth) || (right > 0 && right < innerWidth))\n: top >= 0 && left >= 0 && bottom <= innerHeight && right <= innerWidth;\n};\n// e.g. 100x100 viewport and a 10x10px element at position {top: -1, left: 0, bottom: 9, right: 10}\n// elementIsVisibleInViewport(el) -> false (not fully visible)\n// elementIsVisibleInViewport(el, true) -> true (partially visible)\ngetScrollPosition\n返回当前页的滚动位置。\n\n如果已定义, 则使用pageXOffset和pageYOffset, 否则scrollLeft和scrollTop。可以省略el以使用window的默认值.\n\nconst getScrollPosition = (el = window) =>\n({x: (el.pageXOffset !== undefined) ? el.pageXOffset : el.scrollLeft,\ny: (el.pageYOffset !== undefined) ? el.pageYOffset : el.scrollTop});\n// getScrollPosition() -> {x: 0, y: 200}\ngetURLParameters\n返回一个包含当前 URL 参数的对象。\n\n使用match()与适当的正则表达式来获取所有键值对,Array.reduce()可将它们映射并合并到单个对象中。将location.search作为要应用于当前url的参数传递.\n\nconst getURLParameters = url =>\nurl.match(/([^?=&]+)(=([^&]*))/g).reduce(\n(a, v) => (a[v.slice(0, v.indexOf('='))] = v.slice(v.indexOf('=') + 1), a), {}\n);\n// getURLParameters('http://url.com/page?name=Adam&surname=Smith') -> {name: 'Adam', surname: 'Smith'}\nredirect\n重定向到指定的 URL。\n\n使用window.location.href或window.location.replace()重定向到url。传递第二个参数以模拟链接单击 (true-默认值) 或 HTTP 重定向 (false).\n\nconst redirect = (url, asLink = true) =>\nasLink ? window.location.href = url : window.location.replace(url);\n// redirect('https://google.com')\nscrollToTop\n平滑滚动到页面顶部。\n\n使用document.documentElement.scrollTop或document.body.scrollTop从顶部获取距离。从顶部的距离的一小部分滚动。使用window.requestAnimationFrame()对滚动进行动画处理。\n\nconst scrollToTop = () => {\nconst c = document.documentElement.scrollTop || document.body.scrollTop;\nif (c > 0) {\nwindow.requestAnimationFrame(scrollToTop);\nwindow.scrollTo(0, c - c / 8);\n}\n};\n// scrollToTop()\n日期\ngetDaysDiffBetweenDates\n返回两个日期之间的差异 (以天为值)。\n\n计算Date对象之间的差异 (以天为)。\n\nconst getDaysDiffBetweenDates = (dateInitial, dateFinal) => (dateFinal - dateInitial) / (1000 * 3600 * 24);\n// getDaysDiffBetweenDates(new Date(\"2017-12-13\"), new Date(\"2017-12-22\")) -> 9\nJSONToDate\n将 JSON 对象转换为日期。\n\n使用Date(), 将 JSON 格式的日期转换为可读格式 (dd/mm/yyyy日)).\n\nconst JSONToDate = arr => {\nconst dt = new Date(parseInt(arr.toString().substr(6)));\nreturn `${ dt.getDate() }/${ dt.getMonth() + 1 }/${ dt.getFullYear() }`\n};\n// JSONToDate(/Date(1489525200000)/) -> \"14/3/2017\"\ntoEnglishDate\n将日期从美国格式转换为英文格式。\n\n使用Date.toISOString()、split(‘T’)和replace()将日期从美式格式转换为英文格式。如果传递的时间不能转换为日期, 则抛出错误。\n\nconst toEnglishDate  = (time) =>\n{try{return new Date(time).toISOString().split('T')[0].replace(/-/g, '/')}catch(e){return}};\n// toEnglishDate('09/21/2010') -> '21/09/2010'\n功能\nchainAsync\n链异步函数。\n\n循环遍历包含异步事件的函数数组, 当每个异步事件完成时调用next。\n\nconst chainAsync = fns => { let curr = 0; const next = () => fns[curr++](next); next(); };\n/*\nchainAsync([\n  next => { console.log('0 seconds'); setTimeout(next, 1000); },\n  next => { console.log('1 second');  setTimeout(next, 1000); },\n  next => { console.log('2 seconds'); }\n])\ncompose\n执行从右向左的函数组合。\n\n使用Array.reduce()执行从右向左的函数组合。最后一个 (最右边) 的函数可以接受一个或多个参数;其余的函数必须是一元的。\n\nconst compose = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)));\n/*\nconst add5 = x => x + 5\nconst multiply = (x, y) => x * y\nconst multiplyAndAdd5 = compose(add5, multiply)\nmultiplyAndAdd5(5, 2) -> 15\n*/\ncurry\nCurries a function.\n\n使用递归。如果提供的参数 (变量) 的数量足够, 请调用传递的函数args f。否则, 返回需要其余参数的扩充函数f。如果你想咖喱一个函数, 接受可变数目的参数 (如Math.min()), 可以选择将参数的个数传递到第二个参数arity(可变函数).\n\nconst curry = (fn, arity = fn.length, ...args) =>\narity <= args.length\n? fn(...args)\n: curry.bind(null, fn, arity, ...args);\n// curry(Math.pow)(2)(10) -> 1024\n// curry(Math.min, 3)(10)(50)(2) -> 2\nfunctionName\n记录函数的名称。\n\n使用console.debug()和传递的方法的name属性将方法的名称记录到控制台的debug通道中。\n\nconst functionName = fn => (console.debug(fn.name), fn);\n// functionName(Math.max) -> max (logged in debug channel of console)\npipe\n执行从左向右的函数组合。\n\n使用Array.reduce()与扩展运算符 (…) 执行从左向右的函数组合。第一个 (最左边的) 函数可以接受一个或多个参数;其余的函数必须是一元的。\n\nconst pipeFunctions = (...fns) => fns.reduce((f, g) => (...args) => g(f(...args)));\n/*\nconst add5 = x => x + 5\nconst multiply = (x, y) => x * y\nconst multiplyAndAdd5 = pipeFunctions(multiply, add5)\nmultiplyAndAdd5(5, 2) -> 15\n*/\npromisify\n转换异步函数以返回一个承诺。\n\n使用讨好返回一个返回调用原始函数的Promise的函数。使用…rest运算符传入所有参数。 在节点 8 + 中, 可以使用 util.promisify\n\nconst promisify = func =>\n(...args) =>\nnew Promise((resolve, reject) =>\nfunc(...args, (err, result) =>\nerr ? reject(err) : resolve(result))\n);\n// const delay = promisify((d, cb) => setTimeout(cb, d))\n// delay(2000).then(() => console.log('Hi!')) -> Promise resolves after 2s\nrunPromisesInSeries\n运行一系列的承诺系列。\n\n使用Array.reduce()创建一个承诺链, 每个承诺在解决时返回下一个承诺。\n\nconst runPromisesInSeries = ps => ps.reduce((p, next) => p.then(next), Promise.resolve());\n// const delay = (d) => new Promise(r => setTimeout(r, d))\n// runPromisesInSeries([() => delay(1000), () => delay(2000)]) -> executes each promise sequentially, taking a total of 3 seconds to complete\nsleep\n延迟异步函数的执行。\n\n延迟执行async函数的一部分, 将其放入休眠状态, 返回Promise.\n\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n/*\nasync function sleepyWork() {\n  console.log('I\\'m going to sleep for 1 second.');\n  await sleep(1000);\n  console.log('I woke up after 1 second.');\n}\n*/\n数学\narrayAverage\n返回数字数组的平均值。\n\n使用Array.reduce()将每个值添加到累加器中, 并以0的值初始化, 除以数组的length。\n\nconst arrayAverage = arr => arr.reduce((acc, val) => acc + val, 0) / arr.length;\n// arrayAverage([1,2,3]) -> 2\narraySum\n返回一个数字数组的总和。\n\n使用Array.reduce()将每个值添加到累加器中, 并以0值初始化.\n\nconst arraySum = arr => arr.reduce((acc, val) => acc + val, 0);\n// arraySum([1,2,3,4]) -> 10\ncollatz\n应用 Collatz 算法。\n\n如果n是偶数, 则返回n/2。否则返回3n+1.\n\nconst collatz = n => (n % 2 == 0) ? (n / 2) : (3 * n + 1);\n// collatz(8) --> 4\n// collatz(5) --> 16\ncollatz\n将数字转换为数字数组。\n\n将数字转换为字符串, 在 ES6 ([…string]) 中使用扩展运算符生成数组。使用Array.map()和parseInt()将每个值转换为整数。\n\nconst digitize = n => [...''+n].map(i => parseInt(i));\n// digitize(2334) -> [2, 3, 3, 4]\ndigitize\n返回两点之间的距离。\n\n使用Math.hypot()计算两个点之间的欧氏距离。\n\nconst distance = (x0, y0, x1, y1) => Math.hypot(x1 - x0, y1 - y0);\n// distance(1,1, 2,3) -> 2.23606797749979\ndistance\n计算数字的阶乘。\n\n使用递归。如果n小于或等于1, 则返回1。否则, 返回n的乘积和n – 1的阶乘。如果n为负数, 则引发异常。\n\nconst factorial = n =>\nn < 0 ? (() => { throw new TypeError('Negative numbers are not allowed!') })()\n: n <= 1 ? 1 : n * factorial(n - 1);\n// factorial(6) -> 720\nfibonacci\n生成一个数组, 包含斐波那契数列, 直到第 n 个项。\n\n创建一个指定长度的空数组, 初始化前两个值 (0和1)。使用Array.reduce()可将值添加到数组中, 方法是使用前两个值的总和, 但前两个数值除外。\n\nconst fibonacci = n =>\nArray(n).fill(0).reduce((acc, val, i) => acc.concat(i > 1 ? acc[i - 1] + acc[i - 2] : i), []);\n// fibonacci(5) -> [0,1,1,2,3]\ngcd\n计算两个数字之间最大的公共除数。\n\n使用递归。基本情况是当y等于0时。在这种情况下, 返回x。否则, 返回y的 GCD 和除法的其余部分x/y.\n\nconst gcd = (x, y) => !y ? x : gcd(y, x % y);\n// gcd (8, 36) -> 4\nhammingDistance\n计算两个值之间的汉明距离。\n\n使用 XOR 运算符 (^) 可查找两个数字之间的位差, 使用toString(2)转换为二进制字符串。使用match(/1/g)计算并返回字符串中1的数目。.\n\nconst hammingDistance = (num1, num2) =>\n((num1 ^ num2).toString(2).match(/1/g) || '').length;\n// hammingDistance(2,3) -> 1\nisDivisible\n检查第一个数值参数是否可被另一个数字变量整除。\n\n使用模数运算符 (%) 检查余数是否等于0.\n\nconst isDivisible = (dividend, divisor) => dividend % divisor === 0;\n// isDivisible(6,3) -> true\niseven\n如果给定的数字为偶数, 则返回true, 否则为false。\n\n检查一个数字是奇数还是使用模数 (%) 运算符。如果数字为偶数, 则返回true, 如果数字为奇数, 则为false。\n\nconst isEven = num => num % 2 === 0;\n// isEven(3) -> false\nlcm\n返回两个数字中最不常见的倍数。\n\n使用最大的公共除数 (GCD) 公式和Math.abs()来确定最不常见的倍数。GCD 公式使用递归。\n\nconst lcm = (x,y) => {\nconst gcd = (x, y) => !y ? x : gcd(y, x % y);\nreturn Math.abs(x*y)/(gcd(x,y));\n};\n// lcm(12,7) -> 84\nmedian\n返回数字数组的中间值。\n\n找到数组的中间, 使用Array.sort()来对值进行排序。如果length为奇数, 则返回中点的数字, 否则为两个中间数的平均值。\n\nconst median = arr => {\nconst mid = Math.floor(arr.length / 2), nums = arr.sort((a, b) => a - b);\nreturn arr.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n};\n// median([5,6,50,1,-5]) -> 5\n// median([0,10,-2,7]) -> 3.5\npalindrome\n如果给定字符串为回文, 则返回true, 否则为false。\n\n转换字符串toLowerCase()并使用replace()从其中删除非字母数字字符。然后,split(”)到各个字符,reverse(),join(”), 并将其与原始的、不可逆转的字符串进行比较, 然后将其转换为tolowerCase().\n\nconst palindrome = str => {\nconst s = str.toLowerCase().replace(/[\\W_]/g,'');\nreturn s === s.split('').reverse().join('');\n}\n// palindrome('taco cat') -> true\npercentile\n使用百分比公式计算给定数组中有多少个数小于或等于给定值。\n\n使用Array.reduce()计算值的下面有多少, 有多少个数是相同的值, 并应用百分比公式。\n\nconst percentile = (arr, val) =>\n100 * arr.reduce((acc,v) => acc + (v < val ? 1 : 0) + (v === val ? 0.5 : 0), 0) / arr.length;\n// percentile([1,2,3,4,5,6,7,8,9,10], 6) -> 55\npowerset\n返回给定数字数组的 powerset。\n\n使用Array.reduce()与Array.map()组合, 以循环访问元素并将其合并到包含所有组合的数组中。\n\nconst powerset = arr =>\narr.reduce((a, v) => a.concat(a.map(r => [v].concat(r))), [[]]);\n// powerset([1,2]) -> [[], [1], [2], [2,1]]\nrandomIntegerInRange\n返回指定范围内的随机整数。\n\n使用Math.random()生成一个随机数并将其映射到所需的范围, 使用Math.floor()使其成为整数。\n\nconst randomIntegerInRange = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n// randomIntegerInRange(0, 5) -> 2\nrandomNumberInRange\n返回指定范围内的随机数。\n\n使用Math.random()生成随机值, 并使用乘法将其映射到所需的范围。\n\nconst randomNumberInRange = (min, max) => Math.random() * (max - min) + min;\n// randomNumberInRange(2,10) -> 6.0211363285087005\nround\n将数字四舍五入到指定的位数。\n\n使用Math.round()和模板文本将数字舍入到指定的位数。省略第二个参数,decimals舍入为整数。\n\nconst round = (n, decimals=0) => Number(`${Math.round(`${n}e${decimals}`)}e-${decimals}`);\n// round(1.005, 2) -> 1.01\nstandardDeviation\n返回数字数组的标准偏差。\n\n使用Array.reduce()计算值的平均值、方差和方差的总和, 值的方差, 然后确定标准偏差。可以省略第二个参数以获取样本标准偏差, 或将其设置为true以获取总体标准偏差。\n\nconst standardDeviation = (arr, usePopulation = false) => {\nconst mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;\nreturn Math.sqrt(\narr.reduce((acc, val) => acc.concat(Math.pow(val - mean, 2)), [])\n.reduce((acc, val) => acc + val, 0) / (arr.length - (usePopulation ? 0 : 1))\n);\n};\n// standardDeviation([10,2,38,23,38,23,21]) -> 13.284434142114991 (sample)\n// standardDeviation([10,2,38,23,38,23,21], true) -> 12.29899614287479 (population)\n媒体\nspeechSynthesis\n执行语音合成 (实验)。\n\n使用SpeechSynthesisUtterance.voice和window.speechSynthesis.getVoices()将邮件转换为语音。使用window.speechSynthesis.speak()播放该消息。了解有关Web 语音 API 的 SpeechSynthesisUtterance 接口的详细信息.\n\nconst speechSynthesis = message => {\nconst msg = new SpeechSynthesisUtterance(message);\nmsg.voice = window.speechSynthesis.getVoices()[0];\nwindow.speechSynthesis.speak(msg);\n};\n// speechSynthesis('Hello, World') -> plays the message\n节点\nJSONToFile\n将 JSON 对象写入文件。\n\n使用fs.writeFile()、模板文本和JSON.stringify()将json对象写入.json文件。\n\nconst fs = require('fs');\nconst JSONToFile = (obj, filename) => fs.writeFile(`${filename}.json`, JSON.stringify(obj, null, 2))\n// JSONToFile({test: \"is passed\"}, 'testJsonFile') -> writes the object to 'testJsonFile.json'\nreadFileLines\n返回指定文件中的行的数组。\n\n在fs节点包中使用readFileSync函数可以从文件创建Buffer。使用toString(encoding)函数将缓冲区转换为字符串。通过spliting 文件内容行从文件内容创建数组 (每个\\n).\n\nconst fs = require('fs');\nconst readFileLines = filename => fs.readFileSync(filename).toString('UTF8').split('\\n');\n/*\ncontents of test.txt :\n  line1\n  line2\n  line3\n  ___________________________\nlet arr = readFileLines('test.txt')\nconsole.log(arr) // -> ['line1', 'line2', 'line3']\n*/\n对象\ncleanObj\n移除从 JSON 对象指定的属性之外的任何特性。\n\n使用Object.keys()方法可以遍历给定的 json 对象并删除在给定数组中不是included 的键。另外, 如果给它一个特殊的键 (childIndicator), 它将在里面深入搜索, 并将函数应用于内部对象。\n\nconst cleanObj = (obj, keysToKeep = [], childIndicator) => {\nObject.keys(obj).forEach(key => {\nif (key === childIndicator) {\ncleanObj(obj[key], keysToKeep, childIndicator);\n} else if (!keysToKeep.includes(key)) {\ndelete obj[key];\n}\n})\n}\n/*\n  const testObj = {a: 1, b: 2, children: {a: 1, b: 2}}\n  cleanObj(testObj, [\"a\"],\"children\")\n  console.log(testObj)// { a: 1, children : { a: 1}}\n*/\nobjectFromPairs\n从给定的键值对创建对象。\n\n使用Array.reduce()创建和组合键值对。\n\nconst objectFromPairs = arr => arr.reduce((a, v) => (a[v[0]] = v[1], a), {});\n// objectFromPairs([['a',1],['b',2]]) -> {a: 1, b: 2}\nobjectToPairs\n从对象创建键值对数组的数组。\n\n使用Object.keys()和Array.map()循环访问对象的键并生成具有键值对的数组。\n\nconst objectToPairs = obj => Object.keys(obj).map(k => [k, obj[k]]);\n// objectToPairs({a: 1, b: 2}) -> [['a',1],['b',2]])\nshallowClone\n创建对象的浅表克隆。\n\n使用Object.assign()和一个空对象 ({}) 创建原始的浅克隆。\n\nconst shallowClone = obj => Object.assign({}, obj);\n/*\nconst a = { x: true, y: 1 };\nconst b = shallowClone(a);\na === b -> false\n*/\ntruthCheckCollection\n检查谓词 (第二个参数) 是否 truthy 集合的所有元素 (第一个参数)。\n\n使用Array.every()检查每个传递的对象是否具有指定的属性, 以及是否返回 truthy 值。\n\ntruthCheckCollection = (collection, pre) => (collection.every(obj => obj[pre]));\n// truthCheckCollection([{\"user\": \"Tinky-Winky\", \"sex\": \"male\"}, {\"user\": \"Dipsy\", \"sex\": \"male\"}], \"sex\") -> true\n字符串\nanagrams\n生成字符串的所有字谜 (包含重复项)。\n\n使用递归。对于给定字符串中的每个字母, 为其其余字母创建所有部分字谜。使用Array.map()将字母与每个部分变位词组合在一起, 然后将Array.reduce()组合在一个数组中的所有字谜。基本情况为字符串length等于2或1.\n\nconst anagrams = str => {\nif (str.length <= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str];\nreturn str.split('').reduce((acc, letter, i) =>\nacc.concat(anagrams(str.slice(0, i) + str.slice(i + 1)).map(val => letter + val)), []);\n};\n// anagrams('abc') -> ['abc','acb','bac','bca','cab','cba']\nCapitalize\n将字符串的第一个字母大写。\n\n使用 destructuring 和toUpperCase()可将第一个字母、…rest用于获取第一个字母之后的字符数组, 然后是Array.join(”)以使其成为字符串。省略lowerRest参数以保持字符串的其余部分不变, 或将其设置为true以转换为小写。\n\nconst capitalize = ([first,...rest], lowerRest = false) =>\nfirst.toUpperCase() + (lowerRest ? rest.join('').toLowerCase() : rest.join(''));\n// capitalize('myName') -> 'MyName'\n// capitalize('myName', true) -> 'Myname'\ncapitalizeEveryWord\n将字符串中每个单词的首字母大写。\n\n使用replace()匹配每个单词和toUpperCase()的第一个字符以将其大写。\n\nconst capitalizeEveryWord = str => str.replace(/\\b[a-z]/g, char => char.toUpperCase());\n// capitalizeEveryWord('hello world!') -> 'Hello World!'\nescapeRegExp\n转义要在正则表达式中使用的字符串。\n\n使用replace()可转义特殊字符。\n\nconst escapeRegExp = str => str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n// escapeRegExp('(test)') -> \\\\(test\\\\)\nfromCamelCase\n从匹配转换字符串。\n\n使用replace()可删除下划线、连字符和空格, 并将单词转换为匹配。省略第二个参数以使用默认分隔符_.\n\nconst fromCamelCase = (str, separator = '_') =>\nstr.replace(/([a-z\\d])([A-Z])/g, '$1' + separator + '$2')\n.replace(/([A-Z]+)([A-Z][a-z\\d]+)/g, '$1' + separator + '$2').toLowerCase();\n// fromCamelCase('someDatabaseFieldName', ' ') -> 'some database field name'\n// fromCamelCase('someLabelThatNeedsToBeCamelized', '-') -> 'some-label-that-needs-to-be-camelized'\n// fromCamelCase('someJavascriptProperty', '_') -> 'some_javascript_property'\nreverseString\n反转字符串。\n\n使用数组 destructuring 和Array.reverse()可反转字符串中字符的顺序。使用join(”)组合字符以获取字符串.\n\nconst reverseString = str => [...str].reverse().join('');\n// reverseString('foobar') -> 'raboof'\nsortCharactersInString\n按字母顺序对字符串中的字符进行排序。\n\n使用split(”)、Array.sort()利用localeCompare()重新组合使用join(”).\n\nconst sortCharactersInString = str =>\nstr.split('').sort((a, b) => a.localeCompare(b)).join('');\n// sortCharactersInString('cabbage') -> 'aabbceg'\ntoCamelCase\n将字符串转换为匹配。\n\n使用replace()可删除下划线、连字符和空格, 并将单词转换为匹配。\n\nconst toCamelCase = str =>\nstr.replace(/^([A-Z])|[\\s-_]+(\\w)/g, (match, p1, p2, offset) =>  p2 ? p2.toUpperCase() : p1.toLowerCase());\n// toCamelCase(\"some_database_field_name\") -> 'someDatabaseFieldName'\n// toCamelCase(\"Some label that needs to be camelized\") -> 'someLabelThatNeedsToBeCamelized'\n// toCamelCase(\"some-javascript-property\") -> 'someJavascriptProperty'\n// toCamelCase(\"some-mixed_string with spaces_underscores-and-hyphens\") -> 'someMixedStringWithSpacesUnderscoresAndHyphens'\ntruncateString\n将字符串截断为指定长度。\n\n确定字符串的length是否大于num。将截断的字符串返回到所需的长度, 并将…追加到末尾或原始字符串。\n\nconst truncateString = (str, num) =>\nstr.length > num ? str.slice(0, num > 3 ? num - 3 : num) + '...' : str;\n// truncateString('boomerang', 7) -> 'boom...'\n实用\ncoalesce\n返回第一个非空/未定义参数。\n\n使用Array.find()返回第一个非null/undefined的参数。\n\nconst coalesce = (...args) => args.find(_ => ![undefined, null].includes(_))\n// coalesce(null,undefined,\"\",NaN, \"Waldo\") -> \"\"\ncoalesceFactory\n返回自定义的联合函数, 返回从提供的参数验证函数返回true的第一个参数。\n\n使用Array.find()返回从提供的参数验证函数返回true的第一个参数。\n\nconst coalesceFactory = valid => (...args) => args.find(valid);\n// const customCoalesce = coalesceFactory(_ => ![null, undefined, \"\", NaN].includes(_))\n// customCoalesce(undefined, null, NaN, \"\", \"Waldo\") //-> \"Waldo\"\nextendHex\n将3位色码扩展为6位色码。\n\n使用Array.map()、split()和Array.join()来加入映射数组, 将3位的 RGB notated 十六进制 color-code 转换为6位数字形式。Array.slice()用于从字符串启动中删除#, 因为它添加了一次。\n\nconst extendHex = shortHex =>\n'#' + shortHex.slice(shortHex.startsWith('#') ? 1 : 0).split('').map(x => x+x).join('')\n// extendHex('#03f') -> '#0033ff'\n// extendHex('05a') -> '#0055aa'\ngettype\n返回值的本机类型。\n\n如果值未定义或为 null, 则返回小写的构造函数名称、”未定义” 或 “null”\n\nconst getType = v =>\nv === undefined ? 'undefined' : v === null ? 'null' : v.constructor.name.toLowerCase();\n// getType(new Set([1,2,3])) -> \"set\"\nhexToRGB\n将 colorcode 转换为rgb()字符串。\n\n使用按位右运算符和掩码位与&(and) 运算符将十六进制颜色代码 (前缀为#) 转换为具有 RGB 值的字符串。如果它是一个3位数的 colorcode, 那么用 extendHex () 函数 (ref.extendHex代码段) 扩展的6位 colorcode 进行相同的处理\n\nconst hexToRgb = hex => {\nconst extendHex = shortHex =>\n'#' + shortHex.slice(shortHex.startsWith('#') ? 1 : 0).split('').map(x => x+x).join('');\nconst extendedHex = hex.slice(hex.startsWith('#') ? 1 : 0).length === 3 ? extendHex(hex) : hex;\nreturn `rgb(${parseInt(extendedHex.slice(1), 16) >> 16}, ${(parseInt(extendedHex.slice(1), 16) & 0x00ff00) >> 8}, ${parseInt(extendedHex.slice(1), 16) & 0x0000ff})`;\n}\n// hexToRgb('#27ae60') -> 'rgb(39, 174, 96)'\n// hexToRgb('#acd') -> 'rgb(170, 204, 221)'\nisArray\n检查给定参数是否为数组。\n\n使用Array.isArray()检查某个值是否属于数组。\n\nconst isArray = val => !!val && Array.isArray(val);\n// isArray(null) -> false\n// isArray([1]) -> true\nisBoolean\n检查给定的参数是否为本机布尔元素。\n\n使用typeof检查某个值是否被归类为布尔基元。\n\nconst isBoolean = val => typeof val === 'boolean';\n// isBoolean(null) -> false\n// isBoolean(false) -> true\nisFunction\n检查给定参数是否为函数。\n\n使用typeof检查某个值是否被归类为函数基元。\n\nconst isFunction = val => val && typeof val === 'function';\n// isFunction('x') -> false\n// isFunction(x => x) -> true\nisNumber\n检查给定参数是否为数字。\n\n使用typeof检查某个值是否归类为数字基元。\n\nconst isNumber = val => typeof val === 'number';\n// isNumber('1') -> false\n// isNumber(1) -> true\nisString\n检查给定参数是否为字符串。\n\n使用typeof检查某个值是否属于字符串基元。\n\nconst isString = val => typeof val === 'string';\n// isString(10) -> false\n// isString('10') -> true\nisSymbol\n检查给定参数是否为符号。\n\n使用typeof检查某个值是否被归类为符号基元。\n\nconst isSymbol = val => typeof val === 'symbol';\n// isSymbol('x') -> false\n// isSymbol(Symbol('x')) -> true\nRGBToHex\n将 RGB 组件的值转换为 colorcode。\n\n使用按位左移位运算符 (<<) 和toString(16)将给定的 RGB 参数转换为十六进制字符串, 然后padStart(6,’0′)以获取6位十六进制值。\n\nconst RGBToHex = (r, g, b) => ((r << 16) + (g << 8) + b).toString(16).padStart(6, '0');\n// RGBToHex(255, 165, 1) -> 'ffa501'\ntimeTaken\n测量执行函数所用的时间。\n\n使用console.time()和console.timeEnd()来测量开始和结束时间之间的差异, 以确定回调执行所用的时间。\n\nconst timeTaken = callback => {\nconsole.time('timeTaken');  const r = callback();\nconsole.timeEnd('timeTaken');  return r;\n};\n// timeTaken(() => Math.pow(2, 10)) -> 1024\n// (logged): timeTaken: 0.02099609375ms\ntoOrdinalSuffix\n将序号后缀添加到数字。\n\n使用模数运算符 (%) 查找单个和十位数字的值。查找匹配的序号模式数字。如果在青少年模式中发现数字, 请使用青少年序号。\n\nconst toOrdinalSuffix = num => {\nconst int = parseInt(num), digits = [(int % 10), (int % 100)],\nordinals = ['st', 'nd', 'rd', 'th'], oPattern = [1, 2, 3, 4],\ntPattern = [11, 12, 13, 14, 15, 16, 17, 18, 19];\nreturn oPattern.includes(digits[0]) && !tPattern.includes(digits[1]) ? int + ordinals[digits[0] - 1] : int + ordinals[3];\n};\n// toOrdinalSuffix(\"123\") -> \"123rd\"\nUUIDGenerator\n生成 UUID。\n\n使用cryptoAPI 生成 UUID, 符合RFC4122版本4。\n\nconst UUIDGenerator = () =>\n([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>\n(c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n);\n// UUIDGenerator() -> '7982fcfe-5721-4632-bede-6000885be57d'\nvalidateEmail\n如果给定的字符串是有效的电子邮件, 则返回true, 否则为false。\n\n使用正则表达式检查电子邮件是否有效。如果电子邮件有效, 则返回 true, 如果没有, 则返回false。\n\nconst validateEmail = str =>\n  /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/.test(str);\n// validateEmail(mymail@gmail.com) -> true\nvalidateNumber\n如果给定值为数字, 则返回true, 否则为false。\n\n将!isNaN与parseFloat()结合使用, 以检查参数是否为数字。使用isFinite()检查数字是否是有限的。使用Number()检查强制是否保持。\n\nconst validateNumber = n => !isNaN(parseFloat(n)) && isFinite(n) && Number(n) == n;\n// validateNumber('10') -> true\n感谢作者分享了大量有用的Javascript片段,本文为中文版翻译，下面一起来看看有哪些精彩的JavaScript代码值得收藏。\n\n原文：https://github.com/Chalarangelo/30-seconds-of-code\n\n作者：Chalarangelo\n\n翻译：http://caibaojian.com/30-seconds-of-code.html\n\n译者：蔡宝坚\n\n本文翻译为前端开发博客所有，如有需要转载，请详细注明以上信息。","source":"_posts/index.md","raw":"---\ntitle: 数组操作第二部分\ndate: 2018-01-28 17:23:04\ntags: array, javascript, api\n---\n数组\narrayMax\n返回数组中的最大值。\n\n将Math.max()与扩展运算符 (…) 结合使用以获取数组中的最大值。\n\nconst arrayMax = arr => Math.max(...arr);\n// arrayMax([10, 1, 5]) -> 10\narrayMin\n返回数组中的最小值。\n\n将Math.min()与扩展运算符 (…) 结合使用以获取数组中的最小值。\n\nconst arrayMin = arr => Math.min(...arr);\n// arrayMin([10, 1, 5]) -> 1\nchunk\n将数组块划分为指定大小的较小数组。\n\n使用Array.from()创建新的数组, 这符合将生成的区块数。使用Array.slice()将新数组的每个元素映射到size长度的区块。如果原始数组不能均匀拆分, 则最终的块将包含剩余的元素。\n\nconst chunk = (arr, size) =>\nArray.from({length: Math.ceil(arr.length / size)}, (v, i) => arr.slice(i * size, i * size + size));\n// chunk([1,2,3,4,5], 2) -> [[1,2],[3,4],[5]]\ncompact\n从数组中移除 falsey 值。\n\n使用Array.filter()筛选出 falsey 值 (false、null、0、””、undefined和NaN).\n\nconst compact = (arr) => arr.filter(Boolean);\n// compact([0, 1, false, 2, '', 3, 'a', 'e'*23, NaN, 's', 34]) -> [ 1, 2, 3, 'a', 's', 34 ]\ncountOccurrences\n计算数组中值的出现次数。\n\n使用Array.reduce()在每次遇到数组中的特定值时递增计数器。\n\nconst countOccurrences = (arr, value) => arr.reduce((a, v) => v === value ? a + 1 : a + 0, 0);\n// countOccurrences([1,1,2,1,2,3], 1) -> 3\ndeepFlatten\n深拼合数组。\n\n使用递归。使用Array.concat()与空数组 ([]) 和跨页运算符 (…) 来拼合数组。递归拼合作为数组的每个元素。\n\nconst deepFlatten = arr => [].concat(...arr.map(v => Array.isArray(v) ? deepFlatten(v) : v));\n// deepFlatten([1,[2],[[3],4],5]) -> [1,2,3,4,5]\ndifference\n返回两个数组之间的差异。\n\n从b创建Set, 然后使用Array.filter() on 只保留a b中不包含的值.\n\nconst difference = (a, b) => { const s = new Set(b); return a.filter(x => !s.has(x)); };\n// difference([1,2,3], [1,2,4]) -> [3]\ndistinctValuesOfArray\n返回数组的所有不同值。\n\n使用 ES6 Set和…rest运算符放弃所有重复的值。\n\nconst distinctValuesOfArray = arr => [...new Set(arr)];\n// distinctValuesOfArray([1,2,2,3,4,4,5]) -> [1,2,3,4,5]\ndropElements\n移除数组中的元素, 直到传递的函数返回true。返回数组中的其余元素。 在数组中循环, 使用Array.shift()将数组的第一个元素除去, 直到函数的返回值为true。返回其余元素。\n\nconst dropElements = (arr, func) => {\nwhile (arr.length > 0 && !func(arr[0])) arr.shift();\nreturn arr;\n};\n// dropElements([1, 2, 3, 4], n => n >= 3) -> [3,4]\neveryNth\n返回数组中的每个第 n 个元素。\n\n使用Array.filter()创建一个包含给定数组的每个第 n 个元素的新数组。\n\nconst everyNth = (arr, nth) => arr.filter((e, i) => i % nth === 0);\n// everyNth([1,2,3,4,5,6], 2) -> [ 1, 3, 5 ]\nfilterNonUnique\n筛选出数组中的非唯一值。\n\n对于只包含唯一值的数组, 请使用Array.filter()。\n\nconst filterNonUnique = arr => arr.filter(i => arr.indexOf(i) === arr.lastIndexOf(i));\n// filterNonUnique([1,2,2,3,4,4,5]) -> [1,3,5]\nflatten\n拼合数组。\n\n使用Array.reduce()获取数组中的所有元素和concat()以拼合它们。\n\nconst flatten = arr => arr.reduce((a, v) => a.concat(v), []);\n// flatten([1,[2],3,4]) -> [1,2,3,4]\nflattenDepth\n将数组向上拼合到指定深度。\n\n使用递归, 递减depth, 每层深度为1。使用Array.reduce()和Array.concat()来合并元素或数组。基本情况下, 对于等于1的depth停止递归。省略第二个元素,depth仅拼合到1的深度 (单个拼合)。\n\nconst flattenDepth = (arr, depth = 1) =>\ndepth != 1 ? arr.reduce((a, v) => a.concat(Array.isArray(v) ? flattenDepth(v, depth - 1) : v), [])\n: arr.reduce((a, v) => a.concat(v), []);\n// flattenDepth([1,[2],[[[3],4],5]], 2) -> [1,2,[3],4,5]\ngroupby\n根据给定函数对数组元素进行分组。\n\n使用Array.map()将数组的值映射到函数或属性名。使用Array.reduce()创建一个对象, 其中的键是从映射的结果生成的。\n\nconst groupBy = (arr, func) =>\narr.map(typeof func === 'function' ? func : val => val[func])\n.reduce((acc, val, i) => { acc[val] = (acc[val] || []).concat(arr[i]); return acc; }, {});\n// groupBy([6.1, 4.2, 6.3], Math.floor) -> {4: [4.2], 6: [6.1, 6.3]}\n// groupBy(['one', 'two', 'three'], 'length') -> {3: ['one', 'two'], 5: ['three']}\nhead\n返回列表的头。\n\n使用arr[0]可返回传递的数组的第一个元素。\n\nconst head = arr => arr[0];\n// head([1,2,3]) -> 1\ninitial\n返回除最后一个数组之外的所有元素。\n\n使用 “arr.slice(0,-1)” 返回数组的最后一个元素。\n\nconst initial = arr => arr.slice(0, -1);\n// initial([1,2,3]) -> [1,2]\ninitializeArrayWithRange\n初始化包含指定范围内的数字的数组。\n\n使用Array(end-start)创建所需长度的数组Array.map()以填充区域中所需的值。可以省略start以使用默认值0.\n\nconst initializeArrayWithRange = (end, start = 0) =>\nArray.from({ length: end - start }).map((v, i) => i + start);\n// initializeArrayWithRange(5) -> [0,1,2,3,4]\ninitializeArrayWithValues\n初始化并填充具有指定值的数组。\n\n使用Array(n)创建所需长度的数组,fill(v)以填充所需的值。可以省略value以使用默认值0.\n\nconst initializeArrayWithValues = (n, value = 0) => Array(n).fill(value);\n// initializeArrayWithValues(5, 2) -> [2,2,2,2,2]\nintersection\n返回两个数组中存在的元素的列表。\n\n从b创建Set, 然后使用Array.filter()on a只保留b中包含的值.\n\nconst intersection = (a, b) => { const s = new Set(b); return a.filter(x => s.has(x)); };\n// intersection([1,2,3], [4,3,2]) -> [2,3]\nlast\n返回数组中的最后一个元素。\n\n使用arr.length – 1可计算给定数组的最后一个元素的索引并返回它。\n\nconst last = arr => arr[arr.length - 1];\n// last([1,2,3]) -> 3\nmapObject\n使用函数将数组的值映射到对象, 其中键值对由原始值作为键和映射值组成。\n\n使用匿名内部函数范围来声明未定义的内存空间, 使用闭包来存储返回值。使用新的Array可将该数组与函数的映射放在其数据集上, 而逗号运算符返回第二个步骤, 而不需要从一个上下文移动到另一个环境 (由于关闭和操作顺序)。\n\nconst mapObject = (arr, fn) => \n(a => (a = [arr, arr.map(fn)], a[0].reduce( (acc,val,ind) => (acc[val] = a[1][ind], acc), {}) )) ( );\n/*\nconst squareIt = arr => mapObject(arr, a => a*a)\nsquareIt([1,2,3]) // { 1: 1, 2: 4, 3: 9 }\n*/\nnthElement\n返回数组的第 n 个元素。\n\n使用Array.slice()可获取包含第 n 个元素的数组。如果索引超出界限, 则返回[]。省略第二个参数n, 以获取数组的第一个元素。\n\nconst nthElement = (arr, n=0) => (n>0? arr.slice(n,n+1) : arr.slice(n))[0];\n// nthElement(['a','b','c'],1) -> 'b'\n// nthElement(['a','b','b'],-3) -> 'a'\npick\n从对象中选取对应于给定键的键值对。\n\n使用Array.reduce()将筛选/选取的密钥转换回具有相应键值对的对象 (如果在 obj 中存在该键)。\n\nconst pick = (obj, arr) =>\narr.reduce((acc, curr) => (curr in obj && (acc[curr] = obj[curr]), acc), {});\n// pick({ 'a': 1, 'b': '2', 'c': 3 }, ['a', 'c']) -> { 'a': 1, 'c': 3 }\npull\n对原始数组进行变异, 以筛选出指定的值。\n\n使用Array.filter()和Array.includes()来拉出不需要的值。使用Array.length = 0可将传入的数组中的长度重置为零, 并将其设置为Array.push(), 以便仅使用所提取的值填充它。\n\nconst pull = (arr, ...args) => {\nlet pulled = arr.filter((v, i) => !args.includes(v));\narr.length = 0; pulled.forEach(v => arr.push(v));\n};\n// let myArray = ['a', 'b', 'c', 'a', 'b', 'c'];\n// pull(myArray, 'a', 'c');\n// console.log(myArray) -> [ 'b', 'b' ]\nremove\n从数组中移除给定函数返回false的元素. 使用Array.filter()查找返回 truthy 值的数组元素和Array.reduce()以使用Array.splice()删除元素。使用三参数 (func value, index, array调用函数).\n\nconst remove = (arr, func) =>\nArray.isArray(arr) ? arr.filter(func).reduce((acc, val) => {\narr.splice(arr.indexOf(val), 1); return acc.concat(val);\n}, [])\n: [];\n// remove([1, 2, 3, 4], n => n % 2 == 0) -> [2, 4]\nsample\n返回数组中的随机元素。\n\n使用Math.random()生成一个随机数, 将它与length相乘, 并使用数学将其舍入到最接近的整数Math.floor()。此方法也适用于字符串。\n\nconst sample = arr => arr[Math.floor(Math.random() * arr.length)];\n// sample([3, 7, 9, 11]) -> 9\nshuffle\n随机数组值的顺序。\n\n使用Array.sort()可在比较器中使用Math.random()重新排序元素。\n\nconst shuffle = arr => arr.sort(() => Math.random() - 0.5);\n// shuffle([1,2,3]) -> [2,3,1]\nsimilarity\n返回两个数组中都显示的元素的数组。\n\n使用filter()可删除不属于values的值, 使用includes()确定.\n\nconst similarity = (arr, values) => arr.filter(v => values.includes(v));\n// similarity([1,2,3], [1,2,4]) -> [1,2]\nsymmetricDifference\n返回两个数组之间的对称差。\n\n从每个数组创建一个Set, 然后对它们中的每一个都使用Array.filter(), 以便只保留其他值中不包含的数值。\n\nconst symmetricDifference = (a, b) => {\nconst sA = new Set(a), sB = new Set(b);\nreturn [...a.filter(x => !sB.has(x)), ...b.filter(x => !sA.has(x))];\n}\n// symmetricDifference([1,2,3], [1,2,4]) -> [3,4]\ntail\n返回数组中的所有元素, 除第一个。\n\n如果数组的length大于1, 则返回arr.slice(1), 否则返回整个数组。\n\nconst tail = arr => arr.length > 1 ? arr.slice(1) : arr;\n// tail([1,2,3]) -> [2,3]\n// tail([1]) -> [1]\ntake\n返回一个数组, 其中 n 个元素从开始处移除。\n\n使用Array.slice()创建数组的切片, 其中包含从开始处取出的n元素。\n\nconst take = (arr, n = 1) => arr.slice(0, n);\n// take([1, 2, 3], 5) -> [1, 2, 3]\n// take([1, 2, 3], 0) -> []\ntakeRight\n返回一个数组, 其中 n 个元素从末尾移除。\n\n使用Array.slice()创建数组的切片, 其中包含从末尾取出的n元素。\n\nconst takeRight = (arr, n = 1) => arr.slice(arr.length - n, arr.length);\n// takeRight([1, 2, 3], 2) -> [ 2, 3 ]\n// takeRight([1, 2, 3]) -> [3]\nunion\n返回在两个数组中的任意一个中存在的每个元素。\n\n创建一个Set, 其中包含a和b的所有值, 并将其转换为数组。\n\nconst union = (a, b) => Array.from(new Set([...a, ...b]));\n// union([1,2,3], [4,3,2]) -> [1,2,3,4]\nwithout\n筛选出数组中具有指定值之一的元素。\n\n使用Array.filter()创建不包括的数组 (使用!Array.includes()) 所有给定值。\n\nconst without = (arr, ...args) => arr.filter(v => !args.includes(v));\n// without([2, 1, 2, 3], 1, 2) -> [3]\nzip\n创建基于原始数组中的位置分组的元素数组。\n\n使用Math.max.apply()获取参数中最长的数组。创建一个以该长度为返回值的数组, 并使用 map 函数创建一个分组元素的数组Array.from()如果参数数组的长度不同, 则在未找到任何值的情况下使用undefined。\n\nconst zip = (...arrays) => {\nconst maxLength = Math.max(...arrays.map(x => x.length));\nreturn Array.from({length: maxLength}).map((_, i) => {\nreturn Array.from({length: arrays.length}, (_, k) => arrays[k][i]);\n})\n}\n//zip(['a', 'b'], [1, 2], [true, false]); -> [['a', 1, true], ['b', 2, false]]\n//zip(['a'], [1, 2], [true, false]); -> [['a', 1, true], [undefined, 2, false]]\n浏览器\nbottomVisible\n如果页的底部可见, 则返回true, 否则为false。\n\n使用scrollY、scrollHeight和clientHeight来确定页面底部是否可见。\n\nconst bottomVisible = () =>\ndocument.documentElement.clientHeight + window.scrollY >= document.documentElement.scrollHeight || document.documentElement.clientHeight;\n// bottomVisible() -> true\ncurrentURL\n返回当前 URL。\n\n使用window.location.href获取当前 URL。\n\nconst currentURL = () => window.location.href;\n// currentUrl() -> 'https://google.com'\nelementIsVisibleInViewport\n如果指定的元素在视区中可见, 则返回true, 否则为false。\n\n使用Element.getBoundingClientRect()和window.inner(Width|Height)值以确定给定元素在视区中是否可见。省略第二个参数以确定该元素是否完全可见, 或指定true以确定它是否部分可见。\n\nconst elementIsVisibleInViewport = (el, partiallyVisible = false) => {\nconst { top, left, bottom, right } = el.getBoundingClientRect();\nreturn partiallyVisible\n? ((top > 0 && top < innerHeight) || (bottom > 0 && bottom < innerHeight)) &&\n((left > 0 && left < innerWidth) || (right > 0 && right < innerWidth))\n: top >= 0 && left >= 0 && bottom <= innerHeight && right <= innerWidth;\n};\n// e.g. 100x100 viewport and a 10x10px element at position {top: -1, left: 0, bottom: 9, right: 10}\n// elementIsVisibleInViewport(el) -> false (not fully visible)\n// elementIsVisibleInViewport(el, true) -> true (partially visible)\ngetScrollPosition\n返回当前页的滚动位置。\n\n如果已定义, 则使用pageXOffset和pageYOffset, 否则scrollLeft和scrollTop。可以省略el以使用window的默认值.\n\nconst getScrollPosition = (el = window) =>\n({x: (el.pageXOffset !== undefined) ? el.pageXOffset : el.scrollLeft,\ny: (el.pageYOffset !== undefined) ? el.pageYOffset : el.scrollTop});\n// getScrollPosition() -> {x: 0, y: 200}\ngetURLParameters\n返回一个包含当前 URL 参数的对象。\n\n使用match()与适当的正则表达式来获取所有键值对,Array.reduce()可将它们映射并合并到单个对象中。将location.search作为要应用于当前url的参数传递.\n\nconst getURLParameters = url =>\nurl.match(/([^?=&]+)(=([^&]*))/g).reduce(\n(a, v) => (a[v.slice(0, v.indexOf('='))] = v.slice(v.indexOf('=') + 1), a), {}\n);\n// getURLParameters('http://url.com/page?name=Adam&surname=Smith') -> {name: 'Adam', surname: 'Smith'}\nredirect\n重定向到指定的 URL。\n\n使用window.location.href或window.location.replace()重定向到url。传递第二个参数以模拟链接单击 (true-默认值) 或 HTTP 重定向 (false).\n\nconst redirect = (url, asLink = true) =>\nasLink ? window.location.href = url : window.location.replace(url);\n// redirect('https://google.com')\nscrollToTop\n平滑滚动到页面顶部。\n\n使用document.documentElement.scrollTop或document.body.scrollTop从顶部获取距离。从顶部的距离的一小部分滚动。使用window.requestAnimationFrame()对滚动进行动画处理。\n\nconst scrollToTop = () => {\nconst c = document.documentElement.scrollTop || document.body.scrollTop;\nif (c > 0) {\nwindow.requestAnimationFrame(scrollToTop);\nwindow.scrollTo(0, c - c / 8);\n}\n};\n// scrollToTop()\n日期\ngetDaysDiffBetweenDates\n返回两个日期之间的差异 (以天为值)。\n\n计算Date对象之间的差异 (以天为)。\n\nconst getDaysDiffBetweenDates = (dateInitial, dateFinal) => (dateFinal - dateInitial) / (1000 * 3600 * 24);\n// getDaysDiffBetweenDates(new Date(\"2017-12-13\"), new Date(\"2017-12-22\")) -> 9\nJSONToDate\n将 JSON 对象转换为日期。\n\n使用Date(), 将 JSON 格式的日期转换为可读格式 (dd/mm/yyyy日)).\n\nconst JSONToDate = arr => {\nconst dt = new Date(parseInt(arr.toString().substr(6)));\nreturn `${ dt.getDate() }/${ dt.getMonth() + 1 }/${ dt.getFullYear() }`\n};\n// JSONToDate(/Date(1489525200000)/) -> \"14/3/2017\"\ntoEnglishDate\n将日期从美国格式转换为英文格式。\n\n使用Date.toISOString()、split(‘T’)和replace()将日期从美式格式转换为英文格式。如果传递的时间不能转换为日期, 则抛出错误。\n\nconst toEnglishDate  = (time) =>\n{try{return new Date(time).toISOString().split('T')[0].replace(/-/g, '/')}catch(e){return}};\n// toEnglishDate('09/21/2010') -> '21/09/2010'\n功能\nchainAsync\n链异步函数。\n\n循环遍历包含异步事件的函数数组, 当每个异步事件完成时调用next。\n\nconst chainAsync = fns => { let curr = 0; const next = () => fns[curr++](next); next(); };\n/*\nchainAsync([\n  next => { console.log('0 seconds'); setTimeout(next, 1000); },\n  next => { console.log('1 second');  setTimeout(next, 1000); },\n  next => { console.log('2 seconds'); }\n])\ncompose\n执行从右向左的函数组合。\n\n使用Array.reduce()执行从右向左的函数组合。最后一个 (最右边) 的函数可以接受一个或多个参数;其余的函数必须是一元的。\n\nconst compose = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)));\n/*\nconst add5 = x => x + 5\nconst multiply = (x, y) => x * y\nconst multiplyAndAdd5 = compose(add5, multiply)\nmultiplyAndAdd5(5, 2) -> 15\n*/\ncurry\nCurries a function.\n\n使用递归。如果提供的参数 (变量) 的数量足够, 请调用传递的函数args f。否则, 返回需要其余参数的扩充函数f。如果你想咖喱一个函数, 接受可变数目的参数 (如Math.min()), 可以选择将参数的个数传递到第二个参数arity(可变函数).\n\nconst curry = (fn, arity = fn.length, ...args) =>\narity <= args.length\n? fn(...args)\n: curry.bind(null, fn, arity, ...args);\n// curry(Math.pow)(2)(10) -> 1024\n// curry(Math.min, 3)(10)(50)(2) -> 2\nfunctionName\n记录函数的名称。\n\n使用console.debug()和传递的方法的name属性将方法的名称记录到控制台的debug通道中。\n\nconst functionName = fn => (console.debug(fn.name), fn);\n// functionName(Math.max) -> max (logged in debug channel of console)\npipe\n执行从左向右的函数组合。\n\n使用Array.reduce()与扩展运算符 (…) 执行从左向右的函数组合。第一个 (最左边的) 函数可以接受一个或多个参数;其余的函数必须是一元的。\n\nconst pipeFunctions = (...fns) => fns.reduce((f, g) => (...args) => g(f(...args)));\n/*\nconst add5 = x => x + 5\nconst multiply = (x, y) => x * y\nconst multiplyAndAdd5 = pipeFunctions(multiply, add5)\nmultiplyAndAdd5(5, 2) -> 15\n*/\npromisify\n转换异步函数以返回一个承诺。\n\n使用讨好返回一个返回调用原始函数的Promise的函数。使用…rest运算符传入所有参数。 在节点 8 + 中, 可以使用 util.promisify\n\nconst promisify = func =>\n(...args) =>\nnew Promise((resolve, reject) =>\nfunc(...args, (err, result) =>\nerr ? reject(err) : resolve(result))\n);\n// const delay = promisify((d, cb) => setTimeout(cb, d))\n// delay(2000).then(() => console.log('Hi!')) -> Promise resolves after 2s\nrunPromisesInSeries\n运行一系列的承诺系列。\n\n使用Array.reduce()创建一个承诺链, 每个承诺在解决时返回下一个承诺。\n\nconst runPromisesInSeries = ps => ps.reduce((p, next) => p.then(next), Promise.resolve());\n// const delay = (d) => new Promise(r => setTimeout(r, d))\n// runPromisesInSeries([() => delay(1000), () => delay(2000)]) -> executes each promise sequentially, taking a total of 3 seconds to complete\nsleep\n延迟异步函数的执行。\n\n延迟执行async函数的一部分, 将其放入休眠状态, 返回Promise.\n\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n/*\nasync function sleepyWork() {\n  console.log('I\\'m going to sleep for 1 second.');\n  await sleep(1000);\n  console.log('I woke up after 1 second.');\n}\n*/\n数学\narrayAverage\n返回数字数组的平均值。\n\n使用Array.reduce()将每个值添加到累加器中, 并以0的值初始化, 除以数组的length。\n\nconst arrayAverage = arr => arr.reduce((acc, val) => acc + val, 0) / arr.length;\n// arrayAverage([1,2,3]) -> 2\narraySum\n返回一个数字数组的总和。\n\n使用Array.reduce()将每个值添加到累加器中, 并以0值初始化.\n\nconst arraySum = arr => arr.reduce((acc, val) => acc + val, 0);\n// arraySum([1,2,3,4]) -> 10\ncollatz\n应用 Collatz 算法。\n\n如果n是偶数, 则返回n/2。否则返回3n+1.\n\nconst collatz = n => (n % 2 == 0) ? (n / 2) : (3 * n + 1);\n// collatz(8) --> 4\n// collatz(5) --> 16\ncollatz\n将数字转换为数字数组。\n\n将数字转换为字符串, 在 ES6 ([…string]) 中使用扩展运算符生成数组。使用Array.map()和parseInt()将每个值转换为整数。\n\nconst digitize = n => [...''+n].map(i => parseInt(i));\n// digitize(2334) -> [2, 3, 3, 4]\ndigitize\n返回两点之间的距离。\n\n使用Math.hypot()计算两个点之间的欧氏距离。\n\nconst distance = (x0, y0, x1, y1) => Math.hypot(x1 - x0, y1 - y0);\n// distance(1,1, 2,3) -> 2.23606797749979\ndistance\n计算数字的阶乘。\n\n使用递归。如果n小于或等于1, 则返回1。否则, 返回n的乘积和n – 1的阶乘。如果n为负数, 则引发异常。\n\nconst factorial = n =>\nn < 0 ? (() => { throw new TypeError('Negative numbers are not allowed!') })()\n: n <= 1 ? 1 : n * factorial(n - 1);\n// factorial(6) -> 720\nfibonacci\n生成一个数组, 包含斐波那契数列, 直到第 n 个项。\n\n创建一个指定长度的空数组, 初始化前两个值 (0和1)。使用Array.reduce()可将值添加到数组中, 方法是使用前两个值的总和, 但前两个数值除外。\n\nconst fibonacci = n =>\nArray(n).fill(0).reduce((acc, val, i) => acc.concat(i > 1 ? acc[i - 1] + acc[i - 2] : i), []);\n// fibonacci(5) -> [0,1,1,2,3]\ngcd\n计算两个数字之间最大的公共除数。\n\n使用递归。基本情况是当y等于0时。在这种情况下, 返回x。否则, 返回y的 GCD 和除法的其余部分x/y.\n\nconst gcd = (x, y) => !y ? x : gcd(y, x % y);\n// gcd (8, 36) -> 4\nhammingDistance\n计算两个值之间的汉明距离。\n\n使用 XOR 运算符 (^) 可查找两个数字之间的位差, 使用toString(2)转换为二进制字符串。使用match(/1/g)计算并返回字符串中1的数目。.\n\nconst hammingDistance = (num1, num2) =>\n((num1 ^ num2).toString(2).match(/1/g) || '').length;\n// hammingDistance(2,3) -> 1\nisDivisible\n检查第一个数值参数是否可被另一个数字变量整除。\n\n使用模数运算符 (%) 检查余数是否等于0.\n\nconst isDivisible = (dividend, divisor) => dividend % divisor === 0;\n// isDivisible(6,3) -> true\niseven\n如果给定的数字为偶数, 则返回true, 否则为false。\n\n检查一个数字是奇数还是使用模数 (%) 运算符。如果数字为偶数, 则返回true, 如果数字为奇数, 则为false。\n\nconst isEven = num => num % 2 === 0;\n// isEven(3) -> false\nlcm\n返回两个数字中最不常见的倍数。\n\n使用最大的公共除数 (GCD) 公式和Math.abs()来确定最不常见的倍数。GCD 公式使用递归。\n\nconst lcm = (x,y) => {\nconst gcd = (x, y) => !y ? x : gcd(y, x % y);\nreturn Math.abs(x*y)/(gcd(x,y));\n};\n// lcm(12,7) -> 84\nmedian\n返回数字数组的中间值。\n\n找到数组的中间, 使用Array.sort()来对值进行排序。如果length为奇数, 则返回中点的数字, 否则为两个中间数的平均值。\n\nconst median = arr => {\nconst mid = Math.floor(arr.length / 2), nums = arr.sort((a, b) => a - b);\nreturn arr.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n};\n// median([5,6,50,1,-5]) -> 5\n// median([0,10,-2,7]) -> 3.5\npalindrome\n如果给定字符串为回文, 则返回true, 否则为false。\n\n转换字符串toLowerCase()并使用replace()从其中删除非字母数字字符。然后,split(”)到各个字符,reverse(),join(”), 并将其与原始的、不可逆转的字符串进行比较, 然后将其转换为tolowerCase().\n\nconst palindrome = str => {\nconst s = str.toLowerCase().replace(/[\\W_]/g,'');\nreturn s === s.split('').reverse().join('');\n}\n// palindrome('taco cat') -> true\npercentile\n使用百分比公式计算给定数组中有多少个数小于或等于给定值。\n\n使用Array.reduce()计算值的下面有多少, 有多少个数是相同的值, 并应用百分比公式。\n\nconst percentile = (arr, val) =>\n100 * arr.reduce((acc,v) => acc + (v < val ? 1 : 0) + (v === val ? 0.5 : 0), 0) / arr.length;\n// percentile([1,2,3,4,5,6,7,8,9,10], 6) -> 55\npowerset\n返回给定数字数组的 powerset。\n\n使用Array.reduce()与Array.map()组合, 以循环访问元素并将其合并到包含所有组合的数组中。\n\nconst powerset = arr =>\narr.reduce((a, v) => a.concat(a.map(r => [v].concat(r))), [[]]);\n// powerset([1,2]) -> [[], [1], [2], [2,1]]\nrandomIntegerInRange\n返回指定范围内的随机整数。\n\n使用Math.random()生成一个随机数并将其映射到所需的范围, 使用Math.floor()使其成为整数。\n\nconst randomIntegerInRange = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n// randomIntegerInRange(0, 5) -> 2\nrandomNumberInRange\n返回指定范围内的随机数。\n\n使用Math.random()生成随机值, 并使用乘法将其映射到所需的范围。\n\nconst randomNumberInRange = (min, max) => Math.random() * (max - min) + min;\n// randomNumberInRange(2,10) -> 6.0211363285087005\nround\n将数字四舍五入到指定的位数。\n\n使用Math.round()和模板文本将数字舍入到指定的位数。省略第二个参数,decimals舍入为整数。\n\nconst round = (n, decimals=0) => Number(`${Math.round(`${n}e${decimals}`)}e-${decimals}`);\n// round(1.005, 2) -> 1.01\nstandardDeviation\n返回数字数组的标准偏差。\n\n使用Array.reduce()计算值的平均值、方差和方差的总和, 值的方差, 然后确定标准偏差。可以省略第二个参数以获取样本标准偏差, 或将其设置为true以获取总体标准偏差。\n\nconst standardDeviation = (arr, usePopulation = false) => {\nconst mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;\nreturn Math.sqrt(\narr.reduce((acc, val) => acc.concat(Math.pow(val - mean, 2)), [])\n.reduce((acc, val) => acc + val, 0) / (arr.length - (usePopulation ? 0 : 1))\n);\n};\n// standardDeviation([10,2,38,23,38,23,21]) -> 13.284434142114991 (sample)\n// standardDeviation([10,2,38,23,38,23,21], true) -> 12.29899614287479 (population)\n媒体\nspeechSynthesis\n执行语音合成 (实验)。\n\n使用SpeechSynthesisUtterance.voice和window.speechSynthesis.getVoices()将邮件转换为语音。使用window.speechSynthesis.speak()播放该消息。了解有关Web 语音 API 的 SpeechSynthesisUtterance 接口的详细信息.\n\nconst speechSynthesis = message => {\nconst msg = new SpeechSynthesisUtterance(message);\nmsg.voice = window.speechSynthesis.getVoices()[0];\nwindow.speechSynthesis.speak(msg);\n};\n// speechSynthesis('Hello, World') -> plays the message\n节点\nJSONToFile\n将 JSON 对象写入文件。\n\n使用fs.writeFile()、模板文本和JSON.stringify()将json对象写入.json文件。\n\nconst fs = require('fs');\nconst JSONToFile = (obj, filename) => fs.writeFile(`${filename}.json`, JSON.stringify(obj, null, 2))\n// JSONToFile({test: \"is passed\"}, 'testJsonFile') -> writes the object to 'testJsonFile.json'\nreadFileLines\n返回指定文件中的行的数组。\n\n在fs节点包中使用readFileSync函数可以从文件创建Buffer。使用toString(encoding)函数将缓冲区转换为字符串。通过spliting 文件内容行从文件内容创建数组 (每个\\n).\n\nconst fs = require('fs');\nconst readFileLines = filename => fs.readFileSync(filename).toString('UTF8').split('\\n');\n/*\ncontents of test.txt :\n  line1\n  line2\n  line3\n  ___________________________\nlet arr = readFileLines('test.txt')\nconsole.log(arr) // -> ['line1', 'line2', 'line3']\n*/\n对象\ncleanObj\n移除从 JSON 对象指定的属性之外的任何特性。\n\n使用Object.keys()方法可以遍历给定的 json 对象并删除在给定数组中不是included 的键。另外, 如果给它一个特殊的键 (childIndicator), 它将在里面深入搜索, 并将函数应用于内部对象。\n\nconst cleanObj = (obj, keysToKeep = [], childIndicator) => {\nObject.keys(obj).forEach(key => {\nif (key === childIndicator) {\ncleanObj(obj[key], keysToKeep, childIndicator);\n} else if (!keysToKeep.includes(key)) {\ndelete obj[key];\n}\n})\n}\n/*\n  const testObj = {a: 1, b: 2, children: {a: 1, b: 2}}\n  cleanObj(testObj, [\"a\"],\"children\")\n  console.log(testObj)// { a: 1, children : { a: 1}}\n*/\nobjectFromPairs\n从给定的键值对创建对象。\n\n使用Array.reduce()创建和组合键值对。\n\nconst objectFromPairs = arr => arr.reduce((a, v) => (a[v[0]] = v[1], a), {});\n// objectFromPairs([['a',1],['b',2]]) -> {a: 1, b: 2}\nobjectToPairs\n从对象创建键值对数组的数组。\n\n使用Object.keys()和Array.map()循环访问对象的键并生成具有键值对的数组。\n\nconst objectToPairs = obj => Object.keys(obj).map(k => [k, obj[k]]);\n// objectToPairs({a: 1, b: 2}) -> [['a',1],['b',2]])\nshallowClone\n创建对象的浅表克隆。\n\n使用Object.assign()和一个空对象 ({}) 创建原始的浅克隆。\n\nconst shallowClone = obj => Object.assign({}, obj);\n/*\nconst a = { x: true, y: 1 };\nconst b = shallowClone(a);\na === b -> false\n*/\ntruthCheckCollection\n检查谓词 (第二个参数) 是否 truthy 集合的所有元素 (第一个参数)。\n\n使用Array.every()检查每个传递的对象是否具有指定的属性, 以及是否返回 truthy 值。\n\ntruthCheckCollection = (collection, pre) => (collection.every(obj => obj[pre]));\n// truthCheckCollection([{\"user\": \"Tinky-Winky\", \"sex\": \"male\"}, {\"user\": \"Dipsy\", \"sex\": \"male\"}], \"sex\") -> true\n字符串\nanagrams\n生成字符串的所有字谜 (包含重复项)。\n\n使用递归。对于给定字符串中的每个字母, 为其其余字母创建所有部分字谜。使用Array.map()将字母与每个部分变位词组合在一起, 然后将Array.reduce()组合在一个数组中的所有字谜。基本情况为字符串length等于2或1.\n\nconst anagrams = str => {\nif (str.length <= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str];\nreturn str.split('').reduce((acc, letter, i) =>\nacc.concat(anagrams(str.slice(0, i) + str.slice(i + 1)).map(val => letter + val)), []);\n};\n// anagrams('abc') -> ['abc','acb','bac','bca','cab','cba']\nCapitalize\n将字符串的第一个字母大写。\n\n使用 destructuring 和toUpperCase()可将第一个字母、…rest用于获取第一个字母之后的字符数组, 然后是Array.join(”)以使其成为字符串。省略lowerRest参数以保持字符串的其余部分不变, 或将其设置为true以转换为小写。\n\nconst capitalize = ([first,...rest], lowerRest = false) =>\nfirst.toUpperCase() + (lowerRest ? rest.join('').toLowerCase() : rest.join(''));\n// capitalize('myName') -> 'MyName'\n// capitalize('myName', true) -> 'Myname'\ncapitalizeEveryWord\n将字符串中每个单词的首字母大写。\n\n使用replace()匹配每个单词和toUpperCase()的第一个字符以将其大写。\n\nconst capitalizeEveryWord = str => str.replace(/\\b[a-z]/g, char => char.toUpperCase());\n// capitalizeEveryWord('hello world!') -> 'Hello World!'\nescapeRegExp\n转义要在正则表达式中使用的字符串。\n\n使用replace()可转义特殊字符。\n\nconst escapeRegExp = str => str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n// escapeRegExp('(test)') -> \\\\(test\\\\)\nfromCamelCase\n从匹配转换字符串。\n\n使用replace()可删除下划线、连字符和空格, 并将单词转换为匹配。省略第二个参数以使用默认分隔符_.\n\nconst fromCamelCase = (str, separator = '_') =>\nstr.replace(/([a-z\\d])([A-Z])/g, '$1' + separator + '$2')\n.replace(/([A-Z]+)([A-Z][a-z\\d]+)/g, '$1' + separator + '$2').toLowerCase();\n// fromCamelCase('someDatabaseFieldName', ' ') -> 'some database field name'\n// fromCamelCase('someLabelThatNeedsToBeCamelized', '-') -> 'some-label-that-needs-to-be-camelized'\n// fromCamelCase('someJavascriptProperty', '_') -> 'some_javascript_property'\nreverseString\n反转字符串。\n\n使用数组 destructuring 和Array.reverse()可反转字符串中字符的顺序。使用join(”)组合字符以获取字符串.\n\nconst reverseString = str => [...str].reverse().join('');\n// reverseString('foobar') -> 'raboof'\nsortCharactersInString\n按字母顺序对字符串中的字符进行排序。\n\n使用split(”)、Array.sort()利用localeCompare()重新组合使用join(”).\n\nconst sortCharactersInString = str =>\nstr.split('').sort((a, b) => a.localeCompare(b)).join('');\n// sortCharactersInString('cabbage') -> 'aabbceg'\ntoCamelCase\n将字符串转换为匹配。\n\n使用replace()可删除下划线、连字符和空格, 并将单词转换为匹配。\n\nconst toCamelCase = str =>\nstr.replace(/^([A-Z])|[\\s-_]+(\\w)/g, (match, p1, p2, offset) =>  p2 ? p2.toUpperCase() : p1.toLowerCase());\n// toCamelCase(\"some_database_field_name\") -> 'someDatabaseFieldName'\n// toCamelCase(\"Some label that needs to be camelized\") -> 'someLabelThatNeedsToBeCamelized'\n// toCamelCase(\"some-javascript-property\") -> 'someJavascriptProperty'\n// toCamelCase(\"some-mixed_string with spaces_underscores-and-hyphens\") -> 'someMixedStringWithSpacesUnderscoresAndHyphens'\ntruncateString\n将字符串截断为指定长度。\n\n确定字符串的length是否大于num。将截断的字符串返回到所需的长度, 并将…追加到末尾或原始字符串。\n\nconst truncateString = (str, num) =>\nstr.length > num ? str.slice(0, num > 3 ? num - 3 : num) + '...' : str;\n// truncateString('boomerang', 7) -> 'boom...'\n实用\ncoalesce\n返回第一个非空/未定义参数。\n\n使用Array.find()返回第一个非null/undefined的参数。\n\nconst coalesce = (...args) => args.find(_ => ![undefined, null].includes(_))\n// coalesce(null,undefined,\"\",NaN, \"Waldo\") -> \"\"\ncoalesceFactory\n返回自定义的联合函数, 返回从提供的参数验证函数返回true的第一个参数。\n\n使用Array.find()返回从提供的参数验证函数返回true的第一个参数。\n\nconst coalesceFactory = valid => (...args) => args.find(valid);\n// const customCoalesce = coalesceFactory(_ => ![null, undefined, \"\", NaN].includes(_))\n// customCoalesce(undefined, null, NaN, \"\", \"Waldo\") //-> \"Waldo\"\nextendHex\n将3位色码扩展为6位色码。\n\n使用Array.map()、split()和Array.join()来加入映射数组, 将3位的 RGB notated 十六进制 color-code 转换为6位数字形式。Array.slice()用于从字符串启动中删除#, 因为它添加了一次。\n\nconst extendHex = shortHex =>\n'#' + shortHex.slice(shortHex.startsWith('#') ? 1 : 0).split('').map(x => x+x).join('')\n// extendHex('#03f') -> '#0033ff'\n// extendHex('05a') -> '#0055aa'\ngettype\n返回值的本机类型。\n\n如果值未定义或为 null, 则返回小写的构造函数名称、”未定义” 或 “null”\n\nconst getType = v =>\nv === undefined ? 'undefined' : v === null ? 'null' : v.constructor.name.toLowerCase();\n// getType(new Set([1,2,3])) -> \"set\"\nhexToRGB\n将 colorcode 转换为rgb()字符串。\n\n使用按位右运算符和掩码位与&(and) 运算符将十六进制颜色代码 (前缀为#) 转换为具有 RGB 值的字符串。如果它是一个3位数的 colorcode, 那么用 extendHex () 函数 (ref.extendHex代码段) 扩展的6位 colorcode 进行相同的处理\n\nconst hexToRgb = hex => {\nconst extendHex = shortHex =>\n'#' + shortHex.slice(shortHex.startsWith('#') ? 1 : 0).split('').map(x => x+x).join('');\nconst extendedHex = hex.slice(hex.startsWith('#') ? 1 : 0).length === 3 ? extendHex(hex) : hex;\nreturn `rgb(${parseInt(extendedHex.slice(1), 16) >> 16}, ${(parseInt(extendedHex.slice(1), 16) & 0x00ff00) >> 8}, ${parseInt(extendedHex.slice(1), 16) & 0x0000ff})`;\n}\n// hexToRgb('#27ae60') -> 'rgb(39, 174, 96)'\n// hexToRgb('#acd') -> 'rgb(170, 204, 221)'\nisArray\n检查给定参数是否为数组。\n\n使用Array.isArray()检查某个值是否属于数组。\n\nconst isArray = val => !!val && Array.isArray(val);\n// isArray(null) -> false\n// isArray([1]) -> true\nisBoolean\n检查给定的参数是否为本机布尔元素。\n\n使用typeof检查某个值是否被归类为布尔基元。\n\nconst isBoolean = val => typeof val === 'boolean';\n// isBoolean(null) -> false\n// isBoolean(false) -> true\nisFunction\n检查给定参数是否为函数。\n\n使用typeof检查某个值是否被归类为函数基元。\n\nconst isFunction = val => val && typeof val === 'function';\n// isFunction('x') -> false\n// isFunction(x => x) -> true\nisNumber\n检查给定参数是否为数字。\n\n使用typeof检查某个值是否归类为数字基元。\n\nconst isNumber = val => typeof val === 'number';\n// isNumber('1') -> false\n// isNumber(1) -> true\nisString\n检查给定参数是否为字符串。\n\n使用typeof检查某个值是否属于字符串基元。\n\nconst isString = val => typeof val === 'string';\n// isString(10) -> false\n// isString('10') -> true\nisSymbol\n检查给定参数是否为符号。\n\n使用typeof检查某个值是否被归类为符号基元。\n\nconst isSymbol = val => typeof val === 'symbol';\n// isSymbol('x') -> false\n// isSymbol(Symbol('x')) -> true\nRGBToHex\n将 RGB 组件的值转换为 colorcode。\n\n使用按位左移位运算符 (<<) 和toString(16)将给定的 RGB 参数转换为十六进制字符串, 然后padStart(6,’0′)以获取6位十六进制值。\n\nconst RGBToHex = (r, g, b) => ((r << 16) + (g << 8) + b).toString(16).padStart(6, '0');\n// RGBToHex(255, 165, 1) -> 'ffa501'\ntimeTaken\n测量执行函数所用的时间。\n\n使用console.time()和console.timeEnd()来测量开始和结束时间之间的差异, 以确定回调执行所用的时间。\n\nconst timeTaken = callback => {\nconsole.time('timeTaken');  const r = callback();\nconsole.timeEnd('timeTaken');  return r;\n};\n// timeTaken(() => Math.pow(2, 10)) -> 1024\n// (logged): timeTaken: 0.02099609375ms\ntoOrdinalSuffix\n将序号后缀添加到数字。\n\n使用模数运算符 (%) 查找单个和十位数字的值。查找匹配的序号模式数字。如果在青少年模式中发现数字, 请使用青少年序号。\n\nconst toOrdinalSuffix = num => {\nconst int = parseInt(num), digits = [(int % 10), (int % 100)],\nordinals = ['st', 'nd', 'rd', 'th'], oPattern = [1, 2, 3, 4],\ntPattern = [11, 12, 13, 14, 15, 16, 17, 18, 19];\nreturn oPattern.includes(digits[0]) && !tPattern.includes(digits[1]) ? int + ordinals[digits[0] - 1] : int + ordinals[3];\n};\n// toOrdinalSuffix(\"123\") -> \"123rd\"\nUUIDGenerator\n生成 UUID。\n\n使用cryptoAPI 生成 UUID, 符合RFC4122版本4。\n\nconst UUIDGenerator = () =>\n([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>\n(c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n);\n// UUIDGenerator() -> '7982fcfe-5721-4632-bede-6000885be57d'\nvalidateEmail\n如果给定的字符串是有效的电子邮件, 则返回true, 否则为false。\n\n使用正则表达式检查电子邮件是否有效。如果电子邮件有效, 则返回 true, 如果没有, 则返回false。\n\nconst validateEmail = str =>\n  /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/.test(str);\n// validateEmail(mymail@gmail.com) -> true\nvalidateNumber\n如果给定值为数字, 则返回true, 否则为false。\n\n将!isNaN与parseFloat()结合使用, 以检查参数是否为数字。使用isFinite()检查数字是否是有限的。使用Number()检查强制是否保持。\n\nconst validateNumber = n => !isNaN(parseFloat(n)) && isFinite(n) && Number(n) == n;\n// validateNumber('10') -> true\n感谢作者分享了大量有用的Javascript片段,本文为中文版翻译，下面一起来看看有哪些精彩的JavaScript代码值得收藏。\n\n原文：https://github.com/Chalarangelo/30-seconds-of-code\n\n作者：Chalarangelo\n\n翻译：http://caibaojian.com/30-seconds-of-code.html\n\n译者：蔡宝坚\n\n本文翻译为前端开发博客所有，如有需要转载，请详细注明以上信息。","slug":"index","published":1,"updated":"2018-01-28T09:40:22.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcymfvsm0007s2gsqo6fnu59","content":"<p>数组<br>arrayMax<br>返回数组中的最大值。</p>\n<p>将Math.max()与扩展运算符 (…) 结合使用以获取数组中的最大值。</p>\n<p>const arrayMax = arr =&gt; Math.max(…arr);<br>// arrayMax([10, 1, 5]) -&gt; 10<br>arrayMin<br>返回数组中的最小值。</p>\n<p>将Math.min()与扩展运算符 (…) 结合使用以获取数组中的最小值。</p>\n<p>const arrayMin = arr =&gt; Math.min(…arr);<br>// arrayMin([10, 1, 5]) -&gt; 1<br>chunk<br>将数组块划分为指定大小的较小数组。</p>\n<p>使用Array.from()创建新的数组, 这符合将生成的区块数。使用Array.slice()将新数组的每个元素映射到size长度的区块。如果原始数组不能均匀拆分, 则最终的块将包含剩余的元素。</p>\n<p>const chunk = (arr, size) =&gt;<br>Array.from({length: Math.ceil(arr.length / size)}, (v, i) =&gt; arr.slice(i <em> size, i </em> size + size));<br>// chunk([1,2,3,4,5], 2) -&gt; [[1,2],[3,4],[5]]<br>compact<br>从数组中移除 falsey 值。</p>\n<p>使用Array.filter()筛选出 falsey 值 (false、null、0、””、undefined和NaN).</p>\n<p>const compact = (arr) =&gt; arr.filter(Boolean);<br>// compact([0, 1, false, 2, ‘’, 3, ‘a’, ‘e’*23, NaN, ‘s’, 34]) -&gt; [ 1, 2, 3, ‘a’, ‘s’, 34 ]<br>countOccurrences<br>计算数组中值的出现次数。</p>\n<p>使用Array.reduce()在每次遇到数组中的特定值时递增计数器。</p>\n<p>const countOccurrences = (arr, value) =&gt; arr.reduce((a, v) =&gt; v === value ? a + 1 : a + 0, 0);<br>// countOccurrences([1,1,2,1,2,3], 1) -&gt; 3<br>deepFlatten<br>深拼合数组。</p>\n<p>使用递归。使用Array.concat()与空数组 ([]) 和跨页运算符 (…) 来拼合数组。递归拼合作为数组的每个元素。</p>\n<p>const deepFlatten = arr =&gt; [].concat(…arr.map(v =&gt; Array.isArray(v) ? deepFlatten(v) : v));<br>// deepFlatten([1,[2],[[3],4],5]) -&gt; [1,2,3,4,5]<br>difference<br>返回两个数组之间的差异。</p>\n<p>从b创建Set, 然后使用Array.filter() on 只保留a b中不包含的值.</p>\n<p>const difference = (a, b) =&gt; { const s = new Set(b); return a.filter(x =&gt; !s.has(x)); };<br>// difference([1,2,3], [1,2,4]) -&gt; [3]<br>distinctValuesOfArray<br>返回数组的所有不同值。</p>\n<p>使用 ES6 Set和…rest运算符放弃所有重复的值。</p>\n<p>const distinctValuesOfArray = arr =&gt; […new Set(arr)];<br>// distinctValuesOfArray([1,2,2,3,4,4,5]) -&gt; [1,2,3,4,5]<br>dropElements<br>移除数组中的元素, 直到传递的函数返回true。返回数组中的其余元素。 在数组中循环, 使用Array.shift()将数组的第一个元素除去, 直到函数的返回值为true。返回其余元素。</p>\n<p>const dropElements = (arr, func) =&gt; {<br>while (arr.length &gt; 0 &amp;&amp; !func(arr[0])) arr.shift();<br>return arr;<br>};<br>// dropElements([1, 2, 3, 4], n =&gt; n &gt;= 3) -&gt; [3,4]<br>everyNth<br>返回数组中的每个第 n 个元素。</p>\n<p>使用Array.filter()创建一个包含给定数组的每个第 n 个元素的新数组。</p>\n<p>const everyNth = (arr, nth) =&gt; arr.filter((e, i) =&gt; i % nth === 0);<br>// everyNth([1,2,3,4,5,6], 2) -&gt; [ 1, 3, 5 ]<br>filterNonUnique<br>筛选出数组中的非唯一值。</p>\n<p>对于只包含唯一值的数组, 请使用Array.filter()。</p>\n<p>const filterNonUnique = arr =&gt; arr.filter(i =&gt; arr.indexOf(i) === arr.lastIndexOf(i));<br>// filterNonUnique([1,2,2,3,4,4,5]) -&gt; [1,3,5]<br>flatten<br>拼合数组。</p>\n<p>使用Array.reduce()获取数组中的所有元素和concat()以拼合它们。</p>\n<p>const flatten = arr =&gt; arr.reduce((a, v) =&gt; a.concat(v), []);<br>// flatten([1,[2],3,4]) -&gt; [1,2,3,4]<br>flattenDepth<br>将数组向上拼合到指定深度。</p>\n<p>使用递归, 递减depth, 每层深度为1。使用Array.reduce()和Array.concat()来合并元素或数组。基本情况下, 对于等于1的depth停止递归。省略第二个元素,depth仅拼合到1的深度 (单个拼合)。</p>\n<p>const flattenDepth = (arr, depth = 1) =&gt;<br>depth != 1 ? arr.reduce((a, v) =&gt; a.concat(Array.isArray(v) ? flattenDepth(v, depth - 1) : v), [])<br>: arr.reduce((a, v) =&gt; a.concat(v), []);<br>// flattenDepth([1,[2],[[[3],4],5]], 2) -&gt; [1,2,[3],4,5]<br>groupby<br>根据给定函数对数组元素进行分组。</p>\n<p>使用Array.map()将数组的值映射到函数或属性名。使用Array.reduce()创建一个对象, 其中的键是从映射的结果生成的。</p>\n<p>const groupBy = (arr, func) =&gt;<br>arr.map(typeof func === ‘function’ ? func : val =&gt; val[func])<br>.reduce((acc, val, i) =&gt; { acc[val] = (acc[val] || []).concat(arr[i]); return acc; }, {});<br>// groupBy([6.1, 4.2, 6.3], Math.floor) -&gt; {4: [4.2], 6: [6.1, 6.3]}<br>// groupBy([‘one’, ‘two’, ‘three’], ‘length’) -&gt; {3: [‘one’, ‘two’], 5: [‘three’]}<br>head<br>返回列表的头。</p>\n<p>使用arr[0]可返回传递的数组的第一个元素。</p>\n<p>const head = arr =&gt; arr[0];<br>// head([1,2,3]) -&gt; 1<br>initial<br>返回除最后一个数组之外的所有元素。</p>\n<p>使用 “arr.slice(0,-1)” 返回数组的最后一个元素。</p>\n<p>const initial = arr =&gt; arr.slice(0, -1);<br>// initial([1,2,3]) -&gt; [1,2]<br>initializeArrayWithRange<br>初始化包含指定范围内的数字的数组。</p>\n<p>使用Array(end-start)创建所需长度的数组Array.map()以填充区域中所需的值。可以省略start以使用默认值0.</p>\n<p>const initializeArrayWithRange = (end, start = 0) =&gt;<br>Array.from({ length: end - start }).map((v, i) =&gt; i + start);<br>// initializeArrayWithRange(5) -&gt; [0,1,2,3,4]<br>initializeArrayWithValues<br>初始化并填充具有指定值的数组。</p>\n<p>使用Array(n)创建所需长度的数组,fill(v)以填充所需的值。可以省略value以使用默认值0.</p>\n<p>const initializeArrayWithValues = (n, value = 0) =&gt; Array(n).fill(value);<br>// initializeArrayWithValues(5, 2) -&gt; [2,2,2,2,2]<br>intersection<br>返回两个数组中存在的元素的列表。</p>\n<p>从b创建Set, 然后使用Array.filter()on a只保留b中包含的值.</p>\n<p>const intersection = (a, b) =&gt; { const s = new Set(b); return a.filter(x =&gt; s.has(x)); };<br>// intersection([1,2,3], [4,3,2]) -&gt; [2,3]<br>last<br>返回数组中的最后一个元素。</p>\n<p>使用arr.length – 1可计算给定数组的最后一个元素的索引并返回它。</p>\n<p>const last = arr =&gt; arr[arr.length - 1];<br>// last([1,2,3]) -&gt; 3<br>mapObject<br>使用函数将数组的值映射到对象, 其中键值对由原始值作为键和映射值组成。</p>\n<p>使用匿名内部函数范围来声明未定义的内存空间, 使用闭包来存储返回值。使用新的Array可将该数组与函数的映射放在其数据集上, 而逗号运算符返回第二个步骤, 而不需要从一个上下文移动到另一个环境 (由于关闭和操作顺序)。</p>\n<p>const mapObject = (arr, fn) =&gt;<br>(a =&gt; (a = [arr, arr.map(fn)], a[0].reduce( (acc,val,ind) =&gt; (acc[val] = a[1][ind], acc), {}) )) ( );<br>/<em><br>const squareIt = arr =&gt; mapObject(arr, a =&gt; a</em>a)<br>squareIt([1,2,3]) // { 1: 1, 2: 4, 3: 9 }<br>*/<br>nthElement<br>返回数组的第 n 个元素。</p>\n<p>使用Array.slice()可获取包含第 n 个元素的数组。如果索引超出界限, 则返回[]。省略第二个参数n, 以获取数组的第一个元素。</p>\n<p>const nthElement = (arr, n=0) =&gt; (n&gt;0? arr.slice(n,n+1) : arr.slice(n))[0];<br>// nthElement([‘a’,’b’,’c’],1) -&gt; ‘b’<br>// nthElement([‘a’,’b’,’b’],-3) -&gt; ‘a’<br>pick<br>从对象中选取对应于给定键的键值对。</p>\n<p>使用Array.reduce()将筛选/选取的密钥转换回具有相应键值对的对象 (如果在 obj 中存在该键)。</p>\n<p>const pick = (obj, arr) =&gt;<br>arr.reduce((acc, curr) =&gt; (curr in obj &amp;&amp; (acc[curr] = obj[curr]), acc), {});<br>// pick({ ‘a’: 1, ‘b’: ‘2’, ‘c’: 3 }, [‘a’, ‘c’]) -&gt; { ‘a’: 1, ‘c’: 3 }<br>pull<br>对原始数组进行变异, 以筛选出指定的值。</p>\n<p>使用Array.filter()和Array.includes()来拉出不需要的值。使用Array.length = 0可将传入的数组中的长度重置为零, 并将其设置为Array.push(), 以便仅使用所提取的值填充它。</p>\n<p>const pull = (arr, …args) =&gt; {<br>let pulled = arr.filter((v, i) =&gt; !args.includes(v));<br>arr.length = 0; pulled.forEach(v =&gt; arr.push(v));<br>};<br>// let myArray = [‘a’, ‘b’, ‘c’, ‘a’, ‘b’, ‘c’];<br>// pull(myArray, ‘a’, ‘c’);<br>// console.log(myArray) -&gt; [ ‘b’, ‘b’ ]<br>remove<br>从数组中移除给定函数返回false的元素. 使用Array.filter()查找返回 truthy 值的数组元素和Array.reduce()以使用Array.splice()删除元素。使用三参数 (func value, index, array调用函数).</p>\n<p>const remove = (arr, func) =&gt;<br>Array.isArray(arr) ? arr.filter(func).reduce((acc, val) =&gt; {<br>arr.splice(arr.indexOf(val), 1); return acc.concat(val);<br>}, [])<br>: [];<br>// remove([1, 2, 3, 4], n =&gt; n % 2 == 0) -&gt; [2, 4]<br>sample<br>返回数组中的随机元素。</p>\n<p>使用Math.random()生成一个随机数, 将它与length相乘, 并使用数学将其舍入到最接近的整数Math.floor()。此方法也适用于字符串。</p>\n<p>const sample = arr =&gt; arr[Math.floor(Math.random() * arr.length)];<br>// sample([3, 7, 9, 11]) -&gt; 9<br>shuffle<br>随机数组值的顺序。</p>\n<p>使用Array.sort()可在比较器中使用Math.random()重新排序元素。</p>\n<p>const shuffle = arr =&gt; arr.sort(() =&gt; Math.random() - 0.5);<br>// shuffle([1,2,3]) -&gt; [2,3,1]<br>similarity<br>返回两个数组中都显示的元素的数组。</p>\n<p>使用filter()可删除不属于values的值, 使用includes()确定.</p>\n<p>const similarity = (arr, values) =&gt; arr.filter(v =&gt; values.includes(v));<br>// similarity([1,2,3], [1,2,4]) -&gt; [1,2]<br>symmetricDifference<br>返回两个数组之间的对称差。</p>\n<p>从每个数组创建一个Set, 然后对它们中的每一个都使用Array.filter(), 以便只保留其他值中不包含的数值。</p>\n<p>const symmetricDifference = (a, b) =&gt; {<br>const sA = new Set(a), sB = new Set(b);<br>return […a.filter(x =&gt; !sB.has(x)), …b.filter(x =&gt; !sA.has(x))];<br>}<br>// symmetricDifference([1,2,3], [1,2,4]) -&gt; [3,4]<br>tail<br>返回数组中的所有元素, 除第一个。</p>\n<p>如果数组的length大于1, 则返回arr.slice(1), 否则返回整个数组。</p>\n<p>const tail = arr =&gt; arr.length &gt; 1 ? arr.slice(1) : arr;<br>// tail([1,2,3]) -&gt; [2,3]<br>// tail([1]) -&gt; [1]<br>take<br>返回一个数组, 其中 n 个元素从开始处移除。</p>\n<p>使用Array.slice()创建数组的切片, 其中包含从开始处取出的n元素。</p>\n<p>const take = (arr, n = 1) =&gt; arr.slice(0, n);<br>// take([1, 2, 3], 5) -&gt; [1, 2, 3]<br>// take([1, 2, 3], 0) -&gt; []<br>takeRight<br>返回一个数组, 其中 n 个元素从末尾移除。</p>\n<p>使用Array.slice()创建数组的切片, 其中包含从末尾取出的n元素。</p>\n<p>const takeRight = (arr, n = 1) =&gt; arr.slice(arr.length - n, arr.length);<br>// takeRight([1, 2, 3], 2) -&gt; [ 2, 3 ]<br>// takeRight([1, 2, 3]) -&gt; [3]<br>union<br>返回在两个数组中的任意一个中存在的每个元素。</p>\n<p>创建一个Set, 其中包含a和b的所有值, 并将其转换为数组。</p>\n<p>const union = (a, b) =&gt; Array.from(new Set([…a, …b]));<br>// union([1,2,3], [4,3,2]) -&gt; [1,2,3,4]<br>without<br>筛选出数组中具有指定值之一的元素。</p>\n<p>使用Array.filter()创建不包括的数组 (使用!Array.includes()) 所有给定值。</p>\n<p>const without = (arr, …args) =&gt; arr.filter(v =&gt; !args.includes(v));<br>// without([2, 1, 2, 3], 1, 2) -&gt; [3]<br>zip<br>创建基于原始数组中的位置分组的元素数组。</p>\n<p>使用Math.max.apply()获取参数中最长的数组。创建一个以该长度为返回值的数组, 并使用 map 函数创建一个分组元素的数组Array.from()如果参数数组的长度不同, 则在未找到任何值的情况下使用undefined。</p>\n<p>const zip = (…arrays) =&gt; {<br>const maxLength = Math.max(…arrays.map(x =&gt; x.length));<br>return Array.from({length: maxLength}).map((<em>, i) =&gt; {<br>return Array.from({length: arrays.length}, (</em>, k) =&gt; arrays[k][i]);<br>})<br>}<br>//zip([‘a’, ‘b’], [1, 2], [true, false]); -&gt; [[‘a’, 1, true], [‘b’, 2, false]]<br>//zip([‘a’], [1, 2], [true, false]); -&gt; [[‘a’, 1, true], [undefined, 2, false]]<br>浏览器<br>bottomVisible<br>如果页的底部可见, 则返回true, 否则为false。</p>\n<p>使用scrollY、scrollHeight和clientHeight来确定页面底部是否可见。</p>\n<p>const bottomVisible = () =&gt;<br>document.documentElement.clientHeight + window.scrollY &gt;= document.documentElement.scrollHeight || document.documentElement.clientHeight;<br>// bottomVisible() -&gt; true<br>currentURL<br>返回当前 URL。</p>\n<p>使用window.location.href获取当前 URL。</p>\n<p>const currentURL = () =&gt; window.location.href;<br>// currentUrl() -&gt; ‘<a href=\"https://google.com\" target=\"_blank\" rel=\"noopener\">https://google.com</a>‘<br>elementIsVisibleInViewport<br>如果指定的元素在视区中可见, 则返回true, 否则为false。</p>\n<p>使用Element.getBoundingClientRect()和window.inner(Width|Height)值以确定给定元素在视区中是否可见。省略第二个参数以确定该元素是否完全可见, 或指定true以确定它是否部分可见。</p>\n<p>const elementIsVisibleInViewport = (el, partiallyVisible = false) =&gt; {<br>const { top, left, bottom, right } = el.getBoundingClientRect();<br>return partiallyVisible<br>? ((top &gt; 0 &amp;&amp; top &lt; innerHeight) || (bottom &gt; 0 &amp;&amp; bottom &lt; innerHeight)) &amp;&amp;<br>((left &gt; 0 &amp;&amp; left &lt; innerWidth) || (right &gt; 0 &amp;&amp; right &lt; innerWidth))<br>: top &gt;= 0 &amp;&amp; left &gt;= 0 &amp;&amp; bottom &lt;= innerHeight &amp;&amp; right &lt;= innerWidth;<br>};<br>// e.g. 100x100 viewport and a 10x10px element at position {top: -1, left: 0, bottom: 9, right: 10}<br>// elementIsVisibleInViewport(el) -&gt; false (not fully visible)<br>// elementIsVisibleInViewport(el, true) -&gt; true (partially visible)<br>getScrollPosition<br>返回当前页的滚动位置。</p>\n<p>如果已定义, 则使用pageXOffset和pageYOffset, 否则scrollLeft和scrollTop。可以省略el以使用window的默认值.</p>\n<p>const getScrollPosition = (el = window) =&gt;<br>({x: (el.pageXOffset !== undefined) ? el.pageXOffset : el.scrollLeft,<br>y: (el.pageYOffset !== undefined) ? el.pageYOffset : el.scrollTop});<br>// getScrollPosition() -&gt; {x: 0, y: 200}<br>getURLParameters<br>返回一个包含当前 URL 参数的对象。</p>\n<p>使用match()与适当的正则表达式来获取所有键值对,Array.reduce()可将它们映射并合并到单个对象中。将location.search作为要应用于当前url的参数传递.</p>\n<p>const getURLParameters = url =&gt;<br>url.match(/([^?=&amp;]+)(=([^&amp;]*))/g).reduce(<br>(a, v) =&gt; (a[v.slice(0, v.indexOf(‘=’))] = v.slice(v.indexOf(‘=’) + 1), a), {}<br>);<br>// getURLParameters(‘<a href=\"http://url.com/page?name=Adam&amp;surname=Smith\" target=\"_blank\" rel=\"noopener\">http://url.com/page?name=Adam&amp;surname=Smith</a>‘) -&gt; {name: ‘Adam’, surname: ‘Smith’}<br>redirect<br>重定向到指定的 URL。</p>\n<p>使用window.location.href或window.location.replace()重定向到url。传递第二个参数以模拟链接单击 (true-默认值) 或 HTTP 重定向 (false).</p>\n<p>const redirect = (url, asLink = true) =&gt;<br>asLink ? window.location.href = url : window.location.replace(url);<br>// redirect(‘<a href=\"https://google.com\" target=\"_blank\" rel=\"noopener\">https://google.com</a>‘)<br>scrollToTop<br>平滑滚动到页面顶部。</p>\n<p>使用document.documentElement.scrollTop或document.body.scrollTop从顶部获取距离。从顶部的距离的一小部分滚动。使用window.requestAnimationFrame()对滚动进行动画处理。</p>\n<p>const scrollToTop = () =&gt; {<br>const c = document.documentElement.scrollTop || document.body.scrollTop;<br>if (c &gt; 0) {<br>window.requestAnimationFrame(scrollToTop);<br>window.scrollTo(0, c - c / 8);<br>}<br>};<br>// scrollToTop()<br>日期<br>getDaysDiffBetweenDates<br>返回两个日期之间的差异 (以天为值)。</p>\n<p>计算Date对象之间的差异 (以天为)。</p>\n<p>const getDaysDiffBetweenDates = (dateInitial, dateFinal) =&gt; (dateFinal - dateInitial) / (1000 <em> 3600 </em> 24);<br>// getDaysDiffBetweenDates(new Date(“2017-12-13”), new Date(“2017-12-22”)) -&gt; 9<br>JSONToDate<br>将 JSON 对象转换为日期。</p>\n<p>使用Date(), 将 JSON 格式的日期转换为可读格式 (dd/mm/yyyy日)).</p>\n<p>const JSONToDate = arr =&gt; {<br>const dt = new Date(parseInt(arr.toString().substr(6)));<br>return <code>${ dt.getDate() }/${ dt.getMonth() + 1 }/${ dt.getFullYear() }</code><br>};<br>// JSONToDate(/Date(1489525200000)/) -&gt; “14/3/2017”<br>toEnglishDate<br>将日期从美国格式转换为英文格式。</p>\n<p>使用Date.toISOString()、split(‘T’)和replace()将日期从美式格式转换为英文格式。如果传递的时间不能转换为日期, 则抛出错误。</p>\n<p>const toEnglishDate  = (time) =&gt;<br>{try{return new Date(time).toISOString().split(‘T’)[0].replace(/-/g, ‘/‘)}catch(e){return}};<br>// toEnglishDate(‘09/21/2010’) -&gt; ‘21/09/2010’<br>功能<br>chainAsync<br>链异步函数。</p>\n<p>循环遍历包含异步事件的函数数组, 当每个异步事件完成时调用next。</p>\n<p>const chainAsync = fns =&gt; { let curr = 0; const next = () =&gt; fns<a href=\"next\">curr++</a>; next(); };<br>/*<br>chainAsync([<br>  next =&gt; { console.log(‘0 seconds’); setTimeout(next, 1000); },<br>  next =&gt; { console.log(‘1 second’);  setTimeout(next, 1000); },<br>  next =&gt; { console.log(‘2 seconds’); }<br>])<br>compose<br>执行从右向左的函数组合。</p>\n<p>使用Array.reduce()执行从右向左的函数组合。最后一个 (最右边) 的函数可以接受一个或多个参数;其余的函数必须是一元的。</p>\n<p>const compose = (…fns) =&gt; fns.reduce((f, g) =&gt; (…args) =&gt; f(g(…args)));<br>/<em><br>const add5 = x =&gt; x + 5<br>const multiply = (x, y) =&gt; x </em> y<br>const multiplyAndAdd5 = compose(add5, multiply)<br>multiplyAndAdd5(5, 2) -&gt; 15<br>*/<br>curry<br>Curries a function.</p>\n<p>使用递归。如果提供的参数 (变量) 的数量足够, 请调用传递的函数args f。否则, 返回需要其余参数的扩充函数f。如果你想咖喱一个函数, 接受可变数目的参数 (如Math.min()), 可以选择将参数的个数传递到第二个参数arity(可变函数).</p>\n<p>const curry = (fn, arity = fn.length, …args) =&gt;<br>arity &lt;= args.length<br>? fn(…args)<br>: curry.bind(null, fn, arity, …args);<br>// curry(Math.pow)(2)(10) -&gt; 1024<br>// curry(Math.min, 3)(10)(50)(2) -&gt; 2<br>functionName<br>记录函数的名称。</p>\n<p>使用console.debug()和传递的方法的name属性将方法的名称记录到控制台的debug通道中。</p>\n<p>const functionName = fn =&gt; (console.debug(fn.name), fn);<br>// functionName(Math.max) -&gt; max (logged in debug channel of console)<br>pipe<br>执行从左向右的函数组合。</p>\n<p>使用Array.reduce()与扩展运算符 (…) 执行从左向右的函数组合。第一个 (最左边的) 函数可以接受一个或多个参数;其余的函数必须是一元的。</p>\n<p>const pipeFunctions = (…fns) =&gt; fns.reduce((f, g) =&gt; (…args) =&gt; g(f(…args)));<br>/<em><br>const add5 = x =&gt; x + 5<br>const multiply = (x, y) =&gt; x </em> y<br>const multiplyAndAdd5 = pipeFunctions(multiply, add5)<br>multiplyAndAdd5(5, 2) -&gt; 15<br>*/<br>promisify<br>转换异步函数以返回一个承诺。</p>\n<p>使用讨好返回一个返回调用原始函数的Promise的函数。使用…rest运算符传入所有参数。 在节点 8 + 中, 可以使用 util.promisify</p>\n<p>const promisify = func =&gt;<br>(…args) =&gt;<br>new Promise((resolve, reject) =&gt;<br>func(…args, (err, result) =&gt;<br>err ? reject(err) : resolve(result))<br>);<br>// const delay = promisify((d, cb) =&gt; setTimeout(cb, d))<br>// delay(2000).then(() =&gt; console.log(‘Hi!’)) -&gt; Promise resolves after 2s<br>runPromisesInSeries<br>运行一系列的承诺系列。</p>\n<p>使用Array.reduce()创建一个承诺链, 每个承诺在解决时返回下一个承诺。</p>\n<p>const runPromisesInSeries = ps =&gt; ps.reduce((p, next) =&gt; p.then(next), Promise.resolve());<br>// const delay = (d) =&gt; new Promise(r =&gt; setTimeout(r, d))<br>// runPromisesInSeries([() =&gt; delay(1000), () =&gt; delay(2000)]) -&gt; executes each promise sequentially, taking a total of 3 seconds to complete<br>sleep<br>延迟异步函数的执行。</p>\n<p>延迟执行async函数的一部分, 将其放入休眠状态, 返回Promise.</p>\n<p>const sleep = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));<br>/<em><br>async function sleepyWork() {<br>  console.log(‘I\\’m going to sleep for 1 second.’);<br>  await sleep(1000);<br>  console.log(‘I woke up after 1 second.’);<br>}\n</em>/<br>数学<br>arrayAverage<br>返回数字数组的平均值。</p>\n<p>使用Array.reduce()将每个值添加到累加器中, 并以0的值初始化, 除以数组的length。</p>\n<p>const arrayAverage = arr =&gt; arr.reduce((acc, val) =&gt; acc + val, 0) / arr.length;<br>// arrayAverage([1,2,3]) -&gt; 2<br>arraySum<br>返回一个数字数组的总和。</p>\n<p>使用Array.reduce()将每个值添加到累加器中, 并以0值初始化.</p>\n<p>const arraySum = arr =&gt; arr.reduce((acc, val) =&gt; acc + val, 0);<br>// arraySum([1,2,3,4]) -&gt; 10<br>collatz<br>应用 Collatz 算法。</p>\n<p>如果n是偶数, 则返回n/2。否则返回3n+1.</p>\n<p>const collatz = n =&gt; (n % 2 == 0) ? (n / 2) : (3 * n + 1);<br>// collatz(8) –&gt; 4<br>// collatz(5) –&gt; 16<br>collatz<br>将数字转换为数字数组。</p>\n<p>将数字转换为字符串, 在 ES6 ([…string]) 中使用扩展运算符生成数组。使用Array.map()和parseInt()将每个值转换为整数。</p>\n<p>const digitize = n =&gt; […’’+n].map(i =&gt; parseInt(i));<br>// digitize(2334) -&gt; [2, 3, 3, 4]<br>digitize<br>返回两点之间的距离。</p>\n<p>使用Math.hypot()计算两个点之间的欧氏距离。</p>\n<p>const distance = (x0, y0, x1, y1) =&gt; Math.hypot(x1 - x0, y1 - y0);<br>// distance(1,1, 2,3) -&gt; 2.23606797749979<br>distance<br>计算数字的阶乘。</p>\n<p>使用递归。如果n小于或等于1, 则返回1。否则, 返回n的乘积和n – 1的阶乘。如果n为负数, 则引发异常。</p>\n<p>const factorial = n =&gt;<br>n &lt; 0 ? (() =&gt; { throw new TypeError(‘Negative numbers are not allowed!’) })()<br>: n &lt;= 1 ? 1 : n * factorial(n - 1);<br>// factorial(6) -&gt; 720<br>fibonacci<br>生成一个数组, 包含斐波那契数列, 直到第 n 个项。</p>\n<p>创建一个指定长度的空数组, 初始化前两个值 (0和1)。使用Array.reduce()可将值添加到数组中, 方法是使用前两个值的总和, 但前两个数值除外。</p>\n<p>const fibonacci = n =&gt;<br>Array(n).fill(0).reduce((acc, val, i) =&gt; acc.concat(i &gt; 1 ? acc[i - 1] + acc[i - 2] : i), []);<br>// fibonacci(5) -&gt; [0,1,1,2,3]<br>gcd<br>计算两个数字之间最大的公共除数。</p>\n<p>使用递归。基本情况是当y等于0时。在这种情况下, 返回x。否则, 返回y的 GCD 和除法的其余部分x/y.</p>\n<p>const gcd = (x, y) =&gt; !y ? x : gcd(y, x % y);<br>// gcd (8, 36) -&gt; 4<br>hammingDistance<br>计算两个值之间的汉明距离。</p>\n<p>使用 XOR 运算符 (^) 可查找两个数字之间的位差, 使用toString(2)转换为二进制字符串。使用match(/1/g)计算并返回字符串中1的数目。.</p>\n<p>const hammingDistance = (num1, num2) =&gt;<br>((num1 ^ num2).toString(2).match(/1/g) || ‘’).length;<br>// hammingDistance(2,3) -&gt; 1<br>isDivisible<br>检查第一个数值参数是否可被另一个数字变量整除。</p>\n<p>使用模数运算符 (%) 检查余数是否等于0.</p>\n<p>const isDivisible = (dividend, divisor) =&gt; dividend % divisor === 0;<br>// isDivisible(6,3) -&gt; true<br>iseven<br>如果给定的数字为偶数, 则返回true, 否则为false。</p>\n<p>检查一个数字是奇数还是使用模数 (%) 运算符。如果数字为偶数, 则返回true, 如果数字为奇数, 则为false。</p>\n<p>const isEven = num =&gt; num % 2 === 0;<br>// isEven(3) -&gt; false<br>lcm<br>返回两个数字中最不常见的倍数。</p>\n<p>使用最大的公共除数 (GCD) 公式和Math.abs()来确定最不常见的倍数。GCD 公式使用递归。</p>\n<p>const lcm = (x,y) =&gt; {<br>const gcd = (x, y) =&gt; !y ? x : gcd(y, x % y);<br>return Math.abs(x*y)/(gcd(x,y));<br>};<br>// lcm(12,7) -&gt; 84<br>median<br>返回数字数组的中间值。</p>\n<p>找到数组的中间, 使用Array.sort()来对值进行排序。如果length为奇数, 则返回中点的数字, 否则为两个中间数的平均值。</p>\n<p>const median = arr =&gt; {<br>const mid = Math.floor(arr.length / 2), nums = arr.sort((a, b) =&gt; a - b);<br>return arr.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;<br>};<br>// median([5,6,50,1,-5]) -&gt; 5<br>// median([0,10,-2,7]) -&gt; 3.5<br>palindrome<br>如果给定字符串为回文, 则返回true, 否则为false。</p>\n<p>转换字符串toLowerCase()并使用replace()从其中删除非字母数字字符。然后,split(”)到各个字符,reverse(),join(”), 并将其与原始的、不可逆转的字符串进行比较, 然后将其转换为tolowerCase().</p>\n<p>const palindrome = str =&gt; {<br>const s = str.toLowerCase().replace(/[\\W_]/g,’’);<br>return s === s.split(‘’).reverse().join(‘’);<br>}<br>// palindrome(‘taco cat’) -&gt; true<br>percentile<br>使用百分比公式计算给定数组中有多少个数小于或等于给定值。</p>\n<p>使用Array.reduce()计算值的下面有多少, 有多少个数是相同的值, 并应用百分比公式。</p>\n<p>const percentile = (arr, val) =&gt;<br>100 * arr.reduce((acc,v) =&gt; acc + (v &lt; val ? 1 : 0) + (v === val ? 0.5 : 0), 0) / arr.length;<br>// percentile([1,2,3,4,5,6,7,8,9,10], 6) -&gt; 55<br>powerset<br>返回给定数字数组的 powerset。</p>\n<p>使用Array.reduce()与Array.map()组合, 以循环访问元素并将其合并到包含所有组合的数组中。</p>\n<p>const powerset = arr =&gt;<br>arr.reduce((a, v) =&gt; a.concat(a.map(r =&gt; [v].concat(r))), [[]]);<br>// powerset([1,2]) -&gt; [[], [1], [2], [2,1]]<br>randomIntegerInRange<br>返回指定范围内的随机整数。</p>\n<p>使用Math.random()生成一个随机数并将其映射到所需的范围, 使用Math.floor()使其成为整数。</p>\n<p>const randomIntegerInRange = (min, max) =&gt; Math.floor(Math.random() * (max - min + 1)) + min;<br>// randomIntegerInRange(0, 5) -&gt; 2<br>randomNumberInRange<br>返回指定范围内的随机数。</p>\n<p>使用Math.random()生成随机值, 并使用乘法将其映射到所需的范围。</p>\n<p>const randomNumberInRange = (min, max) =&gt; Math.random() * (max - min) + min;<br>// randomNumberInRange(2,10) -&gt; 6.0211363285087005<br>round<br>将数字四舍五入到指定的位数。</p>\n<p>使用Math.round()和模板文本将数字舍入到指定的位数。省略第二个参数,decimals舍入为整数。</p>\n<p>const round = (n, decimals=0) =&gt; Number(<code>${Math.round(</code>${n}e${decimals}<code>)}e-${decimals}</code>);<br>// round(1.005, 2) -&gt; 1.01<br>standardDeviation<br>返回数字数组的标准偏差。</p>\n<p>使用Array.reduce()计算值的平均值、方差和方差的总和, 值的方差, 然后确定标准偏差。可以省略第二个参数以获取样本标准偏差, 或将其设置为true以获取总体标准偏差。</p>\n<p>const standardDeviation = (arr, usePopulation = false) =&gt; {<br>const mean = arr.reduce((acc, val) =&gt; acc + val, 0) / arr.length;<br>return Math.sqrt(<br>arr.reduce((acc, val) =&gt; acc.concat(Math.pow(val - mean, 2)), [])<br>.reduce((acc, val) =&gt; acc + val, 0) / (arr.length - (usePopulation ? 0 : 1))<br>);<br>};<br>// standardDeviation([10,2,38,23,38,23,21]) -&gt; 13.284434142114991 (sample)<br>// standardDeviation([10,2,38,23,38,23,21], true) -&gt; 12.29899614287479 (population)<br>媒体<br>speechSynthesis<br>执行语音合成 (实验)。</p>\n<p>使用SpeechSynthesisUtterance.voice和window.speechSynthesis.getVoices()将邮件转换为语音。使用window.speechSynthesis.speak()播放该消息。了解有关Web 语音 API 的 SpeechSynthesisUtterance 接口的详细信息.</p>\n<p>const speechSynthesis = message =&gt; {<br>const msg = new SpeechSynthesisUtterance(message);<br>msg.voice = window.speechSynthesis.getVoices()[0];<br>window.speechSynthesis.speak(msg);<br>};<br>// speechSynthesis(‘Hello, World’) -&gt; plays the message<br>节点<br>JSONToFile<br>将 JSON 对象写入文件。</p>\n<p>使用fs.writeFile()、模板文本和JSON.stringify()将json对象写入.json文件。</p>\n<p>const fs = require(‘fs’);<br>const JSONToFile = (obj, filename) =&gt; fs.writeFile(<code>${filename}.json</code>, JSON.stringify(obj, null, 2))<br>// JSONToFile({test: “is passed”}, ‘testJsonFile’) -&gt; writes the object to ‘testJsonFile.json’<br>readFileLines<br>返回指定文件中的行的数组。</p>\n<p>在fs节点包中使用readFileSync函数可以从文件创建Buffer。使用toString(encoding)函数将缓冲区转换为字符串。通过spliting 文件内容行从文件内容创建数组 (每个\\n).</p>\n<p>const fs = require(‘fs’);<br>const readFileLines = filename =&gt; fs.readFileSync(filename).toString(‘UTF8’).split(‘\\n’);<br>/*<br>contents of test.txt :<br>  line1<br>  line2<br>  line3</p>\n<hr>\n<p>let arr = readFileLines(‘test.txt’)<br>console.log(arr) // -&gt; [‘line1’, ‘line2’, ‘line3’]<br>*/<br>对象<br>cleanObj<br>移除从 JSON 对象指定的属性之外的任何特性。</p>\n<p>使用Object.keys()方法可以遍历给定的 json 对象并删除在给定数组中不是included 的键。另外, 如果给它一个特殊的键 (childIndicator), 它将在里面深入搜索, 并将函数应用于内部对象。</p>\n<p>const cleanObj = (obj, keysToKeep = [], childIndicator) =&gt; {<br>Object.keys(obj).forEach(key =&gt; {<br>if (key === childIndicator) {<br>cleanObj(obj[key], keysToKeep, childIndicator);<br>} else if (!keysToKeep.includes(key)) {<br>delete obj[key];<br>}<br>})<br>}<br>/<em><br>  const testObj = {a: 1, b: 2, children: {a: 1, b: 2}}<br>  cleanObj(testObj, [“a”],”children”)<br>  console.log(testObj)// { a: 1, children : { a: 1}}\n</em>/<br>objectFromPairs<br>从给定的键值对创建对象。</p>\n<p>使用Array.reduce()创建和组合键值对。</p>\n<p>const objectFromPairs = arr =&gt; arr.reduce((a, v) =&gt; (a[v[0]] = v[1], a), {});<br>// objectFromPairs([[‘a’,1],[‘b’,2]]) -&gt; {a: 1, b: 2}<br>objectToPairs<br>从对象创建键值对数组的数组。</p>\n<p>使用Object.keys()和Array.map()循环访问对象的键并生成具有键值对的数组。</p>\n<p>const objectToPairs = obj =&gt; Object.keys(obj).map(k =&gt; [k, obj[k]]);<br>// objectToPairs({a: 1, b: 2}) -&gt; [[‘a’,1],[‘b’,2]])<br>shallowClone<br>创建对象的浅表克隆。</p>\n<p>使用Object.assign()和一个空对象 ({}) 创建原始的浅克隆。</p>\n<p>const shallowClone = obj =&gt; Object.assign({}, obj);<br>/<em><br>const a = { x: true, y: 1 };<br>const b = shallowClone(a);<br>a === b -&gt; false\n</em>/<br>truthCheckCollection<br>检查谓词 (第二个参数) 是否 truthy 集合的所有元素 (第一个参数)。</p>\n<p>使用Array.every()检查每个传递的对象是否具有指定的属性, 以及是否返回 truthy 值。</p>\n<p>truthCheckCollection = (collection, pre) =&gt; (collection.every(obj =&gt; obj[pre]));<br>// truthCheckCollection([{“user”: “Tinky-Winky”, “sex”: “male”}, {“user”: “Dipsy”, “sex”: “male”}], “sex”) -&gt; true<br>字符串<br>anagrams<br>生成字符串的所有字谜 (包含重复项)。</p>\n<p>使用递归。对于给定字符串中的每个字母, 为其其余字母创建所有部分字谜。使用Array.map()将字母与每个部分变位词组合在一起, 然后将Array.reduce()组合在一个数组中的所有字谜。基本情况为字符串length等于2或1.</p>\n<p>const anagrams = str =&gt; {<br>if (str.length &lt;= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str];<br>return str.split(‘’).reduce((acc, letter, i) =&gt;<br>acc.concat(anagrams(str.slice(0, i) + str.slice(i + 1)).map(val =&gt; letter + val)), []);<br>};<br>// anagrams(‘abc’) -&gt; [‘abc’,’acb’,’bac’,’bca’,’cab’,’cba’]<br>Capitalize<br>将字符串的第一个字母大写。</p>\n<p>使用 destructuring 和toUpperCase()可将第一个字母、…rest用于获取第一个字母之后的字符数组, 然后是Array.join(”)以使其成为字符串。省略lowerRest参数以保持字符串的其余部分不变, 或将其设置为true以转换为小写。</p>\n<p>const capitalize = ([first,…rest], lowerRest = false) =&gt;<br>first.toUpperCase() + (lowerRest ? rest.join(‘’).toLowerCase() : rest.join(‘’));<br>// capitalize(‘myName’) -&gt; ‘MyName’<br>// capitalize(‘myName’, true) -&gt; ‘Myname’<br>capitalizeEveryWord<br>将字符串中每个单词的首字母大写。</p>\n<p>使用replace()匹配每个单词和toUpperCase()的第一个字符以将其大写。</p>\n<p>const capitalizeEveryWord = str =&gt; str.replace(/\\b[a-z]/g, char =&gt; char.toUpperCase());<br>// capitalizeEveryWord(‘hello world!’) -&gt; ‘Hello World!’<br>escapeRegExp<br>转义要在正则表达式中使用的字符串。</p>\n<p>使用replace()可转义特殊字符。</p>\n<p>const escapeRegExp = str =&gt; str.replace(/[.*+?^${}()|[]\\]/g, ‘\\$&amp;’);<br>// escapeRegExp(‘(test)’) -&gt; \\(test\\)<br>fromCamelCase<br>从匹配转换字符串。</p>\n<p>使用replace()可删除下划线、连字符和空格, 并将单词转换为匹配。省略第二个参数以使用默认分隔符_.</p>\n<p>const fromCamelCase = (str, separator = ‘<em>‘) =&gt;<br>str.replace(/([a-z\\d])([A-Z])/g, ‘$1’ + separator + ‘$2’)<br>.replace(/([A-Z]+)([A-Z][a-z\\d]+)/g, ‘$1’ + separator + ‘$2’).toLowerCase();<br>// fromCamelCase(‘someDatabaseFieldName’, ‘ ‘) -&gt; ‘some database field name’<br>// fromCamelCase(‘someLabelThatNeedsToBeCamelized’, ‘-‘) -&gt; ‘some-label-that-needs-to-be-camelized’<br>// fromCamelCase(‘someJavascriptProperty’, ‘</em>‘) -&gt; ‘some_javascript_property’<br>reverseString<br>反转字符串。</p>\n<p>使用数组 destructuring 和Array.reverse()可反转字符串中字符的顺序。使用join(”)组合字符以获取字符串.</p>\n<p>const reverseString = str =&gt; […str].reverse().join(‘’);<br>// reverseString(‘foobar’) -&gt; ‘raboof’<br>sortCharactersInString<br>按字母顺序对字符串中的字符进行排序。</p>\n<p>使用split(”)、Array.sort()利用localeCompare()重新组合使用join(”).</p>\n<p>const sortCharactersInString = str =&gt;<br>str.split(‘’).sort((a, b) =&gt; a.localeCompare(b)).join(‘’);<br>// sortCharactersInString(‘cabbage’) -&gt; ‘aabbceg’<br>toCamelCase<br>将字符串转换为匹配。</p>\n<p>使用replace()可删除下划线、连字符和空格, 并将单词转换为匹配。</p>\n<p>const toCamelCase = str =&gt;<br>str.replace(/^([A-Z])|[\\s-_]+(\\w)/g, (match, p1, p2, offset) =&gt;  p2 ? p2.toUpperCase() : p1.toLowerCase());<br>// toCamelCase(“some_database_field_name”) -&gt; ‘someDatabaseFieldName’<br>// toCamelCase(“Some label that needs to be camelized”) -&gt; ‘someLabelThatNeedsToBeCamelized’<br>// toCamelCase(“some-javascript-property”) -&gt; ‘someJavascriptProperty’<br>// toCamelCase(“some-mixed_string with spaces_underscores-and-hyphens”) -&gt; ‘someMixedStringWithSpacesUnderscoresAndHyphens’<br>truncateString<br>将字符串截断为指定长度。</p>\n<p>确定字符串的length是否大于num。将截断的字符串返回到所需的长度, 并将…追加到末尾或原始字符串。</p>\n<p>const truncateString = (str, num) =&gt;<br>str.length &gt; num ? str.slice(0, num &gt; 3 ? num - 3 : num) + ‘…’ : str;<br>// truncateString(‘boomerang’, 7) -&gt; ‘boom…’<br>实用<br>coalesce<br>返回第一个非空/未定义参数。</p>\n<p>使用Array.find()返回第一个非null/undefined的参数。</p>\n<p>const coalesce = (…args) =&gt; args.find(<em> =&gt; ![undefined, null].includes(</em>))<br>// coalesce(null,undefined,””,NaN, “Waldo”) -&gt; “”<br>coalesceFactory<br>返回自定义的联合函数, 返回从提供的参数验证函数返回true的第一个参数。</p>\n<p>使用Array.find()返回从提供的参数验证函数返回true的第一个参数。</p>\n<p>const coalesceFactory = valid =&gt; (…args) =&gt; args.find(valid);<br>// const customCoalesce = coalesceFactory(<em> =&gt; ![null, undefined, “”, NaN].includes(</em>))<br>// customCoalesce(undefined, null, NaN, “”, “Waldo”) //-&gt; “Waldo”<br>extendHex<br>将3位色码扩展为6位色码。</p>\n<p>使用Array.map()、split()和Array.join()来加入映射数组, 将3位的 RGB notated 十六进制 color-code 转换为6位数字形式。Array.slice()用于从字符串启动中删除#, 因为它添加了一次。</p>\n<p>const extendHex = shortHex =&gt;<br>‘#’ + shortHex.slice(shortHex.startsWith(‘#’) ? 1 : 0).split(‘’).map(x =&gt; x+x).join(‘’)<br>// extendHex(‘#03f’) -&gt; ‘#0033ff’<br>// extendHex(‘05a’) -&gt; ‘#0055aa’<br>gettype<br>返回值的本机类型。</p>\n<p>如果值未定义或为 null, 则返回小写的构造函数名称、”未定义” 或 “null”</p>\n<p>const getType = v =&gt;<br>v === undefined ? ‘undefined’ : v === null ? ‘null’ : v.constructor.name.toLowerCase();<br>// getType(new Set([1,2,3])) -&gt; “set”<br>hexToRGB<br>将 colorcode 转换为rgb()字符串。</p>\n<p>使用按位右运算符和掩码位与&amp;(and) 运算符将十六进制颜色代码 (前缀为#) 转换为具有 RGB 值的字符串。如果它是一个3位数的 colorcode, 那么用 extendHex () 函数 (ref.extendHex代码段) 扩展的6位 colorcode 进行相同的处理</p>\n<p>const hexToRgb = hex =&gt; {<br>const extendHex = shortHex =&gt;<br>‘#’ + shortHex.slice(shortHex.startsWith(‘#’) ? 1 : 0).split(‘’).map(x =&gt; x+x).join(‘’);<br>const extendedHex = hex.slice(hex.startsWith(‘#’) ? 1 : 0).length === 3 ? extendHex(hex) : hex;<br>return <code>rgb(${parseInt(extendedHex.slice(1), 16) &gt;&gt; 16}, ${(parseInt(extendedHex.slice(1), 16) &amp; 0x00ff00) &gt;&gt; 8}, ${parseInt(extendedHex.slice(1), 16) &amp; 0x0000ff})</code>;<br>}<br>// hexToRgb(‘#27ae60’) -&gt; ‘rgb(39, 174, 96)’<br>// hexToRgb(‘#acd’) -&gt; ‘rgb(170, 204, 221)’<br>isArray<br>检查给定参数是否为数组。</p>\n<p>使用Array.isArray()检查某个值是否属于数组。</p>\n<p>const isArray = val =&gt; !!val &amp;&amp; Array.isArray(val);<br>// isArray(null) -&gt; false<br>// isArray([1]) -&gt; true<br>isBoolean<br>检查给定的参数是否为本机布尔元素。</p>\n<p>使用typeof检查某个值是否被归类为布尔基元。</p>\n<p>const isBoolean = val =&gt; typeof val === ‘boolean’;<br>// isBoolean(null) -&gt; false<br>// isBoolean(false) -&gt; true<br>isFunction<br>检查给定参数是否为函数。</p>\n<p>使用typeof检查某个值是否被归类为函数基元。</p>\n<p>const isFunction = val =&gt; val &amp;&amp; typeof val === ‘function’;<br>// isFunction(‘x’) -&gt; false<br>// isFunction(x =&gt; x) -&gt; true<br>isNumber<br>检查给定参数是否为数字。</p>\n<p>使用typeof检查某个值是否归类为数字基元。</p>\n<p>const isNumber = val =&gt; typeof val === ‘number’;<br>// isNumber(‘1’) -&gt; false<br>// isNumber(1) -&gt; true<br>isString<br>检查给定参数是否为字符串。</p>\n<p>使用typeof检查某个值是否属于字符串基元。</p>\n<p>const isString = val =&gt; typeof val === ‘string’;<br>// isString(10) -&gt; false<br>// isString(‘10’) -&gt; true<br>isSymbol<br>检查给定参数是否为符号。</p>\n<p>使用typeof检查某个值是否被归类为符号基元。</p>\n<p>const isSymbol = val =&gt; typeof val === ‘symbol’;<br>// isSymbol(‘x’) -&gt; false<br>// isSymbol(Symbol(‘x’)) -&gt; true<br>RGBToHex<br>将 RGB 组件的值转换为 colorcode。</p>\n<p>使用按位左移位运算符 (&lt;&lt;) 和toString(16)将给定的 RGB 参数转换为十六进制字符串, 然后padStart(6,’0′)以获取6位十六进制值。</p>\n<p>const RGBToHex = (r, g, b) =&gt; ((r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).padStart(6, ‘0’);<br>// RGBToHex(255, 165, 1) -&gt; ‘ffa501’<br>timeTaken<br>测量执行函数所用的时间。</p>\n<p>使用console.time()和console.timeEnd()来测量开始和结束时间之间的差异, 以确定回调执行所用的时间。</p>\n<p>const timeTaken = callback =&gt; {<br>console.time(‘timeTaken’);  const r = callback();<br>console.timeEnd(‘timeTaken’);  return r;<br>};<br>// timeTaken(() =&gt; Math.pow(2, 10)) -&gt; 1024<br>// (logged): timeTaken: 0.02099609375ms<br>toOrdinalSuffix<br>将序号后缀添加到数字。</p>\n<p>使用模数运算符 (%) 查找单个和十位数字的值。查找匹配的序号模式数字。如果在青少年模式中发现数字, 请使用青少年序号。</p>\n<p>const toOrdinalSuffix = num =&gt; {<br>const int = parseInt(num), digits = [(int % 10), (int % 100)],<br>ordinals = [‘st’, ‘nd’, ‘rd’, ‘th’], oPattern = [1, 2, 3, 4],<br>tPattern = [11, 12, 13, 14, 15, 16, 17, 18, 19];<br>return oPattern.includes(digits[0]) &amp;&amp; !tPattern.includes(digits[1]) ? int + ordinals[digits[0] - 1] : int + ordinals[3];<br>};<br>// toOrdinalSuffix(“123”) -&gt; “123rd”<br>UUIDGenerator<br>生成 UUID。</p>\n<p>使用cryptoAPI 生成 UUID, 符合RFC4122版本4。</p>\n<p>const UUIDGenerator = () =&gt;<br>([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =&gt;<br>(c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16)<br>);<br>// UUIDGenerator() -&gt; ‘7982fcfe-5721-4632-bede-6000885be57d’<br>validateEmail<br>如果给定的字符串是有效的电子邮件, 则返回true, 否则为false。</p>\n<p>使用正则表达式检查电子邮件是否有效。如果电子邮件有效, 则返回 true, 如果没有, 则返回false。</p>\n<p>const validateEmail = str =&gt;<br>  /^(([^&lt;&gt;()[]\\.,;:\\s@”]+(.[^&lt;&gt;()[]\\.,;:\\s@”]+)*)|(“.+”))@(([[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}])|(([a-zA-Z-0-9]+.)+[a-zA-Z]{2,}))$/.test(str);<br>// validateEmail(mymail@gmail.com) -&gt; true<br>validateNumber<br>如果给定值为数字, 则返回true, 否则为false。</p>\n<p>将!isNaN与parseFloat()结合使用, 以检查参数是否为数字。使用isFinite()检查数字是否是有限的。使用Number()检查强制是否保持。</p>\n<p>const validateNumber = n =&gt; !isNaN(parseFloat(n)) &amp;&amp; isFinite(n) &amp;&amp; Number(n) == n;<br>// validateNumber(‘10’) -&gt; true<br>感谢作者分享了大量有用的Javascript片段,本文为中文版翻译，下面一起来看看有哪些精彩的JavaScript代码值得收藏。</p>\n<p>原文：<a href=\"https://github.com/Chalarangelo/30-seconds-of-code\" target=\"_blank\" rel=\"noopener\">https://github.com/Chalarangelo/30-seconds-of-code</a></p>\n<p>作者：Chalarangelo</p>\n<p>翻译：<a href=\"http://caibaojian.com/30-seconds-of-code.html\" target=\"_blank\" rel=\"noopener\">http://caibaojian.com/30-seconds-of-code.html</a></p>\n<p>译者：蔡宝坚</p>\n<p>本文翻译为前端开发博客所有，如有需要转载，请详细注明以上信息。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>数组<br>arrayMax<br>返回数组中的最大值。</p>\n<p>将Math.max()与扩展运算符 (…) 结合使用以获取数组中的最大值。</p>\n<p>const arrayMax = arr =&gt; Math.max(…arr);<br>// arrayMax([10, 1, 5]) -&gt; 10<br>arrayMin<br>返回数组中的最小值。</p>\n<p>将Math.min()与扩展运算符 (…) 结合使用以获取数组中的最小值。</p>\n<p>const arrayMin = arr =&gt; Math.min(…arr);<br>// arrayMin([10, 1, 5]) -&gt; 1<br>chunk<br>将数组块划分为指定大小的较小数组。</p>\n<p>使用Array.from()创建新的数组, 这符合将生成的区块数。使用Array.slice()将新数组的每个元素映射到size长度的区块。如果原始数组不能均匀拆分, 则最终的块将包含剩余的元素。</p>\n<p>const chunk = (arr, size) =&gt;<br>Array.from({length: Math.ceil(arr.length / size)}, (v, i) =&gt; arr.slice(i <em> size, i </em> size + size));<br>// chunk([1,2,3,4,5], 2) -&gt; [[1,2],[3,4],[5]]<br>compact<br>从数组中移除 falsey 值。</p>\n<p>使用Array.filter()筛选出 falsey 值 (false、null、0、””、undefined和NaN).</p>\n<p>const compact = (arr) =&gt; arr.filter(Boolean);<br>// compact([0, 1, false, 2, ‘’, 3, ‘a’, ‘e’*23, NaN, ‘s’, 34]) -&gt; [ 1, 2, 3, ‘a’, ‘s’, 34 ]<br>countOccurrences<br>计算数组中值的出现次数。</p>\n<p>使用Array.reduce()在每次遇到数组中的特定值时递增计数器。</p>\n<p>const countOccurrences = (arr, value) =&gt; arr.reduce((a, v) =&gt; v === value ? a + 1 : a + 0, 0);<br>// countOccurrences([1,1,2,1,2,3], 1) -&gt; 3<br>deepFlatten<br>深拼合数组。</p>\n<p>使用递归。使用Array.concat()与空数组 ([]) 和跨页运算符 (…) 来拼合数组。递归拼合作为数组的每个元素。</p>\n<p>const deepFlatten = arr =&gt; [].concat(…arr.map(v =&gt; Array.isArray(v) ? deepFlatten(v) : v));<br>// deepFlatten([1,[2],[[3],4],5]) -&gt; [1,2,3,4,5]<br>difference<br>返回两个数组之间的差异。</p>\n<p>从b创建Set, 然后使用Array.filter() on 只保留a b中不包含的值.</p>\n<p>const difference = (a, b) =&gt; { const s = new Set(b); return a.filter(x =&gt; !s.has(x)); };<br>// difference([1,2,3], [1,2,4]) -&gt; [3]<br>distinctValuesOfArray<br>返回数组的所有不同值。</p>\n<p>使用 ES6 Set和…rest运算符放弃所有重复的值。</p>\n<p>const distinctValuesOfArray = arr =&gt; […new Set(arr)];<br>// distinctValuesOfArray([1,2,2,3,4,4,5]) -&gt; [1,2,3,4,5]<br>dropElements<br>移除数组中的元素, 直到传递的函数返回true。返回数组中的其余元素。 在数组中循环, 使用Array.shift()将数组的第一个元素除去, 直到函数的返回值为true。返回其余元素。</p>\n<p>const dropElements = (arr, func) =&gt; {<br>while (arr.length &gt; 0 &amp;&amp; !func(arr[0])) arr.shift();<br>return arr;<br>};<br>// dropElements([1, 2, 3, 4], n =&gt; n &gt;= 3) -&gt; [3,4]<br>everyNth<br>返回数组中的每个第 n 个元素。</p>\n<p>使用Array.filter()创建一个包含给定数组的每个第 n 个元素的新数组。</p>\n<p>const everyNth = (arr, nth) =&gt; arr.filter((e, i) =&gt; i % nth === 0);<br>// everyNth([1,2,3,4,5,6], 2) -&gt; [ 1, 3, 5 ]<br>filterNonUnique<br>筛选出数组中的非唯一值。</p>\n<p>对于只包含唯一值的数组, 请使用Array.filter()。</p>\n<p>const filterNonUnique = arr =&gt; arr.filter(i =&gt; arr.indexOf(i) === arr.lastIndexOf(i));<br>// filterNonUnique([1,2,2,3,4,4,5]) -&gt; [1,3,5]<br>flatten<br>拼合数组。</p>\n<p>使用Array.reduce()获取数组中的所有元素和concat()以拼合它们。</p>\n<p>const flatten = arr =&gt; arr.reduce((a, v) =&gt; a.concat(v), []);<br>// flatten([1,[2],3,4]) -&gt; [1,2,3,4]<br>flattenDepth<br>将数组向上拼合到指定深度。</p>\n<p>使用递归, 递减depth, 每层深度为1。使用Array.reduce()和Array.concat()来合并元素或数组。基本情况下, 对于等于1的depth停止递归。省略第二个元素,depth仅拼合到1的深度 (单个拼合)。</p>\n<p>const flattenDepth = (arr, depth = 1) =&gt;<br>depth != 1 ? arr.reduce((a, v) =&gt; a.concat(Array.isArray(v) ? flattenDepth(v, depth - 1) : v), [])<br>: arr.reduce((a, v) =&gt; a.concat(v), []);<br>// flattenDepth([1,[2],[[[3],4],5]], 2) -&gt; [1,2,[3],4,5]<br>groupby<br>根据给定函数对数组元素进行分组。</p>\n<p>使用Array.map()将数组的值映射到函数或属性名。使用Array.reduce()创建一个对象, 其中的键是从映射的结果生成的。</p>\n<p>const groupBy = (arr, func) =&gt;<br>arr.map(typeof func === ‘function’ ? func : val =&gt; val[func])<br>.reduce((acc, val, i) =&gt; { acc[val] = (acc[val] || []).concat(arr[i]); return acc; }, {});<br>// groupBy([6.1, 4.2, 6.3], Math.floor) -&gt; {4: [4.2], 6: [6.1, 6.3]}<br>// groupBy([‘one’, ‘two’, ‘three’], ‘length’) -&gt; {3: [‘one’, ‘two’], 5: [‘three’]}<br>head<br>返回列表的头。</p>\n<p>使用arr[0]可返回传递的数组的第一个元素。</p>\n<p>const head = arr =&gt; arr[0];<br>// head([1,2,3]) -&gt; 1<br>initial<br>返回除最后一个数组之外的所有元素。</p>\n<p>使用 “arr.slice(0,-1)” 返回数组的最后一个元素。</p>\n<p>const initial = arr =&gt; arr.slice(0, -1);<br>// initial([1,2,3]) -&gt; [1,2]<br>initializeArrayWithRange<br>初始化包含指定范围内的数字的数组。</p>\n<p>使用Array(end-start)创建所需长度的数组Array.map()以填充区域中所需的值。可以省略start以使用默认值0.</p>\n<p>const initializeArrayWithRange = (end, start = 0) =&gt;<br>Array.from({ length: end - start }).map((v, i) =&gt; i + start);<br>// initializeArrayWithRange(5) -&gt; [0,1,2,3,4]<br>initializeArrayWithValues<br>初始化并填充具有指定值的数组。</p>\n<p>使用Array(n)创建所需长度的数组,fill(v)以填充所需的值。可以省略value以使用默认值0.</p>\n<p>const initializeArrayWithValues = (n, value = 0) =&gt; Array(n).fill(value);<br>// initializeArrayWithValues(5, 2) -&gt; [2,2,2,2,2]<br>intersection<br>返回两个数组中存在的元素的列表。</p>\n<p>从b创建Set, 然后使用Array.filter()on a只保留b中包含的值.</p>\n<p>const intersection = (a, b) =&gt; { const s = new Set(b); return a.filter(x =&gt; s.has(x)); };<br>// intersection([1,2,3], [4,3,2]) -&gt; [2,3]<br>last<br>返回数组中的最后一个元素。</p>\n<p>使用arr.length – 1可计算给定数组的最后一个元素的索引并返回它。</p>\n<p>const last = arr =&gt; arr[arr.length - 1];<br>// last([1,2,3]) -&gt; 3<br>mapObject<br>使用函数将数组的值映射到对象, 其中键值对由原始值作为键和映射值组成。</p>\n<p>使用匿名内部函数范围来声明未定义的内存空间, 使用闭包来存储返回值。使用新的Array可将该数组与函数的映射放在其数据集上, 而逗号运算符返回第二个步骤, 而不需要从一个上下文移动到另一个环境 (由于关闭和操作顺序)。</p>\n<p>const mapObject = (arr, fn) =&gt;<br>(a =&gt; (a = [arr, arr.map(fn)], a[0].reduce( (acc,val,ind) =&gt; (acc[val] = a[1][ind], acc), {}) )) ( );<br>/<em><br>const squareIt = arr =&gt; mapObject(arr, a =&gt; a</em>a)<br>squareIt([1,2,3]) // { 1: 1, 2: 4, 3: 9 }<br>*/<br>nthElement<br>返回数组的第 n 个元素。</p>\n<p>使用Array.slice()可获取包含第 n 个元素的数组。如果索引超出界限, 则返回[]。省略第二个参数n, 以获取数组的第一个元素。</p>\n<p>const nthElement = (arr, n=0) =&gt; (n&gt;0? arr.slice(n,n+1) : arr.slice(n))[0];<br>// nthElement([‘a’,’b’,’c’],1) -&gt; ‘b’<br>// nthElement([‘a’,’b’,’b’],-3) -&gt; ‘a’<br>pick<br>从对象中选取对应于给定键的键值对。</p>\n<p>使用Array.reduce()将筛选/选取的密钥转换回具有相应键值对的对象 (如果在 obj 中存在该键)。</p>\n<p>const pick = (obj, arr) =&gt;<br>arr.reduce((acc, curr) =&gt; (curr in obj &amp;&amp; (acc[curr] = obj[curr]), acc), {});<br>// pick({ ‘a’: 1, ‘b’: ‘2’, ‘c’: 3 }, [‘a’, ‘c’]) -&gt; { ‘a’: 1, ‘c’: 3 }<br>pull<br>对原始数组进行变异, 以筛选出指定的值。</p>\n<p>使用Array.filter()和Array.includes()来拉出不需要的值。使用Array.length = 0可将传入的数组中的长度重置为零, 并将其设置为Array.push(), 以便仅使用所提取的值填充它。</p>\n<p>const pull = (arr, …args) =&gt; {<br>let pulled = arr.filter((v, i) =&gt; !args.includes(v));<br>arr.length = 0; pulled.forEach(v =&gt; arr.push(v));<br>};<br>// let myArray = [‘a’, ‘b’, ‘c’, ‘a’, ‘b’, ‘c’];<br>// pull(myArray, ‘a’, ‘c’);<br>// console.log(myArray) -&gt; [ ‘b’, ‘b’ ]<br>remove<br>从数组中移除给定函数返回false的元素. 使用Array.filter()查找返回 truthy 值的数组元素和Array.reduce()以使用Array.splice()删除元素。使用三参数 (func value, index, array调用函数).</p>\n<p>const remove = (arr, func) =&gt;<br>Array.isArray(arr) ? arr.filter(func).reduce((acc, val) =&gt; {<br>arr.splice(arr.indexOf(val), 1); return acc.concat(val);<br>}, [])<br>: [];<br>// remove([1, 2, 3, 4], n =&gt; n % 2 == 0) -&gt; [2, 4]<br>sample<br>返回数组中的随机元素。</p>\n<p>使用Math.random()生成一个随机数, 将它与length相乘, 并使用数学将其舍入到最接近的整数Math.floor()。此方法也适用于字符串。</p>\n<p>const sample = arr =&gt; arr[Math.floor(Math.random() * arr.length)];<br>// sample([3, 7, 9, 11]) -&gt; 9<br>shuffle<br>随机数组值的顺序。</p>\n<p>使用Array.sort()可在比较器中使用Math.random()重新排序元素。</p>\n<p>const shuffle = arr =&gt; arr.sort(() =&gt; Math.random() - 0.5);<br>// shuffle([1,2,3]) -&gt; [2,3,1]<br>similarity<br>返回两个数组中都显示的元素的数组。</p>\n<p>使用filter()可删除不属于values的值, 使用includes()确定.</p>\n<p>const similarity = (arr, values) =&gt; arr.filter(v =&gt; values.includes(v));<br>// similarity([1,2,3], [1,2,4]) -&gt; [1,2]<br>symmetricDifference<br>返回两个数组之间的对称差。</p>\n<p>从每个数组创建一个Set, 然后对它们中的每一个都使用Array.filter(), 以便只保留其他值中不包含的数值。</p>\n<p>const symmetricDifference = (a, b) =&gt; {<br>const sA = new Set(a), sB = new Set(b);<br>return […a.filter(x =&gt; !sB.has(x)), …b.filter(x =&gt; !sA.has(x))];<br>}<br>// symmetricDifference([1,2,3], [1,2,4]) -&gt; [3,4]<br>tail<br>返回数组中的所有元素, 除第一个。</p>\n<p>如果数组的length大于1, 则返回arr.slice(1), 否则返回整个数组。</p>\n<p>const tail = arr =&gt; arr.length &gt; 1 ? arr.slice(1) : arr;<br>// tail([1,2,3]) -&gt; [2,3]<br>// tail([1]) -&gt; [1]<br>take<br>返回一个数组, 其中 n 个元素从开始处移除。</p>\n<p>使用Array.slice()创建数组的切片, 其中包含从开始处取出的n元素。</p>\n<p>const take = (arr, n = 1) =&gt; arr.slice(0, n);<br>// take([1, 2, 3], 5) -&gt; [1, 2, 3]<br>// take([1, 2, 3], 0) -&gt; []<br>takeRight<br>返回一个数组, 其中 n 个元素从末尾移除。</p>\n<p>使用Array.slice()创建数组的切片, 其中包含从末尾取出的n元素。</p>\n<p>const takeRight = (arr, n = 1) =&gt; arr.slice(arr.length - n, arr.length);<br>// takeRight([1, 2, 3], 2) -&gt; [ 2, 3 ]<br>// takeRight([1, 2, 3]) -&gt; [3]<br>union<br>返回在两个数组中的任意一个中存在的每个元素。</p>\n<p>创建一个Set, 其中包含a和b的所有值, 并将其转换为数组。</p>\n<p>const union = (a, b) =&gt; Array.from(new Set([…a, …b]));<br>// union([1,2,3], [4,3,2]) -&gt; [1,2,3,4]<br>without<br>筛选出数组中具有指定值之一的元素。</p>\n<p>使用Array.filter()创建不包括的数组 (使用!Array.includes()) 所有给定值。</p>\n<p>const without = (arr, …args) =&gt; arr.filter(v =&gt; !args.includes(v));<br>// without([2, 1, 2, 3], 1, 2) -&gt; [3]<br>zip<br>创建基于原始数组中的位置分组的元素数组。</p>\n<p>使用Math.max.apply()获取参数中最长的数组。创建一个以该长度为返回值的数组, 并使用 map 函数创建一个分组元素的数组Array.from()如果参数数组的长度不同, 则在未找到任何值的情况下使用undefined。</p>\n<p>const zip = (…arrays) =&gt; {<br>const maxLength = Math.max(…arrays.map(x =&gt; x.length));<br>return Array.from({length: maxLength}).map((<em>, i) =&gt; {<br>return Array.from({length: arrays.length}, (</em>, k) =&gt; arrays[k][i]);<br>})<br>}<br>//zip([‘a’, ‘b’], [1, 2], [true, false]); -&gt; [[‘a’, 1, true], [‘b’, 2, false]]<br>//zip([‘a’], [1, 2], [true, false]); -&gt; [[‘a’, 1, true], [undefined, 2, false]]<br>浏览器<br>bottomVisible<br>如果页的底部可见, 则返回true, 否则为false。</p>\n<p>使用scrollY、scrollHeight和clientHeight来确定页面底部是否可见。</p>\n<p>const bottomVisible = () =&gt;<br>document.documentElement.clientHeight + window.scrollY &gt;= document.documentElement.scrollHeight || document.documentElement.clientHeight;<br>// bottomVisible() -&gt; true<br>currentURL<br>返回当前 URL。</p>\n<p>使用window.location.href获取当前 URL。</p>\n<p>const currentURL = () =&gt; window.location.href;<br>// currentUrl() -&gt; ‘<a href=\"https://google.com\" target=\"_blank\" rel=\"noopener\">https://google.com</a>‘<br>elementIsVisibleInViewport<br>如果指定的元素在视区中可见, 则返回true, 否则为false。</p>\n<p>使用Element.getBoundingClientRect()和window.inner(Width|Height)值以确定给定元素在视区中是否可见。省略第二个参数以确定该元素是否完全可见, 或指定true以确定它是否部分可见。</p>\n<p>const elementIsVisibleInViewport = (el, partiallyVisible = false) =&gt; {<br>const { top, left, bottom, right } = el.getBoundingClientRect();<br>return partiallyVisible<br>? ((top &gt; 0 &amp;&amp; top &lt; innerHeight) || (bottom &gt; 0 &amp;&amp; bottom &lt; innerHeight)) &amp;&amp;<br>((left &gt; 0 &amp;&amp; left &lt; innerWidth) || (right &gt; 0 &amp;&amp; right &lt; innerWidth))<br>: top &gt;= 0 &amp;&amp; left &gt;= 0 &amp;&amp; bottom &lt;= innerHeight &amp;&amp; right &lt;= innerWidth;<br>};<br>// e.g. 100x100 viewport and a 10x10px element at position {top: -1, left: 0, bottom: 9, right: 10}<br>// elementIsVisibleInViewport(el) -&gt; false (not fully visible)<br>// elementIsVisibleInViewport(el, true) -&gt; true (partially visible)<br>getScrollPosition<br>返回当前页的滚动位置。</p>\n<p>如果已定义, 则使用pageXOffset和pageYOffset, 否则scrollLeft和scrollTop。可以省略el以使用window的默认值.</p>\n<p>const getScrollPosition = (el = window) =&gt;<br>({x: (el.pageXOffset !== undefined) ? el.pageXOffset : el.scrollLeft,<br>y: (el.pageYOffset !== undefined) ? el.pageYOffset : el.scrollTop});<br>// getScrollPosition() -&gt; {x: 0, y: 200}<br>getURLParameters<br>返回一个包含当前 URL 参数的对象。</p>\n<p>使用match()与适当的正则表达式来获取所有键值对,Array.reduce()可将它们映射并合并到单个对象中。将location.search作为要应用于当前url的参数传递.</p>\n<p>const getURLParameters = url =&gt;<br>url.match(/([^?=&amp;]+)(=([^&amp;]*))/g).reduce(<br>(a, v) =&gt; (a[v.slice(0, v.indexOf(‘=’))] = v.slice(v.indexOf(‘=’) + 1), a), {}<br>);<br>// getURLParameters(‘<a href=\"http://url.com/page?name=Adam&amp;surname=Smith\" target=\"_blank\" rel=\"noopener\">http://url.com/page?name=Adam&amp;surname=Smith</a>‘) -&gt; {name: ‘Adam’, surname: ‘Smith’}<br>redirect<br>重定向到指定的 URL。</p>\n<p>使用window.location.href或window.location.replace()重定向到url。传递第二个参数以模拟链接单击 (true-默认值) 或 HTTP 重定向 (false).</p>\n<p>const redirect = (url, asLink = true) =&gt;<br>asLink ? window.location.href = url : window.location.replace(url);<br>// redirect(‘<a href=\"https://google.com\" target=\"_blank\" rel=\"noopener\">https://google.com</a>‘)<br>scrollToTop<br>平滑滚动到页面顶部。</p>\n<p>使用document.documentElement.scrollTop或document.body.scrollTop从顶部获取距离。从顶部的距离的一小部分滚动。使用window.requestAnimationFrame()对滚动进行动画处理。</p>\n<p>const scrollToTop = () =&gt; {<br>const c = document.documentElement.scrollTop || document.body.scrollTop;<br>if (c &gt; 0) {<br>window.requestAnimationFrame(scrollToTop);<br>window.scrollTo(0, c - c / 8);<br>}<br>};<br>// scrollToTop()<br>日期<br>getDaysDiffBetweenDates<br>返回两个日期之间的差异 (以天为值)。</p>\n<p>计算Date对象之间的差异 (以天为)。</p>\n<p>const getDaysDiffBetweenDates = (dateInitial, dateFinal) =&gt; (dateFinal - dateInitial) / (1000 <em> 3600 </em> 24);<br>// getDaysDiffBetweenDates(new Date(“2017-12-13”), new Date(“2017-12-22”)) -&gt; 9<br>JSONToDate<br>将 JSON 对象转换为日期。</p>\n<p>使用Date(), 将 JSON 格式的日期转换为可读格式 (dd/mm/yyyy日)).</p>\n<p>const JSONToDate = arr =&gt; {<br>const dt = new Date(parseInt(arr.toString().substr(6)));<br>return <code>${ dt.getDate() }/${ dt.getMonth() + 1 }/${ dt.getFullYear() }</code><br>};<br>// JSONToDate(/Date(1489525200000)/) -&gt; “14/3/2017”<br>toEnglishDate<br>将日期从美国格式转换为英文格式。</p>\n<p>使用Date.toISOString()、split(‘T’)和replace()将日期从美式格式转换为英文格式。如果传递的时间不能转换为日期, 则抛出错误。</p>\n<p>const toEnglishDate  = (time) =&gt;<br>{try{return new Date(time).toISOString().split(‘T’)[0].replace(/-/g, ‘/‘)}catch(e){return}};<br>// toEnglishDate(‘09/21/2010’) -&gt; ‘21/09/2010’<br>功能<br>chainAsync<br>链异步函数。</p>\n<p>循环遍历包含异步事件的函数数组, 当每个异步事件完成时调用next。</p>\n<p>const chainAsync = fns =&gt; { let curr = 0; const next = () =&gt; fns<a href=\"next\">curr++</a>; next(); };<br>/*<br>chainAsync([<br>  next =&gt; { console.log(‘0 seconds’); setTimeout(next, 1000); },<br>  next =&gt; { console.log(‘1 second’);  setTimeout(next, 1000); },<br>  next =&gt; { console.log(‘2 seconds’); }<br>])<br>compose<br>执行从右向左的函数组合。</p>\n<p>使用Array.reduce()执行从右向左的函数组合。最后一个 (最右边) 的函数可以接受一个或多个参数;其余的函数必须是一元的。</p>\n<p>const compose = (…fns) =&gt; fns.reduce((f, g) =&gt; (…args) =&gt; f(g(…args)));<br>/<em><br>const add5 = x =&gt; x + 5<br>const multiply = (x, y) =&gt; x </em> y<br>const multiplyAndAdd5 = compose(add5, multiply)<br>multiplyAndAdd5(5, 2) -&gt; 15<br>*/<br>curry<br>Curries a function.</p>\n<p>使用递归。如果提供的参数 (变量) 的数量足够, 请调用传递的函数args f。否则, 返回需要其余参数的扩充函数f。如果你想咖喱一个函数, 接受可变数目的参数 (如Math.min()), 可以选择将参数的个数传递到第二个参数arity(可变函数).</p>\n<p>const curry = (fn, arity = fn.length, …args) =&gt;<br>arity &lt;= args.length<br>? fn(…args)<br>: curry.bind(null, fn, arity, …args);<br>// curry(Math.pow)(2)(10) -&gt; 1024<br>// curry(Math.min, 3)(10)(50)(2) -&gt; 2<br>functionName<br>记录函数的名称。</p>\n<p>使用console.debug()和传递的方法的name属性将方法的名称记录到控制台的debug通道中。</p>\n<p>const functionName = fn =&gt; (console.debug(fn.name), fn);<br>// functionName(Math.max) -&gt; max (logged in debug channel of console)<br>pipe<br>执行从左向右的函数组合。</p>\n<p>使用Array.reduce()与扩展运算符 (…) 执行从左向右的函数组合。第一个 (最左边的) 函数可以接受一个或多个参数;其余的函数必须是一元的。</p>\n<p>const pipeFunctions = (…fns) =&gt; fns.reduce((f, g) =&gt; (…args) =&gt; g(f(…args)));<br>/<em><br>const add5 = x =&gt; x + 5<br>const multiply = (x, y) =&gt; x </em> y<br>const multiplyAndAdd5 = pipeFunctions(multiply, add5)<br>multiplyAndAdd5(5, 2) -&gt; 15<br>*/<br>promisify<br>转换异步函数以返回一个承诺。</p>\n<p>使用讨好返回一个返回调用原始函数的Promise的函数。使用…rest运算符传入所有参数。 在节点 8 + 中, 可以使用 util.promisify</p>\n<p>const promisify = func =&gt;<br>(…args) =&gt;<br>new Promise((resolve, reject) =&gt;<br>func(…args, (err, result) =&gt;<br>err ? reject(err) : resolve(result))<br>);<br>// const delay = promisify((d, cb) =&gt; setTimeout(cb, d))<br>// delay(2000).then(() =&gt; console.log(‘Hi!’)) -&gt; Promise resolves after 2s<br>runPromisesInSeries<br>运行一系列的承诺系列。</p>\n<p>使用Array.reduce()创建一个承诺链, 每个承诺在解决时返回下一个承诺。</p>\n<p>const runPromisesInSeries = ps =&gt; ps.reduce((p, next) =&gt; p.then(next), Promise.resolve());<br>// const delay = (d) =&gt; new Promise(r =&gt; setTimeout(r, d))<br>// runPromisesInSeries([() =&gt; delay(1000), () =&gt; delay(2000)]) -&gt; executes each promise sequentially, taking a total of 3 seconds to complete<br>sleep<br>延迟异步函数的执行。</p>\n<p>延迟执行async函数的一部分, 将其放入休眠状态, 返回Promise.</p>\n<p>const sleep = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));<br>/<em><br>async function sleepyWork() {<br>  console.log(‘I\\’m going to sleep for 1 second.’);<br>  await sleep(1000);<br>  console.log(‘I woke up after 1 second.’);<br>}\n</em>/<br>数学<br>arrayAverage<br>返回数字数组的平均值。</p>\n<p>使用Array.reduce()将每个值添加到累加器中, 并以0的值初始化, 除以数组的length。</p>\n<p>const arrayAverage = arr =&gt; arr.reduce((acc, val) =&gt; acc + val, 0) / arr.length;<br>// arrayAverage([1,2,3]) -&gt; 2<br>arraySum<br>返回一个数字数组的总和。</p>\n<p>使用Array.reduce()将每个值添加到累加器中, 并以0值初始化.</p>\n<p>const arraySum = arr =&gt; arr.reduce((acc, val) =&gt; acc + val, 0);<br>// arraySum([1,2,3,4]) -&gt; 10<br>collatz<br>应用 Collatz 算法。</p>\n<p>如果n是偶数, 则返回n/2。否则返回3n+1.</p>\n<p>const collatz = n =&gt; (n % 2 == 0) ? (n / 2) : (3 * n + 1);<br>// collatz(8) –&gt; 4<br>// collatz(5) –&gt; 16<br>collatz<br>将数字转换为数字数组。</p>\n<p>将数字转换为字符串, 在 ES6 ([…string]) 中使用扩展运算符生成数组。使用Array.map()和parseInt()将每个值转换为整数。</p>\n<p>const digitize = n =&gt; […’’+n].map(i =&gt; parseInt(i));<br>// digitize(2334) -&gt; [2, 3, 3, 4]<br>digitize<br>返回两点之间的距离。</p>\n<p>使用Math.hypot()计算两个点之间的欧氏距离。</p>\n<p>const distance = (x0, y0, x1, y1) =&gt; Math.hypot(x1 - x0, y1 - y0);<br>// distance(1,1, 2,3) -&gt; 2.23606797749979<br>distance<br>计算数字的阶乘。</p>\n<p>使用递归。如果n小于或等于1, 则返回1。否则, 返回n的乘积和n – 1的阶乘。如果n为负数, 则引发异常。</p>\n<p>const factorial = n =&gt;<br>n &lt; 0 ? (() =&gt; { throw new TypeError(‘Negative numbers are not allowed!’) })()<br>: n &lt;= 1 ? 1 : n * factorial(n - 1);<br>// factorial(6) -&gt; 720<br>fibonacci<br>生成一个数组, 包含斐波那契数列, 直到第 n 个项。</p>\n<p>创建一个指定长度的空数组, 初始化前两个值 (0和1)。使用Array.reduce()可将值添加到数组中, 方法是使用前两个值的总和, 但前两个数值除外。</p>\n<p>const fibonacci = n =&gt;<br>Array(n).fill(0).reduce((acc, val, i) =&gt; acc.concat(i &gt; 1 ? acc[i - 1] + acc[i - 2] : i), []);<br>// fibonacci(5) -&gt; [0,1,1,2,3]<br>gcd<br>计算两个数字之间最大的公共除数。</p>\n<p>使用递归。基本情况是当y等于0时。在这种情况下, 返回x。否则, 返回y的 GCD 和除法的其余部分x/y.</p>\n<p>const gcd = (x, y) =&gt; !y ? x : gcd(y, x % y);<br>// gcd (8, 36) -&gt; 4<br>hammingDistance<br>计算两个值之间的汉明距离。</p>\n<p>使用 XOR 运算符 (^) 可查找两个数字之间的位差, 使用toString(2)转换为二进制字符串。使用match(/1/g)计算并返回字符串中1的数目。.</p>\n<p>const hammingDistance = (num1, num2) =&gt;<br>((num1 ^ num2).toString(2).match(/1/g) || ‘’).length;<br>// hammingDistance(2,3) -&gt; 1<br>isDivisible<br>检查第一个数值参数是否可被另一个数字变量整除。</p>\n<p>使用模数运算符 (%) 检查余数是否等于0.</p>\n<p>const isDivisible = (dividend, divisor) =&gt; dividend % divisor === 0;<br>// isDivisible(6,3) -&gt; true<br>iseven<br>如果给定的数字为偶数, 则返回true, 否则为false。</p>\n<p>检查一个数字是奇数还是使用模数 (%) 运算符。如果数字为偶数, 则返回true, 如果数字为奇数, 则为false。</p>\n<p>const isEven = num =&gt; num % 2 === 0;<br>// isEven(3) -&gt; false<br>lcm<br>返回两个数字中最不常见的倍数。</p>\n<p>使用最大的公共除数 (GCD) 公式和Math.abs()来确定最不常见的倍数。GCD 公式使用递归。</p>\n<p>const lcm = (x,y) =&gt; {<br>const gcd = (x, y) =&gt; !y ? x : gcd(y, x % y);<br>return Math.abs(x*y)/(gcd(x,y));<br>};<br>// lcm(12,7) -&gt; 84<br>median<br>返回数字数组的中间值。</p>\n<p>找到数组的中间, 使用Array.sort()来对值进行排序。如果length为奇数, 则返回中点的数字, 否则为两个中间数的平均值。</p>\n<p>const median = arr =&gt; {<br>const mid = Math.floor(arr.length / 2), nums = arr.sort((a, b) =&gt; a - b);<br>return arr.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;<br>};<br>// median([5,6,50,1,-5]) -&gt; 5<br>// median([0,10,-2,7]) -&gt; 3.5<br>palindrome<br>如果给定字符串为回文, 则返回true, 否则为false。</p>\n<p>转换字符串toLowerCase()并使用replace()从其中删除非字母数字字符。然后,split(”)到各个字符,reverse(),join(”), 并将其与原始的、不可逆转的字符串进行比较, 然后将其转换为tolowerCase().</p>\n<p>const palindrome = str =&gt; {<br>const s = str.toLowerCase().replace(/[\\W_]/g,’’);<br>return s === s.split(‘’).reverse().join(‘’);<br>}<br>// palindrome(‘taco cat’) -&gt; true<br>percentile<br>使用百分比公式计算给定数组中有多少个数小于或等于给定值。</p>\n<p>使用Array.reduce()计算值的下面有多少, 有多少个数是相同的值, 并应用百分比公式。</p>\n<p>const percentile = (arr, val) =&gt;<br>100 * arr.reduce((acc,v) =&gt; acc + (v &lt; val ? 1 : 0) + (v === val ? 0.5 : 0), 0) / arr.length;<br>// percentile([1,2,3,4,5,6,7,8,9,10], 6) -&gt; 55<br>powerset<br>返回给定数字数组的 powerset。</p>\n<p>使用Array.reduce()与Array.map()组合, 以循环访问元素并将其合并到包含所有组合的数组中。</p>\n<p>const powerset = arr =&gt;<br>arr.reduce((a, v) =&gt; a.concat(a.map(r =&gt; [v].concat(r))), [[]]);<br>// powerset([1,2]) -&gt; [[], [1], [2], [2,1]]<br>randomIntegerInRange<br>返回指定范围内的随机整数。</p>\n<p>使用Math.random()生成一个随机数并将其映射到所需的范围, 使用Math.floor()使其成为整数。</p>\n<p>const randomIntegerInRange = (min, max) =&gt; Math.floor(Math.random() * (max - min + 1)) + min;<br>// randomIntegerInRange(0, 5) -&gt; 2<br>randomNumberInRange<br>返回指定范围内的随机数。</p>\n<p>使用Math.random()生成随机值, 并使用乘法将其映射到所需的范围。</p>\n<p>const randomNumberInRange = (min, max) =&gt; Math.random() * (max - min) + min;<br>// randomNumberInRange(2,10) -&gt; 6.0211363285087005<br>round<br>将数字四舍五入到指定的位数。</p>\n<p>使用Math.round()和模板文本将数字舍入到指定的位数。省略第二个参数,decimals舍入为整数。</p>\n<p>const round = (n, decimals=0) =&gt; Number(<code>${Math.round(</code>${n}e${decimals}<code>)}e-${decimals}</code>);<br>// round(1.005, 2) -&gt; 1.01<br>standardDeviation<br>返回数字数组的标准偏差。</p>\n<p>使用Array.reduce()计算值的平均值、方差和方差的总和, 值的方差, 然后确定标准偏差。可以省略第二个参数以获取样本标准偏差, 或将其设置为true以获取总体标准偏差。</p>\n<p>const standardDeviation = (arr, usePopulation = false) =&gt; {<br>const mean = arr.reduce((acc, val) =&gt; acc + val, 0) / arr.length;<br>return Math.sqrt(<br>arr.reduce((acc, val) =&gt; acc.concat(Math.pow(val - mean, 2)), [])<br>.reduce((acc, val) =&gt; acc + val, 0) / (arr.length - (usePopulation ? 0 : 1))<br>);<br>};<br>// standardDeviation([10,2,38,23,38,23,21]) -&gt; 13.284434142114991 (sample)<br>// standardDeviation([10,2,38,23,38,23,21], true) -&gt; 12.29899614287479 (population)<br>媒体<br>speechSynthesis<br>执行语音合成 (实验)。</p>\n<p>使用SpeechSynthesisUtterance.voice和window.speechSynthesis.getVoices()将邮件转换为语音。使用window.speechSynthesis.speak()播放该消息。了解有关Web 语音 API 的 SpeechSynthesisUtterance 接口的详细信息.</p>\n<p>const speechSynthesis = message =&gt; {<br>const msg = new SpeechSynthesisUtterance(message);<br>msg.voice = window.speechSynthesis.getVoices()[0];<br>window.speechSynthesis.speak(msg);<br>};<br>// speechSynthesis(‘Hello, World’) -&gt; plays the message<br>节点<br>JSONToFile<br>将 JSON 对象写入文件。</p>\n<p>使用fs.writeFile()、模板文本和JSON.stringify()将json对象写入.json文件。</p>\n<p>const fs = require(‘fs’);<br>const JSONToFile = (obj, filename) =&gt; fs.writeFile(<code>${filename}.json</code>, JSON.stringify(obj, null, 2))<br>// JSONToFile({test: “is passed”}, ‘testJsonFile’) -&gt; writes the object to ‘testJsonFile.json’<br>readFileLines<br>返回指定文件中的行的数组。</p>\n<p>在fs节点包中使用readFileSync函数可以从文件创建Buffer。使用toString(encoding)函数将缓冲区转换为字符串。通过spliting 文件内容行从文件内容创建数组 (每个\\n).</p>\n<p>const fs = require(‘fs’);<br>const readFileLines = filename =&gt; fs.readFileSync(filename).toString(‘UTF8’).split(‘\\n’);<br>/*<br>contents of test.txt :<br>  line1<br>  line2<br>  line3</p>\n<hr>\n<p>let arr = readFileLines(‘test.txt’)<br>console.log(arr) // -&gt; [‘line1’, ‘line2’, ‘line3’]<br>*/<br>对象<br>cleanObj<br>移除从 JSON 对象指定的属性之外的任何特性。</p>\n<p>使用Object.keys()方法可以遍历给定的 json 对象并删除在给定数组中不是included 的键。另外, 如果给它一个特殊的键 (childIndicator), 它将在里面深入搜索, 并将函数应用于内部对象。</p>\n<p>const cleanObj = (obj, keysToKeep = [], childIndicator) =&gt; {<br>Object.keys(obj).forEach(key =&gt; {<br>if (key === childIndicator) {<br>cleanObj(obj[key], keysToKeep, childIndicator);<br>} else if (!keysToKeep.includes(key)) {<br>delete obj[key];<br>}<br>})<br>}<br>/<em><br>  const testObj = {a: 1, b: 2, children: {a: 1, b: 2}}<br>  cleanObj(testObj, [“a”],”children”)<br>  console.log(testObj)// { a: 1, children : { a: 1}}\n</em>/<br>objectFromPairs<br>从给定的键值对创建对象。</p>\n<p>使用Array.reduce()创建和组合键值对。</p>\n<p>const objectFromPairs = arr =&gt; arr.reduce((a, v) =&gt; (a[v[0]] = v[1], a), {});<br>// objectFromPairs([[‘a’,1],[‘b’,2]]) -&gt; {a: 1, b: 2}<br>objectToPairs<br>从对象创建键值对数组的数组。</p>\n<p>使用Object.keys()和Array.map()循环访问对象的键并生成具有键值对的数组。</p>\n<p>const objectToPairs = obj =&gt; Object.keys(obj).map(k =&gt; [k, obj[k]]);<br>// objectToPairs({a: 1, b: 2}) -&gt; [[‘a’,1],[‘b’,2]])<br>shallowClone<br>创建对象的浅表克隆。</p>\n<p>使用Object.assign()和一个空对象 ({}) 创建原始的浅克隆。</p>\n<p>const shallowClone = obj =&gt; Object.assign({}, obj);<br>/<em><br>const a = { x: true, y: 1 };<br>const b = shallowClone(a);<br>a === b -&gt; false\n</em>/<br>truthCheckCollection<br>检查谓词 (第二个参数) 是否 truthy 集合的所有元素 (第一个参数)。</p>\n<p>使用Array.every()检查每个传递的对象是否具有指定的属性, 以及是否返回 truthy 值。</p>\n<p>truthCheckCollection = (collection, pre) =&gt; (collection.every(obj =&gt; obj[pre]));<br>// truthCheckCollection([{“user”: “Tinky-Winky”, “sex”: “male”}, {“user”: “Dipsy”, “sex”: “male”}], “sex”) -&gt; true<br>字符串<br>anagrams<br>生成字符串的所有字谜 (包含重复项)。</p>\n<p>使用递归。对于给定字符串中的每个字母, 为其其余字母创建所有部分字谜。使用Array.map()将字母与每个部分变位词组合在一起, 然后将Array.reduce()组合在一个数组中的所有字谜。基本情况为字符串length等于2或1.</p>\n<p>const anagrams = str =&gt; {<br>if (str.length &lt;= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str];<br>return str.split(‘’).reduce((acc, letter, i) =&gt;<br>acc.concat(anagrams(str.slice(0, i) + str.slice(i + 1)).map(val =&gt; letter + val)), []);<br>};<br>// anagrams(‘abc’) -&gt; [‘abc’,’acb’,’bac’,’bca’,’cab’,’cba’]<br>Capitalize<br>将字符串的第一个字母大写。</p>\n<p>使用 destructuring 和toUpperCase()可将第一个字母、…rest用于获取第一个字母之后的字符数组, 然后是Array.join(”)以使其成为字符串。省略lowerRest参数以保持字符串的其余部分不变, 或将其设置为true以转换为小写。</p>\n<p>const capitalize = ([first,…rest], lowerRest = false) =&gt;<br>first.toUpperCase() + (lowerRest ? rest.join(‘’).toLowerCase() : rest.join(‘’));<br>// capitalize(‘myName’) -&gt; ‘MyName’<br>// capitalize(‘myName’, true) -&gt; ‘Myname’<br>capitalizeEveryWord<br>将字符串中每个单词的首字母大写。</p>\n<p>使用replace()匹配每个单词和toUpperCase()的第一个字符以将其大写。</p>\n<p>const capitalizeEveryWord = str =&gt; str.replace(/\\b[a-z]/g, char =&gt; char.toUpperCase());<br>// capitalizeEveryWord(‘hello world!’) -&gt; ‘Hello World!’<br>escapeRegExp<br>转义要在正则表达式中使用的字符串。</p>\n<p>使用replace()可转义特殊字符。</p>\n<p>const escapeRegExp = str =&gt; str.replace(/[.*+?^${}()|[]\\]/g, ‘\\$&amp;’);<br>// escapeRegExp(‘(test)’) -&gt; \\(test\\)<br>fromCamelCase<br>从匹配转换字符串。</p>\n<p>使用replace()可删除下划线、连字符和空格, 并将单词转换为匹配。省略第二个参数以使用默认分隔符_.</p>\n<p>const fromCamelCase = (str, separator = ‘<em>‘) =&gt;<br>str.replace(/([a-z\\d])([A-Z])/g, ‘$1’ + separator + ‘$2’)<br>.replace(/([A-Z]+)([A-Z][a-z\\d]+)/g, ‘$1’ + separator + ‘$2’).toLowerCase();<br>// fromCamelCase(‘someDatabaseFieldName’, ‘ ‘) -&gt; ‘some database field name’<br>// fromCamelCase(‘someLabelThatNeedsToBeCamelized’, ‘-‘) -&gt; ‘some-label-that-needs-to-be-camelized’<br>// fromCamelCase(‘someJavascriptProperty’, ‘</em>‘) -&gt; ‘some_javascript_property’<br>reverseString<br>反转字符串。</p>\n<p>使用数组 destructuring 和Array.reverse()可反转字符串中字符的顺序。使用join(”)组合字符以获取字符串.</p>\n<p>const reverseString = str =&gt; […str].reverse().join(‘’);<br>// reverseString(‘foobar’) -&gt; ‘raboof’<br>sortCharactersInString<br>按字母顺序对字符串中的字符进行排序。</p>\n<p>使用split(”)、Array.sort()利用localeCompare()重新组合使用join(”).</p>\n<p>const sortCharactersInString = str =&gt;<br>str.split(‘’).sort((a, b) =&gt; a.localeCompare(b)).join(‘’);<br>// sortCharactersInString(‘cabbage’) -&gt; ‘aabbceg’<br>toCamelCase<br>将字符串转换为匹配。</p>\n<p>使用replace()可删除下划线、连字符和空格, 并将单词转换为匹配。</p>\n<p>const toCamelCase = str =&gt;<br>str.replace(/^([A-Z])|[\\s-_]+(\\w)/g, (match, p1, p2, offset) =&gt;  p2 ? p2.toUpperCase() : p1.toLowerCase());<br>// toCamelCase(“some_database_field_name”) -&gt; ‘someDatabaseFieldName’<br>// toCamelCase(“Some label that needs to be camelized”) -&gt; ‘someLabelThatNeedsToBeCamelized’<br>// toCamelCase(“some-javascript-property”) -&gt; ‘someJavascriptProperty’<br>// toCamelCase(“some-mixed_string with spaces_underscores-and-hyphens”) -&gt; ‘someMixedStringWithSpacesUnderscoresAndHyphens’<br>truncateString<br>将字符串截断为指定长度。</p>\n<p>确定字符串的length是否大于num。将截断的字符串返回到所需的长度, 并将…追加到末尾或原始字符串。</p>\n<p>const truncateString = (str, num) =&gt;<br>str.length &gt; num ? str.slice(0, num &gt; 3 ? num - 3 : num) + ‘…’ : str;<br>// truncateString(‘boomerang’, 7) -&gt; ‘boom…’<br>实用<br>coalesce<br>返回第一个非空/未定义参数。</p>\n<p>使用Array.find()返回第一个非null/undefined的参数。</p>\n<p>const coalesce = (…args) =&gt; args.find(<em> =&gt; ![undefined, null].includes(</em>))<br>// coalesce(null,undefined,””,NaN, “Waldo”) -&gt; “”<br>coalesceFactory<br>返回自定义的联合函数, 返回从提供的参数验证函数返回true的第一个参数。</p>\n<p>使用Array.find()返回从提供的参数验证函数返回true的第一个参数。</p>\n<p>const coalesceFactory = valid =&gt; (…args) =&gt; args.find(valid);<br>// const customCoalesce = coalesceFactory(<em> =&gt; ![null, undefined, “”, NaN].includes(</em>))<br>// customCoalesce(undefined, null, NaN, “”, “Waldo”) //-&gt; “Waldo”<br>extendHex<br>将3位色码扩展为6位色码。</p>\n<p>使用Array.map()、split()和Array.join()来加入映射数组, 将3位的 RGB notated 十六进制 color-code 转换为6位数字形式。Array.slice()用于从字符串启动中删除#, 因为它添加了一次。</p>\n<p>const extendHex = shortHex =&gt;<br>‘#’ + shortHex.slice(shortHex.startsWith(‘#’) ? 1 : 0).split(‘’).map(x =&gt; x+x).join(‘’)<br>// extendHex(‘#03f’) -&gt; ‘#0033ff’<br>// extendHex(‘05a’) -&gt; ‘#0055aa’<br>gettype<br>返回值的本机类型。</p>\n<p>如果值未定义或为 null, 则返回小写的构造函数名称、”未定义” 或 “null”</p>\n<p>const getType = v =&gt;<br>v === undefined ? ‘undefined’ : v === null ? ‘null’ : v.constructor.name.toLowerCase();<br>// getType(new Set([1,2,3])) -&gt; “set”<br>hexToRGB<br>将 colorcode 转换为rgb()字符串。</p>\n<p>使用按位右运算符和掩码位与&amp;(and) 运算符将十六进制颜色代码 (前缀为#) 转换为具有 RGB 值的字符串。如果它是一个3位数的 colorcode, 那么用 extendHex () 函数 (ref.extendHex代码段) 扩展的6位 colorcode 进行相同的处理</p>\n<p>const hexToRgb = hex =&gt; {<br>const extendHex = shortHex =&gt;<br>‘#’ + shortHex.slice(shortHex.startsWith(‘#’) ? 1 : 0).split(‘’).map(x =&gt; x+x).join(‘’);<br>const extendedHex = hex.slice(hex.startsWith(‘#’) ? 1 : 0).length === 3 ? extendHex(hex) : hex;<br>return <code>rgb(${parseInt(extendedHex.slice(1), 16) &gt;&gt; 16}, ${(parseInt(extendedHex.slice(1), 16) &amp; 0x00ff00) &gt;&gt; 8}, ${parseInt(extendedHex.slice(1), 16) &amp; 0x0000ff})</code>;<br>}<br>// hexToRgb(‘#27ae60’) -&gt; ‘rgb(39, 174, 96)’<br>// hexToRgb(‘#acd’) -&gt; ‘rgb(170, 204, 221)’<br>isArray<br>检查给定参数是否为数组。</p>\n<p>使用Array.isArray()检查某个值是否属于数组。</p>\n<p>const isArray = val =&gt; !!val &amp;&amp; Array.isArray(val);<br>// isArray(null) -&gt; false<br>// isArray([1]) -&gt; true<br>isBoolean<br>检查给定的参数是否为本机布尔元素。</p>\n<p>使用typeof检查某个值是否被归类为布尔基元。</p>\n<p>const isBoolean = val =&gt; typeof val === ‘boolean’;<br>// isBoolean(null) -&gt; false<br>// isBoolean(false) -&gt; true<br>isFunction<br>检查给定参数是否为函数。</p>\n<p>使用typeof检查某个值是否被归类为函数基元。</p>\n<p>const isFunction = val =&gt; val &amp;&amp; typeof val === ‘function’;<br>// isFunction(‘x’) -&gt; false<br>// isFunction(x =&gt; x) -&gt; true<br>isNumber<br>检查给定参数是否为数字。</p>\n<p>使用typeof检查某个值是否归类为数字基元。</p>\n<p>const isNumber = val =&gt; typeof val === ‘number’;<br>// isNumber(‘1’) -&gt; false<br>// isNumber(1) -&gt; true<br>isString<br>检查给定参数是否为字符串。</p>\n<p>使用typeof检查某个值是否属于字符串基元。</p>\n<p>const isString = val =&gt; typeof val === ‘string’;<br>// isString(10) -&gt; false<br>// isString(‘10’) -&gt; true<br>isSymbol<br>检查给定参数是否为符号。</p>\n<p>使用typeof检查某个值是否被归类为符号基元。</p>\n<p>const isSymbol = val =&gt; typeof val === ‘symbol’;<br>// isSymbol(‘x’) -&gt; false<br>// isSymbol(Symbol(‘x’)) -&gt; true<br>RGBToHex<br>将 RGB 组件的值转换为 colorcode。</p>\n<p>使用按位左移位运算符 (&lt;&lt;) 和toString(16)将给定的 RGB 参数转换为十六进制字符串, 然后padStart(6,’0′)以获取6位十六进制值。</p>\n<p>const RGBToHex = (r, g, b) =&gt; ((r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).padStart(6, ‘0’);<br>// RGBToHex(255, 165, 1) -&gt; ‘ffa501’<br>timeTaken<br>测量执行函数所用的时间。</p>\n<p>使用console.time()和console.timeEnd()来测量开始和结束时间之间的差异, 以确定回调执行所用的时间。</p>\n<p>const timeTaken = callback =&gt; {<br>console.time(‘timeTaken’);  const r = callback();<br>console.timeEnd(‘timeTaken’);  return r;<br>};<br>// timeTaken(() =&gt; Math.pow(2, 10)) -&gt; 1024<br>// (logged): timeTaken: 0.02099609375ms<br>toOrdinalSuffix<br>将序号后缀添加到数字。</p>\n<p>使用模数运算符 (%) 查找单个和十位数字的值。查找匹配的序号模式数字。如果在青少年模式中发现数字, 请使用青少年序号。</p>\n<p>const toOrdinalSuffix = num =&gt; {<br>const int = parseInt(num), digits = [(int % 10), (int % 100)],<br>ordinals = [‘st’, ‘nd’, ‘rd’, ‘th’], oPattern = [1, 2, 3, 4],<br>tPattern = [11, 12, 13, 14, 15, 16, 17, 18, 19];<br>return oPattern.includes(digits[0]) &amp;&amp; !tPattern.includes(digits[1]) ? int + ordinals[digits[0] - 1] : int + ordinals[3];<br>};<br>// toOrdinalSuffix(“123”) -&gt; “123rd”<br>UUIDGenerator<br>生成 UUID。</p>\n<p>使用cryptoAPI 生成 UUID, 符合RFC4122版本4。</p>\n<p>const UUIDGenerator = () =&gt;<br>([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =&gt;<br>(c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16)<br>);<br>// UUIDGenerator() -&gt; ‘7982fcfe-5721-4632-bede-6000885be57d’<br>validateEmail<br>如果给定的字符串是有效的电子邮件, 则返回true, 否则为false。</p>\n<p>使用正则表达式检查电子邮件是否有效。如果电子邮件有效, 则返回 true, 如果没有, 则返回false。</p>\n<p>const validateEmail = str =&gt;<br>  /^(([^&lt;&gt;()[]\\.,;:\\s@”]+(.[^&lt;&gt;()[]\\.,;:\\s@”]+)*)|(“.+”))@(([[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}])|(([a-zA-Z-0-9]+.)+[a-zA-Z]{2,}))$/.test(str);<br>// validateEmail(mymail@gmail.com) -&gt; true<br>validateNumber<br>如果给定值为数字, 则返回true, 否则为false。</p>\n<p>将!isNaN与parseFloat()结合使用, 以检查参数是否为数字。使用isFinite()检查数字是否是有限的。使用Number()检查强制是否保持。</p>\n<p>const validateNumber = n =&gt; !isNaN(parseFloat(n)) &amp;&amp; isFinite(n) &amp;&amp; Number(n) == n;<br>// validateNumber(‘10’) -&gt; true<br>感谢作者分享了大量有用的Javascript片段,本文为中文版翻译，下面一起来看看有哪些精彩的JavaScript代码值得收藏。</p>\n<p>原文：<a href=\"https://github.com/Chalarangelo/30-seconds-of-code\" target=\"_blank\" rel=\"noopener\">https://github.com/Chalarangelo/30-seconds-of-code</a></p>\n<p>作者：Chalarangelo</p>\n<p>翻译：<a href=\"http://caibaojian.com/30-seconds-of-code.html\" target=\"_blank\" rel=\"noopener\">http://caibaojian.com/30-seconds-of-code.html</a></p>\n<p>译者：蔡宝坚</p>\n<p>本文翻译为前端开发博客所有，如有需要转载，请详细注明以上信息。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjcymfvs70000s2gssh4no3n8","tag_id":"cjcymfvsf0004s2gsa5naodjj","_id":"cjcymfvso0009s2gsywpultt1"},{"post_id":"cjcymfvsm0007s2gsqo6fnu59","tag_id":"cjcymfvsf0004s2gsa5naodjj","_id":"cjcymfvso000as2gsjei5f6fj"},{"post_id":"cjcymfvsc0002s2gse2ugzme5","tag_id":"cjcymfvsn0008s2gsj2xk8sc6","_id":"cjcymfvsp000cs2gs9kvbgmcw"},{"post_id":"cjcymfvsh0005s2gsc88po3gi","tag_id":"cjcymfvsp000bs2gsoxtyeuwb","_id":"cjcymfvsq000es2gshxlmbu0h"},{"post_id":"cjcymfvsj0006s2gsa15008mo","tag_id":"cjcymfvsp000ds2gsck4l1h1c","_id":"cjcymfvsq000fs2gsa6ca0krz"}],"Tag":[{"name":"array, javascript, api","_id":"cjcymfvsf0004s2gsa5naodjj"},{"name":"git","_id":"cjcymfvsn0008s2gsj2xk8sc6"},{"name":"system, api,前端接口对接,后端","_id":"cjcymfvsp000bs2gsoxtyeuwb"},{"name":"rem,px","_id":"cjcymfvsp000ds2gsck4l1h1c"}]}}
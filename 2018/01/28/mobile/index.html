<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="charsle"><title>了解真实的『REM』手机屏幕适配 · 前端码农日志</title><meta name="description" content="rem 作为一个低调的长度单位，由于手机端网页的兴起，在屏幕适配中得到重用。使用 rem 前端开发者可以很方便的在各种屏幕尺寸下，通过等比缩放的方式达到设计图要求的效果。
rem 的官方定义『The font size of the root element.』，即以根节点的字体大小作为基准值进行长"><meta name="keywords" content="HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo.jpeg" style="width:127px;border-radius:50%;"><h3 title=""><a href="/">charsle</a></h3><div class="description"><p>一个关注技术与人文的IT博客</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/iweb8" target="_blank"><i class="fa fa-weibo"></i></a></li><li><a href="http://facebook.com/charsle.cai.3" target="_blank"><i class="fa fa-facebook"></i></a></li><li><a href="http://github.com/charsle" target="_blank"><i class="fa fa-github"></i></a></li><li><a href="http://gitee.com/charsle" target="_blank"> 码云</a></li></ul><div class="footer"><a target="_blank" href="/"><span> </span></a><a href="http://www.miitbeian.gov.cn/publish/query/indexFirst.action" target="_blank">渝ICP备16004561号 </a><span> </span><br><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank"> </a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="https://avatars1.githubusercontent.com/u/11400128?s=460&amp;v=4"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>了解真实的『REM』手机屏幕适配</a></h3></div><div class="post-content"><p>rem 作为一个低调的长度单位，由于手机端网页的兴起，在屏幕适配中得到重用。使用 rem 前端开发者可以很方便的在各种屏幕尺寸下，通过等比缩放的方式达到设计图要求的效果。</p>
<p>rem 的官方定义『The font size of the root element.』，即以根节点的字体大小作为基准值进行长度计算。一般认为网页中的根节点是 html 元素，所以采用的方式也是通过设置 html 元素的 font-size 来做屏幕适配，但实际情况真有这么简单吗？</p>
<p>首先我们来看看使用 rem 实现手机屏幕适配的常用方案。</p>
<p>以设计稿的宽度为640px，即：designWidth = 640，同时设定在640px屏宽下 1rem=100px ，即：rem2px = 100。</p>
<p>设置 1rem=100px 的优点不言而喻。前端开发者在切图、重构页面的时候，通过直接位移小数点的方式，就可以将UI图中测量到的 px 值换算成对应的 rem 值，方便快捷。</p>
<p>此外，在 head 中我们还设置了：<meta name="”viewport”" content="”width=device-width," initial-scale="1.0," minimum-scale="1.0," maximum-scale="1.0″"><br>viewport 的作用很重要，但不是本文的重点所以不展开，有兴趣的同学可以自行搜索。</p>
<p>先来看看具体方案：</p>
<p>下面四个方案来自同事共享，原理都是采用等比缩放的方式 —— 获得目标屏幕宽度和设计稿宽度的比，作为 rem 的基值（缩放系数），设置为html标签的字体大小。不同的只是在于性能取舍和书写习惯。</p>
<p>方案1</p>
<p>@media screen and (min-width: 320px) {html{font-size:50px;}}<br>@media screen and (min-width: 360px) {html{font-size:56.25px;}}<br>@media screen and (min-width: 375px) {html{font-size:58.59375px;}}<br>@media screen and (min-width: 400px) {html{font-size:62.5px;}}<br>@media screen and (min-width: 414px) {html{font-size:64.6875px;}}<br>@media screen and (min-width: 440px) {html{font-size:68.75px;}}<br>@media screen and (min-width: 480px) {html{font-size:75px;}}<br>@media screen and (min-width: 520px) {html{font-size:81.25px;}}<br>@media screen and (min-width: 560px) {html{font-size:87.5px;}}<br>@media screen and (min-width: 600px) {html{font-size:93.75px;}}<br>@media screen and (min-width: 640px) {html{font-size:100px;}}<br>@media screen and (min-width: 680px) {html{font-size:106.25px;}}<br>@media screen and (min-width: 720px) {html{font-size:112.5px;}}<br>@media screen and (min-width: 760px) {html{font-size:118.75px;}}<br>@media screen and (min-width: 800px) {html{font-size:125px;}}<br>@media screen and (min-width: 960px) {html{font-size:150px;}}<br>方案2</p>
<p>@media screen and (min-width: 320px) {html{font-size:312.5%;}}<br>@media screen and (min-width: 360px) {html{font-size:351.5625%;}}<br>@media screen and (min-width: 375px) {html{font-size:366.211%;}}<br>@media screen and (min-width: 400px) {html{font-size:390.625%;}}<br>@media screen and (min-width: 414px) {html{font-size:404.2969%;}}<br>@media screen and (min-width: 440px) {html{font-size:429.6875%;}}<br>@media screen and (min-width: 480px) {html{font-size:468.75%;}}<br>@media screen and (min-width: 520px) {html{font-size:507.8125%;}}<br>@media screen and (min-width: 560px) {html{font-size:546.875%;}}<br>@media screen and (min-width: 600px) {html{font-size:585.9375%;}}<br>@media screen and (min-width: 640px) {html{font-size:625%;}}<br>@media screen and (min-width: 680px) {html{font-size:664.0625%;}}<br>@media screen and (min-width: 720px) {html{font-size:703.125%;}}<br>@media screen and (min-width: 760px) {html{font-size:742.1875%;}}<br>@media screen and (min-width: 800px) {html{font-size:781.25%;}}<br>@media screen and (min-width: 960px) {html{font-size:937.5%;}}<br>方案3</p>
<p>var designWidth = 640, rem2px = 100;<br>document.documentElement.style.fontSize =<br>  ((window.innerWidth / designWidth) * rem2px) + ‘px’;<br>方案4</p>
<p>var designWidth = 640, rem2px = 100;<br>document.documentElement.style.fontSize =<br>  ((((window.innerWidth / designWidth) <em> rem2px) / 16) </em> 100) + ‘%’;<br>为了更避免理解上的混乱，我在上面js的代码中加了 ( ) ，实际代码中是不需要的。</p>
<p>详细分析一下，rem 和 px 直接的转换公式可以写为：</p>
<p>1rem = 1 * htmlFontSize<br>htmlFontSize 为 html 元素的字体大小。</p>
<p>首先来看方案1中，在屏宽为640px情况下的设置：</p>
<p>@media screen and (min-width: 640px) {html{font-size:100px;}}<br>可以很明显的表现出这一点 1rem = 1 * 100px ，同我们最初的设定。那么我们要得到其它屏幕大小的 htmlFontSize 值要怎么办。很简单如方案3，因为我们的采用等比缩放的方式适配，所以计算目标屏幕宽度和设计稿的宽度的比即可：</p>
<p>window.innerWidth / designWidth * rem2px + ‘px’<br>由于浏览器默认字体大小为 16px，所以当我们使用百分比作为根节点 html 的字体大小时，即html元素的font-size值设置为一个百分比值，rem 的计算方式就会改为：</p>
<p>defaultFontSize = 16px<br>1rem = 1 <em> htmlFontSize </em> defaultFontSize<br>如方案2中，在屏宽为640px情况下的设置：</p>
<p>@media screen and (min-width: 640px) {html{font-size:625%;}}<br>应用上面的公式：</p>
<p>1rem = 1 <em> 625% </em> 16px<br>其中：625% <em> 16 = 6.25 </em> 16 = 100<br>所以：1rem = 1 * 100px<br>同样的可以得到所有屏幕大小下，html 的 font-size 值的计算公式，即为方案4：</p>
<p>window.innerWidth / designWidth <em> rem2px / 16 </em> 100  + ‘%’<br>通过方案3和方案4的公式，就可以很方便的生成方案1和方案2中的css。</p>
<p>这里只给出了方案3和方案4对应验证页面（方案1和方案2是它们的变形）: scheme3.html, scheme4.html</p>
<p>如下面两张图，是在屏宽为360px下的效果，通过计算目标为：1rem = 56.25px。方案3设置值为：56.25px，方案4设置值为：351.5625%</p>
<p>方案1    方案2</p>
<p>到目前为止貌似很完美的解决了问题，实际情况当然是出现了意外。在有些 Android 手机上，浏览器或 webview 的默认字体是随着系统设置的字体改变的。这样就会导致默认字体大于或小于 16px。</p>
<p>修改默认字体大小后，我们再看方案3和方案4。</p>
<p>同样在屏宽为360px下，我们调大系统字体大小，如下面的效果</p>
<p>设置前 html 元素的字体大小的计算值为 18px ，设置后的计算值为 65px ，由于屏幕宽度没有改变，我们的目标值，即我们在 html 元素上设置的 font-size 值也没有变化任然为 56.25px，而最终计算值出现了偏差。</p>
<p>方案3    方案4</p>
<p>分析偏差前，先来看在360px屏宽下，方案3和方案4的计算过程：</p>
<p>方案3：</p>
<p>document.documentElement.style.fontSize = 56.25px<br>htmlFontSize = 56.25px<br>1rem = 1 * htmlFontSize = 56.25px<br>实际为：<br>1rem = 64.6875px<br>方案4：</p>
<p>document.documentElement.style.fontSize = 351.5625%<br>htmlFontSize = 351.5625%<br>defaultFontSize = 18px<br>1rem = 1 <em> htmlFontSize </em> defaultFontSize = 351.5625% <em> 18px = 63.28125px<br>351.5625% </em> 18 = 63.28125<br>实际为：<br>1rem = 64.6875px<br>貌似方案4的计算结果很接近实际效果，而方案3偏差很大。再来比较方案3和方案4的计算公式：</p>
<p>// 方案3<br>document.documentElement.style.fontSize =<br>  window.innerWidth / designWidth * rem2px + ‘px’;</p>
<p>// 方案4<br>document.documentElement.style.fontSize =<br>  window.innerWidth / designWidth <em> rem2px / 16 </em> 100 + ‘%’;<br>方案4较于方案3其实多除了一个16，可以推测浏览器在计算 rem 的具体值时，如果 html 设置的 font-size 为 px 值时会先除以 16 ，然后再乘以 htmlFontSize。</p>
<p>1rem = 1 <em> (56.25px / 16) </em> 18<br>1 <em> (56.25 / 16) </em> 18 = 63.28125<br>方案4存在问题，是因为系统的默认字体改为了 18px ，但是我们在计算百分比是时候，还是以 16px 为基准值进行计算，所以出现偏差（计算值和实际值之间还有一点偏差这个在后面会提到）。</p>
<p>而在方案3中，我们其实是不考虑浏览器默认字体大小的，但在实际使用的过程中，浏览器还是除了 16 ，而此时默认字体大小为 18px。得出如下在 html 的 fontSize 设置为 px 的情况下 rem 的计算公式为：</p>
<p>1rem = 1 <em> (htmlFontSize / 16) </em> defaultFontSize<br>在系统设置的字体大小发生改变时，defaultFontSize 会跟着改变，而 16 不会变化。所以方案3虽然表面上不考虑默认字体大小的变化，只关注屏幕与设计稿之间的宽度比，但在实际计算中还是使用到了默认字体大小，而且还有一个不变的 16 在作祟，导致方案3失败。</p>
<p>所谓的「root element」其实不是想象的那样，一个是16，一个是18，到底取的是那个 root element 的字体大小。</p>
<p>ok，rem 的计算的时候，px 的方式会有一个16不随系统字体大小改变，所以我们采用百分比的方案，绕开这个问题。</p>
<p>采用百分比的方案4因为在计算时写死了默认字体大小 16px。所以它的偏差在于没能动态的获取默认字体大小。更新如下：</p>
<p>方案4.1</p>
<p>var designWidth = 640, rem2px = 100;<br>var h = document.getElementsByTagName(‘html’)[0];<br>var htmlFontSize = parseFloat(window.getComputedStyle(h, null)<br>                                    .getPropertyValue(‘font-size’));</p>
<p>document.documentElement.style.fontSize =<br>  window.innerWidth / designWidth <em> rem2px / htmlFontSize </em> 100 + ‘%’;<br>效果如下图：</p>
<p>16px 的图中，设置后的 html 的 font-size 与 1rem 的实际值有偏差，同时 6.4rem 的计算值也有偏差。通过查看代码发现html的font-size使用的是： getPropertyValue(‘font-size’) 而 1rem 使用的是 getPropertyValue(‘width’)，偏差出在计算 font-size 的时候浏览器进行了四舍五入。rem 定义中的另一个元素「font size」也不能按字面意思使用，宣告失守。</p>
<p>18px 中的偏差，以及上文中方案4在 18px 实际值和计算值出现的偏差都是同样的问题。所以基准值还需要修改。</p>
<p>方案5    方案6</p>
<p>在更新一版，方案4.2：</p>
<p>var designWidth = 640, rem2px = 100;<br>var d = window.document.createElement(‘div’);<br>d.style.width = ‘1rem’;<br>d.style.display = “none”;<br>var head = window.document.getElementsByTagName(‘head’)[0];<br>head.appendChild(d);<br>var defaultFontSize = parseFloat(window.getComputedStyle(d, null).getPropertyValue(‘width’));<br>// d.remove();<br>document.documentElement.style.fontSize =<br>  window.innerWidth / designWidth <em> rem2px / defaultFontSize </em> 100 + ‘%’;<br>效果如下图：</p>
<p>方案7    方案8</p>
<p>到此为止，rem 在默认字体不是 16px 的情况下的处理已经解决，考虑到还有设计屏幕旋转，最终手机端的解决方案为：</p>
<p>function adapt(designWidth, rem2px){<br>  var d = window.document.createElement(‘div’);<br>  d.style.width = ‘1rem’;<br>  d.style.display = “none”;<br>  var head = window.document.getElementsByTagName(‘head’)[0];<br>  head.appendChild(d);<br>  var defaultFontSize = parseFloat(window.getComputedStyle(d, null).getPropertyValue(‘width’));<br>  // d.remove();<br>  // document.documentElement.style.fontSize = window.innerWidth / designWidth <em> rem2px / defaultFontSize </em> 100 + ‘%’;<br>  var st = document.createElement(‘style’);<br>  var portrait = “@media screen and (min-width: “+window.innerWidth+”px) {html{font-size:”+ ((window.innerWidth/(designWidth/rem2px)/defaultFontSize)<em>100) +”%;}}”;<br>  var landscape = “@media screen and (min-width: “+window.innerHeight+”px) {html{font-size:”+ ((window.innerHeight/(designWidth/rem2px)/defaultFontSize)</em>100) +”%;}}”<br>  st.innerHTML = portrait + landscape;<br>  head.appendChild(st);<br>  return defaultFontSize<br>};<br>var defaultFontSize = adapt(640, 100);<br>回过头来再看 rem 的定义，『The font size of the root element.』。我们以为的 root element —— html 其实还有个影子在作祟，而我们以为的 font-size 其实是个近似值。</p>
<p>by bx 2016.11.20</p>
<p>评论中提到『高清适配』的问题，解决思路是设置单独的样式特殊处理：其中dpr大于1的时候，1px 的问题，『Retina屏的移动设备如何实现真正1px的线？』此文介绍的很详细，珠玉在前，就不献丑了。图片高清的可以用同样是思路，在不同dpr下加载不同分辨率的图片。</p>
<p>此外rem还有一个问题就是对精灵图的适配，本人开发了一个命令行工具sprites-cli，用来处理这个问题（测试阶段，可能还不是太成熟）。</p>
<p>by 2016.12.06</p>
<p>思而不学则殆，优化了一下此方案前端：『REM』手机屏幕高清适配方案。</p>
<p>by 2016.12.14</p>
</div><span>item.excerpt_link</span><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-01-28</span><i class="fa fa-comment-o"></i><a href="/2018/01/28/mobile/#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/tags/rem-px/" title="rem,px">rem,px </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://www.charsle.com/2018/01/28/mobile/,前端码农日志,了解真实的『REM』手机屏幕适配,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/01/28/git-opeation/" title="Git 常用命令速查">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/01/28/array/" title="javascript Application Programming Interface">下一篇</a></li></ul></div><a id="comments"></a><div class="ds-thread" data-thread-key="2018/01/28/mobile/" data-title="了解真实的『REM』手机屏幕适配" data-url="http://www.charsle.com/2018/01/28/mobile/" data-author-key="1"></div><script>var duoshuoQuery = {short_name:"ss"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'ss';
var disqus_identifier = '2018/01/28/mobile/';
var disqus_title = '了解真实的『REM』手机屏幕适配';
var disqus_url = 'http://www.charsle.com/2018/01/28/mobile/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script><a id="comments"></a><div class="cloud-tie-wrapper" id="cloud-tie-wrapper"></div><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script><script>var cloudTieConfig = { url: document.location.href, sourceId: '2018/01/28/mobile/', productKey: 'ss', target: 'cloud-tie-wrapper' };var yunManualLoad = true;Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.7/dist/Valine.min.js?v=undefined"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'CnAe2r7Il03VGSTKGaxf4Wdx-gzGzoHsz',
  app_key:'nTfB9wd2lBIJs8Urje43HB2H',
  placeholder:'Just go go',
  path: window.location.pathname,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>